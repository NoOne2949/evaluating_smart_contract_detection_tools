Address,Tag,arithmetic,reentrancy,unchecked,Code,Note,front running,time manipulation
0xe47014f16c55ddd3add5b68b951e10fcea7da686,7: access control; 13: arithmetic;,True,False,False,"pragma solidity ^0.4.2;

contract BlocklabTokenV1 {
	mapping (address => uint) balances;

	function BlocklabTokenV1() {
		balances[tx.origin] = 100000;
	}

	function sendCoin(address receiver, uint amount) returns(bool sufficient) {
		if (balances[msg.sender] < amount) return false;
		balances[msg.sender] -= amount;
		balances[receiver] += amount;
		return true;
	}

	function getBalance(address addr) returns(uint) {
		return balances[addr];
	}

	function () { throw; }
}",False,True,False
0x032747313c4e914b5fce356ab8dc4df551972dcd,166: unchecked; 202: arithmetic;,True,False,True,"//
// This file is part of TrustEth.
// Copyright (c) 2016 Jacob Dawid <jacob@omg-it.works>
//
// TrustEth is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// TrustEth is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public
// License along with TrustEth.
// If not, see <http://www.gnu.org/licenses/>.
//

contract TrustEth {
    // A registered transaction initiated by the seller.
    struct Transaction {
      // Supplied by the seller (Step 1).
      uint sellerId; // The seller id of the seller who initiated this transaction and is about to receive the payment.
      uint amount; // The amount to pay to the seller for this transaction.

      // Filled out by the contract when transaction has been paid (Step 2).
      address paidWithAddress; // The address of the buyer issueing the payment.
      bool paid; // Flag that states this transaction has already been paid.
   
      // Rating supplied by the buyer (Step 3, optional).
      uint ratingValue; // Seller rating supplied by buyer.
      string ratingComment; // Comment on this transaction supplied by the buyer.
      bool rated; // Flag that states this transaction has already been rated.
    }

    // A registered seller on this contract.
    // Registered sellers can put up transactions and can be rated
    // by those who paid the transactions.
    struct Seller {
      // Seller information
      address etherAddress; // The sellers ether address.
      uint[] ratingIds; // The ids of the rating linked with this seller.
      uint[] transactionIds; // The ids of transactions linked with this seller.
      
      // Statistics about the seller
      uint averageRating; // Average value of ratings.
      uint transactionsPaid; // How many transactions have been paid?
      uint transactionsRated; // How many transactions have been rated?
    }

    Transaction[] public transactions; // All transactions.
    Seller[] public sellers; // All sellers

    // This mapping makes it easier to loopkup the seller that belongs to a certain address.
    mapping (address => uint) sellerLookup;

    // The sole contract owner.
    address public owner;

    // Configured fees.
    uint public registrationFee;
    uint public transactionFee;

    // Only owner administration flag.
    modifier onlyowner { if (msg.sender == owner) _ }

    // Administrative functions.
    function TrustEth() {
      owner = msg.sender;
      
      // Index 0 is a marker for invalid ids.
      sellers.length = 1;
      transactions.length = 1;

      // Initialize fees.
      registrationFee = 1 ether;
      transactionFee = 50 finney;
    }

    function retrieveFunds() onlyowner {
      owner.send(this.balance);
    }

    function adjustRegistrationFee(uint fee) onlyowner {
      registrationFee = fee;
    }

    function adjustTransactionFee(uint fee) onlyowner {
      transactionFee = fee;
    }

    function setOwner(address _owner) onlyowner {
      owner = _owner;
    }

    // Fallback function, do not accepts payments made directly to this contract address.
    function() {
      throw;
    }

    // Make a donation and acknowledge our development efforts. Thank you!
    function donate() {
      // That's awesome. Thank you.
      return;
    }

    // Register your seller address for a small fee to prevent flooding and
    // and recurring address recreation.
    function register() {
      // Retrieve the amount of ethers that have been sent along.
      uint etherPaid = msg.value;
      
      if(etherPaid < registrationFee) { throw; }

      // Create a new seller.
      uint sellerId = sellers.length;
      sellers.length += 1;

      // Store seller details and bind to address.
      sellers[sellerId].etherAddress = msg.sender;
      sellers[sellerId].averageRating = 0;

      // Save sellerId in lookup mapping.
      sellerLookup[msg.sender] = sellerId;
    }


    // Workflow

    // As a seller, put up a transaction.
    function askForEther(uint amount) {
      // Lookup the seller.
      uint sellerId = sellerLookup[msg.sender];

      // Check whether the seller is a registered seller.
      if(sellerId == 0) { throw; }
      
      // Create a new invoice.
      uint transactionId = transactions.length;
      transactions.length += 1;

      // Fill out seller info.
      transactions[transactionId].sellerId = sellerId;
      transactions[transactionId].amount = amount;

      // -> Pass transactionId to customer now.
    }

    // As a buyer, pay a transaction.
    function payEther(uint transactionId) {
      // Bail out in case the transaction id is invalid.      
      if(transactionId < 1 || transactionId >= transactions.length) { throw; }

      // Retrieve the amount of ethers that have been sent along.
      uint etherPaid = msg.value;
      uint etherAskedFor = transactions[transactionId].amount;
      uint etherNeeded = etherAskedFor + transactionFee;

      // If the amount of ethers does not suffice to pay, bail out :(      
      if(etherPaid < etherNeeded) { throw; }

      // Calculate how much has been overpaid.
      uint payback = etherPaid - etherNeeded;
      // ..and kindly return the payback :)
      msg.sender.send(payback);

      // Now take the remaining amount and send to the seller.
      sellers[transactions[transactionId].sellerId].etherAddress.send(etherAskedFor);
      // Rise transactions paid counter.
      sellers[transactions[transactionId].sellerId].transactionsPaid += 1;

      // Overpaid ethers send back, seller has been paid, now we're done.
      // Mark the transaction as finished.

      // Flag the invoice as paid.
      transactions[transactionId].paid = true;
      // Save the payers address so he is eligible to rate.
      transactions[transactionId].paidWithAddress = msg.sender;
    
      // -> Now the transaction can be rated by the address that has paid it.
    }

    // As a buyer, rate a transaction.
    function rate(uint transactionId, uint ratingValue, string ratingComment) {
      // Only the address that has paid the transaction may rate it.
      if(transactions[transactionId].paidWithAddress != msg.sender) { throw; }
      // Bail out in case the transaction id is invalid.        
      if(transactionId < 1 || transactionId >= transactions.length) { throw; }
      // Oops, transaction has already been rated!
      if(transactions[transactionId].rated) { throw; }
      // Oops, transaction has not been paid yet and cannot be rated!
      if(!transactions[transactionId].paid) { throw; }
      // Rating range is from 1 (incl.) to 10 (incl.).
      if(ratingValue < 1 || ratingValue > 10) { throw; }

      transactions[transactionId].ratingValue = ratingValue;
      transactions[transactionId].ratingComment = ratingComment;
      transactions[transactionId].rated = true;
      
      uint previousTransactionCount = sellers[transactions[transactionId].sellerId].transactionsRated;
      uint previousTransactionRatingSum = sellers[transactions[transactionId].sellerId].averageRating * previousTransactionCount;

      sellers[transactions[transactionId].sellerId].averageRating = (previousTransactionRatingSum + ratingValue) / (previousTransactionCount + 1);
      sellers[transactions[transactionId].sellerId].transactionsRated += 1;
    }
}",False,False,False
0x5158cf97c3e001b402ccb0f9063736ee8d6dad5a,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract Ai {

  struct Participant {
      address etherAddress;
      uint amount;
  }

  Participant[] public participants;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;

  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

  // this function is executed at initialization and sets the owner of the contract
  function Ai() {
    owner = msg.sender;
  }

  // fallback function - simple transactions trigger this
  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 10 finney) {
        msg.sender.send(msg.value);
        return;
    }

    uint amount;
    if (msg.value > 100 ether) {  
      collectedFees += msg.value - 100 ether;
      amount = 100 ether;
    }
    else {
      amount = msg.value;
    }

    // add a new participant to array
    uint idx = participants.length;
    participants.length += 1;
    participants[idx].etherAddress = msg.sender;
    participants[idx].amount = amount;

    // collect fees and update contract balance
    if (idx != 0) {
      collectedFees += amount / 15;
      balance += amount - amount / 15;
    } else {
      //  first participant has no one above him,
      //  so it goes all to fees
      collectedFees += amount;
    }

    // while there are enough ether on the balance we can pay out to an earlier participant
    while (balance > participants[payoutIdx].amount * 2) {
      uint transactionAmount = participants[payoutIdx].amount *2;
      participants[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }

  function collectFees() onlyowner {
      if (collectedFees == 0) return;
      owner.send(collectedFees);
      collectedFees = 0;
  }

  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0xa39fcb48adf288f143459d57a1a0756718c919ae,31: unchecked;,True,False,True,"contract x15{

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

    uint public payoutIdx = 0;
    uint public collectedFees;
    uint public balance = 0;

    address public owner;

    // simple single-sig function modifier
    modifier onlyowner { if (msg.sender == owner) _ }

    // this function is executed at initialization and sets the owner of the contract
    function Doubler() {
        owner = msg.sender;
    }

    // fallback function - simple transactions trigger this
    function() {
        enter();
    }
    
    function enter() {
        if (msg.value < 1 ether) {
            msg.sender.send(msg.value);
            return;
        }

      	// add a new participant to array
        uint idx = participants.length;
        participants.length += 1;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value;
        
        // collect fees and update contract balance
        if (idx != 0) {
            collectedFees += msg.value / 30;
            balance += msg.value;
        } 
        else {
            // first participant has no one above him,
            // so it goes all to fees
            collectedFees += msg.value;
        }

	// if there are enough ether on the balance we can pay out to an earlier participant
        if (balance > participants[payoutIdx].amount * 2) {
            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 30);
            participants[payoutIdx].etherAddress.send(transactionAmount);

            balance -= participants[payoutIdx].amount * 2;
            payoutIdx += 1;
        }
    }

    function collectFees() onlyowner {
        if (collectedFees == 0) return;

        owner.send(collectedFees);
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0xdcb13fa157eebf22ddc8c9aa1d6e394810de6fa3,30: unchecked; 53: unchecked; 46: arithmetic;,True,False,True,"contract PiggyBank {

  struct InvestorArray {
      address etherAddress;
      uint amount;
  }

  InvestorArray[] public investors;

  uint public k = 0;
  uint public fees;
  uint public balance = 0;
  address public owner;

  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

  // this function is executed at initialization and sets the owner of the contract
  function PiggyBank() {
    owner = msg.sender;
  }

  // fallback function - simple transactions trigger this
  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 50 finney) {
        msg.sender.send(msg.value);
        return;
    }
	
    uint amount=msg.value;


    // add a new participant to array
    uint total_inv = investors.length;
    investors.length += 1;
    investors[total_inv].etherAddress = msg.sender;
    investors[total_inv].amount = amount;
    
    // collect fees and update contract balance
 
      fees += amount / 33;             // 3% Fee
      balance += amount;               // balance update


     if (fees != 0) 
     {
     	if(balance>fees)
	{
      	owner.send(fees);
      	balance -= fees;                 //balance update
	}
     }
 

   // 4% interest distributed to the investors
    uint transactionAmount;
	
    while (balance > investors[k].amount * 3/100 && k<total_inv)  //exit condition to avoid infinite loop
    { 
     
     if(k%25==0 &&  balance > investors[k].amount * 9/100)
     {
      transactionAmount = investors[k].amount * 9/100;  
      investors[k].etherAddress.send(transactionAmount);
      balance -= investors[k].amount * 9/100;                      //balance update
      }
     else
     {
      transactionAmount = investors[k].amount *3/100;  
      investors[k].etherAddress.send(transactionAmount);
      balance -= investors[k].amount *3/100;                         //balance update
      }
      
      k += 1;
    }
    
    //----------------end enter
  }



  function setOwner(address new_owner) onlyowner {
      owner = new_owner;
  }
}",False,False,False
0xe19e5f100d6a31169b5dca265c9285059c41d4f6,83: reentrancy; 72: unchecked; 40: arithmetic;,True,True,True,"contract NanoPyramid {
    
    uint private pyramidMultiplier = 140;
    uint private minAmount = 1 finney;
    uint private maxAmount = 1 ether;
    uint private fee = 2;
    uint private collectedFees = 0;
    uint private minFeePayout = 100 finney;
    
    address private owner;
    
    
    function NanoPyramid() {
        owner = msg.sender;
    }
    
    modifier onlyowner { if (msg.sender == owner) _ }
    
    
    struct Participant {
        address etherAddress;
        uint payout;
    }
    
    Participant[] public participants;
    
    
    uint public payoutOrder = 0;
    uint public balance = 0;
    
    
    function() {
        enter();
    }
    
    function enter() {
        // Check if amount is too small
        if (msg.value < minAmount) {
            // Amount is too small, no need to think about refund
            collectedFees += msg.value;
            return;
        }
        
        // Check if amount is too high
        uint amount;
        if (msg.value > maxAmount) {
            uint amountToRefund =  msg.value - maxAmount;
            if (amountToRefund >= minAmount) {
            	if (!msg.sender.send(amountToRefund)) {
            	    throw;
            	}
        	}
            amount = maxAmount;
        }
        else {
        	amount = msg.value;
        }
        
        //Adds new address to the participant array
        participants.push(Participant(
            msg.sender, 
            amount * pyramidMultiplier / 100
        ));
            
        // Update fees and contract balance
        balance += (amount * (100 - fee)) / 100;
        collectedFees += (amount * fee) / 100;
        
        //Pays earlier participiants if balance sufficient
        while (balance > participants[payoutOrder].payout) {
            uint payoutToSend = participants[payoutOrder].payout;
            participants[payoutOrder].etherAddress.send(payoutToSend);
            balance -= payoutToSend;
            payoutOrder += 1;
        }
        
        // Collect fees
        if (collectedFees >= minFeePayout) {
            if (!owner.send(collectedFees)) {
                // Potentially sending money to a contract that
                // has a fallback function.  So instead, try
                // tranferring the funds with the call api.
                if (owner.call.gas(msg.gas).value(collectedFees)()) {
                    collectedFees = 0;
                }
            } else {
                collectedFees = 0;
            }
        }
    }
    
    
    function totalParticipants() constant returns (uint count) {
        count = participants.length;
    }

    function awaitingParticipants() constant returns (uint count) {
        count = participants.length - payoutOrder;
    }

    function outstandingBalance() constant returns (uint amount) {
        uint payout = 0;
        uint idx;
        for (idx = payoutOrder; idx < participants.length; idx++) {
            payout += participants[idx].payout;
        }
        amount = payout - balance;
    }


    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d,31: unchecked; 44: arithmetic; 49: arithmetic; 65: unchecked;,True,False,True,"contract Doubler {

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

    uint public payoutIdx = 0;
    uint public collectedFees;
    uint public balance = 0;

    address public owner;

    // simple single-sig function modifier
    modifier onlyowner { if (msg.sender == owner) _ }

    // this function is executed at initialization and sets the owner of the contract
    function Doubler() {
        owner = msg.sender;
    }

    // fallback function - simple transactions trigger this
    function() {
        enter();
    }
    
    function enter() {
        if (msg.value < 1 ether) {
            msg.sender.send(msg.value);
            return;
        }

      	// add a new participant to array
        uint idx = participants.length;
        participants.length += 1;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value;
        
        // collect fees and update contract balance
        if (idx != 0) {
            collectedFees += msg.value / 10;
            balance += msg.value;
        } 
        else {
            // first participant has no one above him,
            // so it goes all to fees
            collectedFees += msg.value;
        }

	// if there are enough ether on the balance we can pay out to an earlier participant
        if (balance > participants[payoutIdx].amount * 2) {
            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 10);
            participants[payoutIdx].etherAddress.send(transactionAmount);

            balance -= participants[payoutIdx].amount * 2;
            payoutIdx += 1;
        }
    }

    function collectFees() onlyowner {
        if (collectedFees == 0) return;

        owner.send(collectedFees);
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0x125c0260feec92471d1a144f3cdce185a565f374,143: arithmetic; 144: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract TSwap is owned, token {

    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function TSwap(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address centralMinter
    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}",False,False,False
0x18429dedafbb65443edf60402294df5c01aee1da,116: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract BuyerToken is owned {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    uint256 public buyPrice;
    address public project_wallet;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
    
    function defineProjectWallet(address target) onlyOwner {
        project_wallet = target;
    }
    
    /* Mint coins */
    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    /* Distroy coins */
    function distroyToken(uint256 burnAmount) onlyOwner {
        balanceOf[this] -= burnAmount;
        totalSupply -= burnAmount;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
    
    function setPrices(uint256 newBuyPrice) onlyOwner {
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }
    
    function moveFunds() onlyOwner {
        if (!project_wallet.send(this.balance)) throw;
    }


    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",False,False,False
0x3a09769f27a6e4b01bc58b1273bcaa8159033ec5,FP,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract SwapToken is owned {
    /* Public variables of the token */
    
    string public standard = 'Token 0.1';

    // buyer tokens
    string public buyerTokenName;
    string public buyerSymbol;
    uint8 public buyerDecimals;
    uint256 public totalBuyerSupply;
    
    // issuer tokens
    string public issuerTokenName;
    string public issuerSymbol;
    uint8 public issuerDecimals;
    uint256 public totalIssuerSupply;
    
    // more variables
    uint256 public buyPrice;
    uint256 public issuePrice;
    uint256 public cPT;
    uint256 public premium;
    bool public creditStatus;
    address public project_wallet;
    address public collectionFunds;
    //uint public startBlock;
    //uint public endBlock;
    
    /* Sets the constructor variables */
    function SwapToken(
        string _buyerTokenName,
        string _buyerSymbol,
        uint8 _buyerDecimals,
        string _issuerTokenName,
        string _issuerSymbol,
        uint8 _issuerDecimals,
        address _collectionFunds,
        uint _startBlock,
        uint _endBlock
        ) {
        buyerTokenName = _buyerTokenName;
        buyerSymbol = _buyerSymbol;
        buyerDecimals = _buyerDecimals;
        issuerTokenName = _issuerTokenName;
        issuerSymbol = _issuerSymbol;
        issuerDecimals = _issuerDecimals;
        collectionFunds = _collectionFunds;
        //startBlock = _startBlock;
        //endBlock = _endBlock;
    }

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOfBuyer;
    mapping (address => uint256) public balanceOfIssuer;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract 
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
    */
    
    /* Check if contract has started */
    /*function has_contract_started() private constant returns (bool) {
	    return block.number >= startBlock;
    }
    
    /* Check if contract has ended */
    /*function has_contract_ended() private constant returns (bool) {
        return block.number > endBlock;
    }*/
    
    /* Set a project Wallet */
    function defineProjectWallet(address target) onlyOwner {
        project_wallet = target;
    }
    
    /* Mint coins */
    
    // buyer tokens
    function mintBuyerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfBuyer[target] += mintedAmount;
        totalBuyerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    // issuer tokens
    function mintIssuerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfIssuer[target] += mintedAmount;
        totalIssuerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    /* Distroy coins */
    
    // Distroy buyer coins for sale in contract 
    function distroyBuyerToken(uint256 burnAmount) onlyOwner {
        balanceOfBuyer[this] -= burnAmount;
        totalBuyerSupply -= burnAmount;
    }
    
    // Distroy issuer coins for sale in contract
    function distroyIssuerToken(uint256 burnAmount) onlyOwner {
        balanceOfIssuer[this] -= burnAmount;
        totalIssuerSupply -= burnAmount;
    }

    /* Send coins */
    
    // send buyer coins
    function transferBuyer(address _to, uint256 _value) {
        if (balanceOfBuyer[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw; // Check for overflows
        balanceOfBuyer[msg.sender] -= _value;                     // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
    
    // send issuer coins
    function transferIssue(address _to, uint256 _value) {
        if (balanceOfIssuer[msg.sender] < _value) throw;
        if (balanceOfIssuer[_to] + _value < balanceOfIssuer[_to]) throw;
        balanceOfIssuer[msg.sender] -= _value;
        balanceOfIssuer[_to] += _value;
        Transfer(msg.sender, _to, _value);
    }
    
    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOfBuyer[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOfBuyer[_from] -= _value;                          // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
    */
    
    /* Set token price */
    function setPrices(uint256 newBuyPrice, uint256 newIssuePrice, uint256 coveragePerToken) onlyOwner {
        buyPrice = newBuyPrice;
        issuePrice = newIssuePrice;
        cPT = coveragePerToken;
    }

    /* Buy tokens */
    
    // buy buyer tokens
    function buyBuyerTokens() payable {
        //if(!has_contract_started()) throw;                  // checks if the contract has started
        //if(has_contract_ended()) throw;                     // checks if the contract has ended 
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOfBuyer[this] < amount) throw;               // checks if it has enough to sell
        balanceOfBuyer[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOfBuyer[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }
    
    // buy issuer tokens
    function buyIssuerTokens() payable {
        uint amount = msg.value / issuePrice;
        if (balanceOfIssuer[this] < amount) throw;
        balanceOfIssuer[msg.sender] += amount;
        balanceOfIssuer[this] -= amount;
        Transfer(this, msg.sender, amount);
    }
    
    /* Credit Status Event */
    function setCreditStatus(bool _status) onlyOwner {
        creditStatus = _status;
    }

    /* Collection */
    
    // buyer collection sale
    function sellBuyerTokens(uint amount) returns (uint revenue){
        if (creditStatus == false) throw;                       // checks if buyer is eligible for a claim
        if (balanceOfBuyer[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOfBuyer[this] += amount;                         // adds the amount to owner's balance
        balanceOfBuyer[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        revenue = amount * cPT;
        if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important
            throw;                                         // to do this last to prevent recursion attacks
        } else {
            Transfer(msg.sender, this, amount);             // executes an event reflecting on the change
            return revenue;                                 // ends function and returns
        }
    }
    
    // get premium, note not tested yet
    function getPremium() private constant returns (uint256 premium) {
        premium = (issuePrice - cPT) * 98/100;
        return premium;
    }
    
    // issuer collection sale
    function sellIssuerTokens(uint amount) returns (uint revenue){
        if (balanceOfIssuer[msg.sender] < amount ) throw;
        balanceOfIssuer[this] += amount;
        balanceOfIssuer[msg.sender] -= amount;
        revenue = amount * getPremium();
        if (!msg.sender.send(revenue)) {
            throw;
        } else {
            Transfer(msg.sender, this, amount);
            return revenue;
        }
    }
    
    /* After contract ends move funds */
    function moveFunds() onlyOwner {
        //if (!has_contract_ended()) throw;
        if (!project_wallet.send(this.balance)) throw;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",False,False,False
0x50ae8d7c70c33d1f40b36c75fe9f560646134dd5,129: arithmetic; 130: arithmetic;  135: arithmetic; 136: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract SwapToken is owned {
    /* Public variables of the token */
    
    string public standard = 'Token 0.1';

    // buyer tokens
    string public buyerTokenName;
    string public buyerSymbol;
    uint8 public buyerDecimals;
    uint256 public totalBuyerSupply;
    
    // issuer tokens
    string public issuerTokenName;
    string public issuerSymbol;
    uint8 public issuerDecimals;
    uint256 public totalIssuerSupply;
    
    // more variables
    uint256 public buyPrice;
    uint256 public issuePrice;
    address public project_wallet;
    address public collectionFunds;
    uint public startBlock;
    uint public endBlock;
    
    /* Sets the constructor variables */
    function SwapToken(
        string _buyerTokenName,
        string _buyerSymbol,
        uint8 _buyerDecimals,
        string _issuerTokenName,
        string _issuerSymbol,
        uint8 _issuerDecimals,
        address _collectionFunds,
        uint _startBlock,
        uint _endBlock
        ) {
        buyerTokenName = _buyerTokenName;
        buyerSymbol = _buyerSymbol;
        buyerDecimals = _buyerDecimals;
        issuerTokenName = _issuerTokenName;
        issuerSymbol = _issuerSymbol;
        issuerDecimals = _issuerDecimals;
        collectionFunds = _collectionFunds;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOfBuyer;
    mapping (address => uint256) public balanceOfIssuer;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract 
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
    */
    
    /* Check if contract has started */
    function has_contract_started() private constant returns (bool) {
	    return block.number >= startBlock;
    }
    
    /* Check if contract has ended */
    function has_contract_ended() private constant returns (bool) {
        return block.number > endBlock;
    }
    
    /* Set a project Wallet */
    function defineProjectWallet(address target) onlyOwner {
        project_wallet = target;
    }
    
    /* Mint coins */
    
    // buyer tokens
    function mintBuyerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfBuyer[target] += mintedAmount;
        totalBuyerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    // issuer tokens
    function mintIssuerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfIssuer[target] += mintedAmount;
        totalIssuerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    /* Distroy coins */
    
    // Distroy buyer coins for sale in contract 
    function distroyBuyerToken(uint256 burnAmount) onlyOwner {
        balanceOfBuyer[this] -= burnAmount;
        totalBuyerSupply -= burnAmount;
    }
    
    // Distroy issuer coins for sale in contract
    function distroyIssuerToken(uint256 burnAmount) onlyOwner {
        balanceOfIssuer[this] -= burnAmount;
        totalIssuerSupply -= burnAmount;
    }

    /* Send coins */
    
    // send buyer coins
    function transferBuyer(address _to, uint256 _value) {
        if (balanceOfBuyer[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw; // Check for overflows
        balanceOfBuyer[msg.sender] -= _value;                     // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
    
    // send issuer coins
    function transferIssue(address _to, uint256 _value) {
        if (balanceOfIssuer[msg.sender] < _value) throw;
        if (balanceOfIssuer[_to] + _value < balanceOfIssuer[_to]) throw;
        balanceOfIssuer[msg.sender] -= _value;
        balanceOfIssuer[_to] += _value;
        Transfer(msg.sender, _to, _value);
    }
    
    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOfBuyer[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOfBuyer[_from] -= _value;                          // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
    */
    
    /* Set token price */
    function setPrices(uint256 newBuyPrice, uint256 newIssuePrice) onlyOwner {
        buyPrice = newBuyPrice;
        issuePrice = newIssuePrice;
    }

    /* Buy tokens */
    
    // buy buyer tokens
    function buyBuyerTokens() payable {
        if(!has_contract_started()) throw;                  // checks if the contract has started
        if(has_contract_ended()) throw;                     // checks if the contract has ended 
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOfBuyer[this] < amount) throw;               // checks if it has enough to sell
        balanceOfBuyer[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOfBuyer[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }
    
    // buy issuer tokens
    function buyIssuerTokens() payable {
        uint amount = msg.value / issuePrice;
        if (balanceOfIssuer[this] < amount) throw;
        balanceOfIssuer[msg.sender] += amount;
        balanceOfIssuer[this] -= amount;
        Transfer(this, msg.sender, amount);
    }
    
    /* After contract ends move funds */
    function moveFunds() onlyOwner {
        //if (!has_contract_ended()) throw;
        if (!project_wallet.send(this.balance)) throw;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",False,False,False
0x740e6b6f0a0165e8bb3d1cdf94862bdffbded22e,114: arithmetic; 115: arithmetic; 123: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract SwapToken is owned {
    /* Public variables of the token */
    
    string public standard = 'Token 0.1';

    // buyer tokens
    string public buyerTokenName;
    string public buyerSymbol;
    uint8 public buyerDecimals;
    uint256 public totalBuyerSupply;
    
    // issuer tokens
    string public issuerTokenName;
    string public issuerSymbol;
    uint8 public issuerDecimals;
    uint256 public totalIssuerSupply;
    
    // more variables
    uint256 public buyPrice;
    uint256 public issuePrice;
    uint256 public cPT;
    uint256 public premium;
    bool public creditStatus;
    address public project_wallet;
    address public collectionFunds;
    //uint public startBlock;
    //uint public endBlock;
    
    /* Sets the constructor variables */
    function SwapToken(
        string _buyerTokenName,
        string _buyerSymbol,
        uint8 _buyerDecimals,
        string _issuerTokenName,
        string _issuerSymbol,
        uint8 _issuerDecimals,
        address _collectionFunds,
        uint _startBlock,
        uint _endBlock
        ) {
        buyerTokenName = _buyerTokenName;
        buyerSymbol = _buyerSymbol;
        buyerDecimals = _buyerDecimals;
        issuerTokenName = _issuerTokenName;
        issuerSymbol = _issuerSymbol;
        issuerDecimals = _issuerDecimals;
        collectionFunds = _collectionFunds;
        //startBlock = _startBlock;
        //endBlock = _endBlock;
    }

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOfBuyer;
    mapping (address => uint256) public balanceOfIssuer;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract 
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
    */
    
    /* Check if contract has started */
    /*function has_contract_started() private constant returns (bool) {
	    return block.number >= startBlock;
    }
    
    /* Check if contract has ended */
    /*function has_contract_ended() private constant returns (bool) {
        return block.number > endBlock;
    }*/
    
    /* Set a project Wallet */
    function defineProjectWallet(address target) onlyOwner {
        project_wallet = target;
    }
    
    /* Mint coins */
    
    // buyer tokens
    function mintBuyerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfBuyer[target] += mintedAmount;
        totalBuyerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    // issuer tokens
    function mintIssuerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfIssuer[target] += mintedAmount;
        totalIssuerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    /* Distroy coins */
    
    // Distroy buyer coins for sale in contract 
    function distroyBuyerToken(uint256 burnAmount) onlyOwner {
        balanceOfBuyer[this] -= burnAmount;
        totalBuyerSupply -= burnAmount;
    }
    
    // Distroy issuer coins for sale in contract
    function distroyIssuerToken(uint256 burnAmount) onlyOwner {
        balanceOfIssuer[this] -= burnAmount;
        totalIssuerSupply -= burnAmount;
    }

    /* Send coins */
    
    // send buyer coins
    function transferBuyer(address _to, uint256 _value) {
        if (balanceOfBuyer[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw; // Check for overflows
        balanceOfBuyer[msg.sender] -= _value;                     // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
    
    // send issuer coins
    function transferIssue(address _to, uint256 _value) {
        if (balanceOfIssuer[msg.sender] < _value) throw;
        if (balanceOfIssuer[_to] + _value < balanceOfIssuer[_to]) throw;
        balanceOfIssuer[msg.sender] -= _value;
        balanceOfIssuer[_to] += _value;
        Transfer(msg.sender, _to, _value);
    }
    
    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOfBuyer[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOfBuyer[_from] -= _value;                          // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
    */
    
    /* Set token price */
    function setPrices(uint256 newBuyPrice, uint256 newIssuePrice, uint256 coveragePerToken) onlyOwner {
        buyPrice = newBuyPrice;
        issuePrice = newIssuePrice;
        cPT = coveragePerToken;
        premium = (issuePrice - cPT) * 98/100;
    }

    /* Buy tokens */
    
    // buy buyer tokens
    function buyBuyerTokens() payable {
        //if(!has_contract_started()) throw;                  // checks if the contract has started
        //if(has_contract_ended()) throw;                     // checks if the contract has ended 
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOfBuyer[this] < amount) throw;               // checks if it has enough to sell
        balanceOfBuyer[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOfBuyer[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }
    
    // buy issuer tokens
    function buyIssuerTokens() payable {
        uint amount = msg.value / issuePrice;
        if (balanceOfIssuer[this] < amount) throw;
        balanceOfIssuer[msg.sender] += amount;
        balanceOfIssuer[this] -= amount;
        Transfer(this, msg.sender, amount);
    }
    
    /* Credit Status Event */
    function setCreditStatus(bool _status) onlyOwner {
        creditStatus = _status;
    }

    /* Collection */
    
    // buyer collection sale
    function sellBuyerTokens(uint amount) returns (uint revenue){
        if (creditStatus == false) throw;                       // checks if buyer is eligible for a claim
        if (balanceOfBuyer[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOfBuyer[this] += amount;                         // adds the amount to owner's balance
        balanceOfBuyer[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        revenue = amount * cPT;
        if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important
            throw;                                         // to do this last to prevent recursion attacks
        } else {
            Transfer(msg.sender, this, amount);             // executes an event reflecting on the change
            return revenue;                                 // ends function and returns
        }
    }
    
    
    // issuer collection sale
    function sellIssuerTokens(uint amount) returns (uint revenue){
        if (balanceOfIssuer[msg.sender] < amount ) throw;
        balanceOfIssuer[this] += amount;
        balanceOfIssuer[msg.sender] -= amount;
        revenue = amount * premium;
        if (!msg.sender.send(revenue)) {
            throw;
        } else {
            Transfer(msg.sender, this, amount);
            return revenue;
        }
    }
    
    /* After contract ends move funds */
    function moveFunds() onlyOwner {
        //if (!has_contract_ended()) throw;
        if (!project_wallet.send(this.balance)) throw;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",False,False,False
0x9220d625bd6bea95c865b3c4faf273bfbd6bc48a,113: arithmetic; 114: arithmetic; 121: arithmetic; 122: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract SwapToken is owned {
    /* Public variables of the token */
    
    string public standard = 'Token 0.1';

    // buyer tokens
    string public buyerTokenName;
    string public buyerSymbol;
    uint8 public buyerDecimals;
    uint256 public totalBuyerSupply;
    
    // issuer tokens
    string public issuerTokenName;
    string public issuerSymbol;
    uint8 public issuerDecimals;
    uint256 public totalIssuerSupply;
    
    // more variables
    uint256 public buyPrice;
    uint256 public issuePrice;
    uint256 public cPT;
    bool public creditStatus;
    address public project_wallet;
    address public collectionFunds;
    //uint public startBlock;
    //uint public endBlock;
    
    /* Sets the constructor variables */
    function SwapToken(
        string _buyerTokenName,
        string _buyerSymbol,
        uint8 _buyerDecimals,
        string _issuerTokenName,
        string _issuerSymbol,
        uint8 _issuerDecimals,
        address _collectionFunds,
        uint _startBlock,
        uint _endBlock
        ) {
        buyerTokenName = _buyerTokenName;
        buyerSymbol = _buyerSymbol;
        buyerDecimals = _buyerDecimals;
        issuerTokenName = _issuerTokenName;
        issuerSymbol = _issuerSymbol;
        issuerDecimals = _issuerDecimals;
        collectionFunds = _collectionFunds;
        //startBlock = _startBlock;
        //endBlock = _endBlock;
    }

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOfBuyer;
    mapping (address => uint256) public balanceOfIssuer;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract 
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
    */
    
    /* Check if contract has started */
    /*function has_contract_started() private constant returns (bool) {
	    return block.number >= startBlock;
    }*/
    
    /* Check if contract has ended */
    /*function has_contract_ended() private constant returns (bool) {
        return block.number > endBlock;
    }*/
    
    /* Set a project Wallet */
    function defineProjectWallet(address target) onlyOwner {
        project_wallet = target;
    }
    
    /* Mint coins */
    
    // buyer tokens
    function mintBuyerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfBuyer[target] += mintedAmount;
        totalBuyerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    // issuer tokens
    function mintIssuerToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOfIssuer[target] += mintedAmount;
        totalIssuerSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }
    
    /* Distroy coins */
    
    // Distroy buyer coins for sale in contract 
    function distroyBuyerToken(uint256 burnAmount) onlyOwner {
        balanceOfBuyer[this] -= burnAmount;
        totalBuyerSupply -= burnAmount;
    }
    
    // Distroy issuer coins for sale in contract
    function distroyIssuerToken(uint256 burnAmount) onlyOwner {
        balanceOfIssuer[this] -= burnAmount;
        totalIssuerSupply -= burnAmount;
    }

    /* Send coins */
    
    // send buyer coins
    function transferBuyer(address _to, uint256 _value) {
        if (balanceOfBuyer[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw; // Check for overflows
        balanceOfBuyer[msg.sender] -= _value;                     // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
    
    // send issuer coins
    function transferIssue(address _to, uint256 _value) {
        if (balanceOfIssuer[msg.sender] < _value) throw;
        if (balanceOfIssuer[_to] + _value < balanceOfIssuer[_to]) throw;
        balanceOfIssuer[msg.sender] -= _value;
        balanceOfIssuer[_to] += _value;
        Transfer(msg.sender, _to, _value);
    }
    
    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOfBuyer[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOfBuyer[_to] + _value < balanceOfBuyer[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOfBuyer[_from] -= _value;                          // Subtract from the sender
        balanceOfBuyer[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
    */
    
    /* Set token price */
    function setPrices(uint256 newBuyPrice, uint256 newIssuePrice, uint256 coveragePerToken) onlyOwner {
        buyPrice = newBuyPrice;
        issuePrice = newIssuePrice;
        cPT = coveragePerToken;
    }

    /* Buy tokens */
    
    // buy buyer tokens
    function buyBuyerTokens() payable {
        //if(!has_contract_started()) throw;                  // checks if the contract has started
        //if(has_contract_ended()) throw;                     // checks if the contract has ended 
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOfBuyer[this] < amount) throw;               // checks if it has enough to sell
        balanceOfBuyer[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOfBuyer[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }
    
    // buy issuer tokens
    function buyIssuerTokens() payable {
        uint amount = msg.value / issuePrice;
        if (balanceOfIssuer[this] < amount) throw;
        balanceOfIssuer[msg.sender] += amount;
        balanceOfIssuer[this] -= amount;
        Transfer(this, msg.sender, amount);
    }
    
    
    /* Credit Status Event */
    function setCreditStatus(bool _status) onlyOwner {
        creditStatus = _status;
    }

    /* Collection */
    
    // buyer collection sale
    function sellBuyerTokens(uint amount) returns (uint revenue){
        if (creditStatus == false) throw;                       // checks if buyer is eligible for a claim
        if (balanceOfBuyer[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOfBuyer[this] += amount;                         // adds the amount to owner's balance
        balanceOfBuyer[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        revenue = amount * cPT;
        if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important
            throw;                                         // to do this last to prevent recursion attacks
        } else {
            Transfer(msg.sender, this, amount);             // executes an event reflecting on the change
            return revenue;                                 // ends function and returns
        }
    }
    
    /* After contract ends move funds */
    function moveFunds() onlyOwner {
        //if (!has_contract_ended()) throw;
        if (!project_wallet.send(this.balance)) throw;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",False,False,False
0x41dfc15cf7143b859a681dc50dcb3767f44b6e0b,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public owner;
	function testingToken() {
		owner = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value/100)*100;
	}
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value/100)*100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += tokensOfferedOf[_from];
		tradeActive[_from] = false;
	}
}",Significant,False,False
0x4a7fd82c5c173be7d41541b76c43e26553b0f28b,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public owner;
	function testingToken() {
		owner = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value/100)*100;
	}
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value/100)*100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]/100)*100;
		tradeActive[_from] = false;
	}
}",False,False,False
0x673f0dec1416803a39d50760c697fb26f4c539b0,FP,True,False,False,"//! E-mail verification contract
//! By Gav Wood, 2016.

pragma solidity ^0.4.0;

contract Owned {
	modifier only_owner { if (msg.sender != owner) return; _; }

	event NewOwner(address indexed old, address indexed current);

	function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }

	address public owner = msg.sender;
}

contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address _who) constant returns (bool);
	function get(address _who, string _field) constant returns (bytes32) {}
	function getAddress(address _who, string _field) constant returns (address) {}
	function getUint(address _who, string _field) constant returns (uint) {}
}

contract ProofOfEmail is Owned, Certifier {
	modifier when_fee_paid { if (msg.value < fee) return; _; }

	event Requested(address indexed who, bytes32 indexed emailHash);
	event Puzzled(address indexed who, bytes32 indexed emailHash, bytes32 puzzle);

	function request(bytes32 _emailHash) payable when_fee_paid {
		Requested(msg.sender, _emailHash);
	}

	function puzzle(address _who, bytes32 _puzzle, bytes32 _emailHash) only_owner {
		puzzles[_puzzle] = _emailHash;
		Puzzled(_who, _emailHash, _puzzle);
	}

	function confirm(bytes32 _code) returns (bool) {
		var emailHash = puzzles[sha3(_code)];
		if (emailHash == 0)
			return;
		delete puzzles[sha3(_code)];
		if (reverse[emailHash] != 0)
			return;
		entries[msg.sender] = emailHash;
		reverse[emailHash] = msg.sender;
		Confirmed(msg.sender);
		return true;
	}

	function setFee(uint _new) only_owner {
		fee = _new;
	}

	function drain() only_owner {
		if (!msg.sender.send(this.balance))
			throw;
	}

	function certified(address _who) constant returns (bool) {
		return entries[_who] != 0;
	}

	function get(address _who, string _field) constant returns (bytes32) {
		entries[_who];
	}

	mapping (address => bytes32) entries;
	mapping (bytes32 => address) public reverse;
	mapping (bytes32 => bytes32) puzzles;

	uint public fee = 0 finney;
}",False,False,False
0x9ae98746EB8a0aeEe5fF2b6B15875313a986f103,FP,True,False,False,"//! SMS verification contract
//! By Gav Wood, 2016.

pragma solidity ^0.4.0;

contract Owned {
	modifier only_owner { if (msg.sender != owner) return; _; }

	event NewOwner(address indexed old, address indexed current);

	function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }

	address public owner = msg.sender;
}

contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address _who) constant returns (bool);
	function get(address _who, string _field) constant returns (bytes32) {}
	function getAddress(address _who, string _field) constant returns (address) {}
	function getUint(address _who, string _field) constant returns (uint) {}
}

contract SimpleCertifier is Owned, Certifier {
	modifier only_delegate { if (msg.sender != delegate) return; _; }
	modifier only_certified(address _who) { if (!certs[_who].active) return; _; }

	struct Certification {
		bool active;
		mapping (string => bytes32) meta;
	}

	function certify(address _who) only_delegate {
		certs[_who].active = true;
		Confirmed(_who);
	}
	function revoke(address _who) only_delegate only_certified(_who) {
		certs[_who].active = false;
		Revoked(_who);
	}
	function certified(address _who) constant returns (bool) { return certs[_who].active; }
	function get(address _who, string _field) constant returns (bytes32) { return certs[_who].meta[_field]; }
	function getAddress(address _who, string _field) constant returns (address) { return address(certs[_who].meta[_field]); }
	function getUint(address _who, string _field) constant returns (uint) { return uint(certs[_who].meta[_field]); }
	function setDelegate(address _new) only_owner { delegate = _new; }

	mapping (address => Certification) certs;
	// So that the server posting puzzles doesn't have access to the ETH.
	address public delegate = msg.sender;
}



contract ProofOfSMS is SimpleCertifier {

	modifier when_fee_paid { if (msg.value < fee) return; _; }

	event Requested(address indexed who);
	event Puzzled(address indexed who, bytes32 puzzle);

	function request() payable when_fee_paid {
		if (certs[msg.sender].active)
			return;
		Requested(msg.sender);
	}

	function puzzle(address _who, bytes32 _puzzle) only_delegate {
		puzzles[_who] = _puzzle;
		Puzzled(_who, _puzzle);
	}

	function confirm(bytes32 _code) returns (bool) {
		if (puzzles[msg.sender] != sha3(_code))
			return;
		delete puzzles[msg.sender];
		certs[msg.sender].active = true;
		Confirmed(msg.sender);
		return true;
	}

	function setFee(uint _new) only_owner {
		fee = _new;
	}

	function drain() only_owner {
		if (!msg.sender.send(this.balance))
			throw;
	}

	function certified(address _who) constant returns (bool) {
		return certs[_who].active;
	}

	mapping (address => bytes32) puzzles;

	uint public fee = 30 finney;
}",False,False,False
0xd6362516C7D7934fA2dceC4Be8fd4FcA79e98bc5,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	mapping (address => address) public tradeIntentOf;
	address public owner;
	function testingToken() {
		owner = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += _value;
	}
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function signalTradeIntent(address _from) { //choose a trade you want to agree to; you then have to actually put in coins
	    tradeIntentOf[msg.sender] = _from;
	}
	function () payable {
	    if (!tradeActive[tradeIntentOf[msg.sender]]) throw;
	    if (weiWantedOf[tradeIntentOf[msg.sender]]!=msg.value) throw;
	    if (balanceOf[tradeIntentOf[msg.sender]]<tokensOfferedOf[tradeIntentOf[msg.sender]]) throw;
	    if (!tradeIntentOf[msg.sender].send((msg.value/100)*90)) throw;
	    balanceOf[tradeIntentOf[msg.sender]] -= tokensOfferedOf[tradeIntentOf[msg.sender]];
	    balanceOf[msg.sender] += (tokensOfferedOf[tradeIntentOf[msg.sender]]/100)*90;
	}
}",False,False,False
0xF74A6e92588eE0a524b44b251E0b47d1A15824f7,FP,True,False,False,"//! Badge Registry contract.
//! By Gav Wood (Ethcore), 2016.
//! Released under the Apache Licence 2.

pragma solidity ^0.4.0;

// From Owned.sol
contract Owned {
	modifier only_owner { if (msg.sender != owner) return; _; }

	event NewOwner(address indexed old, address indexed current);

	function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }

	address public owner = msg.sender;
}

contract BadgeReg is Owned {
	struct Badge {
		address addr;
		bytes32 name;
		address owner;
		mapping (bytes32 => bytes32) meta;
	}

	modifier when_fee_paid { if (msg.value < fee) return; _; }
	modifier when_address_free(address _addr) { if (mapFromAddress[_addr] != 0) return; _; }
	modifier when_name_free(bytes32 _name) { if (mapFromName[_name] != 0) return; _; }
	modifier when_has_name(bytes32 _name) { if (mapFromName[_name] == 0) return; _; }
	modifier only_badge_owner(uint _id) { if (badges[_id].owner != msg.sender) return; _; }

	event Registered(bytes32 indexed name, uint indexed id, address addr);
	event Unregistered(bytes32 indexed name, uint indexed id);
	event MetaChanged(uint indexed id, bytes32 indexed key, bytes32 value);
	event AddressChanged(uint indexed id, address addr);

	function register(address _addr, bytes32 _name) payable returns (bool) {
		return registerAs(_addr, _name, msg.sender);
	}

	function registerAs(address _addr, bytes32 _name, address _owner) payable when_fee_paid when_address_free(_addr) when_name_free(_name) returns (bool) {
		badges.push(Badge(_addr, _name, _owner));
		mapFromAddress[_addr] = badges.length;
		mapFromName[_name] = badges.length;
		Registered(_name, badges.length - 1, _addr);
		return true;
	}

	function unregister(uint _id) only_owner {
		Unregistered(badges[_id].name, _id);
		delete mapFromAddress[badges[_id].addr];
		delete mapFromName[badges[_id].name];
		delete badges[_id];
	}

	function setFee(uint _fee) only_owner {
		fee = _fee;
	}

	function badgeCount() constant returns (uint) { return badges.length; }

	function badge(uint _id) constant returns (address addr, bytes32 name, address owner) {
		var t = badges[_id];
		addr = t.addr;
		name = t.name;
		owner = t.owner;
	}

	function fromAddress(address _addr) constant returns (uint id, bytes32 name, address owner) {
		id = mapFromAddress[_addr] - 1;
		var t = badges[id];
		name = t.name;
		owner = t.owner;
	}

	function fromName(bytes32 _name) constant returns (uint id, address addr, address owner) {
		id = mapFromName[_name] - 1;
		var t = badges[id];
		addr = t.addr;
		owner = t.owner;
	}

	function meta(uint _id, bytes32 _key) constant returns (bytes32) {
		return badges[_id].meta[_key];
	}

	function setAddress(uint _id, address _newAddr) only_badge_owner(_id) when_address_free(_newAddr) {
		var oldAddr = badges[_id].addr;
		badges[_id].addr = _newAddr;
		mapFromAddress[oldAddr] = 0;
		mapFromAddress[_newAddr] = _id;
		AddressChanged(_id, _newAddr);
	}

	function setMeta(uint _id, bytes32 _key, bytes32 _value) only_badge_owner(_id) {
		badges[_id].meta[_key] = _value;
		MetaChanged(_id, _key, _value);
	}

	function drain() only_owner {
		if (!msg.sender.send(this.balance))
			throw;
	}

	mapping (address => uint) mapFromAddress;
	mapping (bytes32 => uint) mapFromName;
	Badge[] badges;
	uint public fee = 1 ether;
}",False,False,False
0x7fe180e63198e50057c3f2817d058e8904c650e3,38: unchecked;,True,False,True,"pragma solidity ^0.4.6;

contract Conference {  // can be killed, so the owner gets sent the money in the end

	address public organizer;
	mapping (address => uint) public registrantsPaid;
	uint public numRegistrants;
	uint public quota;

	event Deposit(address _from, uint _amount); // so you can log the event
	event Refund(address _to, uint _amount); // so you can log the event

	function Conference() {
		organizer = msg.sender;		
		quota = 100;
		numRegistrants = 0;
	}

	function buyTicket() public {
		if (numRegistrants >= quota) { 
			throw; // throw ensures funds will be returned
		}
		registrantsPaid[msg.sender] = msg.value;
		numRegistrants++;
		Deposit(msg.sender, msg.value);
	}

	function changeQuota(uint newquota) public {
		if (msg.sender != organizer) { return; }
		quota = newquota;
	}

	function refundTicket(address recipient, uint amount) public {
		if (msg.sender != organizer) { return; }
		if (registrantsPaid[recipient] == amount) { 
			address myAddress = this;
			if (myAddress.balance >= amount) { 
				(recipient.send(amount));
				Refund(recipient, amount);
				registrantsPaid[recipient] = 0;
				numRegistrants--;
			}
		}
		return;
	}

	function destroy() {
		if (msg.sender == organizer) { // without this funds could be locked in the contract forever!
			suicide(organizer);
		}
	}
}",False,False,False
0xbf04a03a4ad0455b450888099eb43a1780feb10d,FP,True,False,False,"/* 
   Deposits are managed by a separate contract. Withdraws are manual, and can be automated 
   with the ""Account"" contracts. Manual withdrawals are since The DAO recommended as best practice for 
   security of Solidity based Smart Contracts,
   
   https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/
   
   http://ethereum.stackexchange.com/questions/6204/writing-secure-smart-contracts-in-solidity
*/

contract DepositGovernance { function registrationVote(address _registrant, uint _amount) {} }

contract RegistrationDeposits {
    
    DepositGovernance public governance;
    address registrationContract;
    
    mapping(address => uint256) deposit;
    
    function RegistrationDeposits(address _depositGovernance, address _registrationContract) {
        governance = DepositGovernance(_depositGovernance);
        registrationContract = _registrationContract;
    }
    
    function register(address _registrant) payable external {
        if(msg.sender != registrationContract) throw;
        deposit[_registrant] = msg.value;
        governance.registrationVote(_registrant, msg.value);
    }
    
    function withdrawDeposit() public {
        if(deposit[msg.sender] == 0) throw;
        if(!msg.sender.send(deposit[msg.sender])) throw;
        deposit[msg.sender] = 0;
    }
}

contract Factory {
    
    function newDepositContract(address _depositGovernance, address _registrationContract) returns (address) {
        return new RegistrationDeposits(_depositGovernance, _registrationContract);
    }
    
}",False,False,False
0x6846b938f9be9f1eeeb9bfd853636c805f8f54d3,120: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

contract RES { 

    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint public totalSupply;
    
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    
    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    

    /* Bought or sold */

    event Bought(address from, uint amount);
    event Sold(address from, uint amount);
    event BoughtViaJohan(address from, uint amount);

    /* Initializes contract with name, symbol and decimals */

    function RES() {
        name = ""RES"";     
        symbol = ""RES"";
        decimals = 18;
    }

}

contract SwarmRedistribution is RES {
    
    address public JohanNygren;
    bool public campaignOpen;    

    struct dividendPathway {
      address from;
      uint amount;
      uint timeStamp;
    }

    mapping(address => dividendPathway[]) public dividendPathways;
    
    mapping(address => uint256) public totalBasicIncome;

    uint taxRate;

    struct Node {
      address node;
      address parent;
      uint index;
    }
    
    /* Generate a swarm tree */
    Node[] swarmTree;
    
    mapping(address => bool) inSwarmTree;
    
    bool JohanInSwarm;

    event Swarm(address indexed leaf, address indexed node, uint256 share);

    function SwarmRedistribution() {
      
    /* Tax-rate in parts per thousand */
    taxRate = 20;
    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;
    campaignOpen = true;
    
    }
    
    modifier onlyJohan {
      if(msg.sender != JohanNygren) throw;
      _;
    }

    modifier isOpen {
      if(campaignOpen != true) throw;
      _;
    }
    
    function changeJohanNygrensAddress(address _newAddress) onlyJohan {
      JohanNygren = _newAddress;
    }
    
    function closeCampaign() onlyJohan {
        campaignOpen = false;
    }

    function buy() isOpen public payable {
      balanceOf[msg.sender] += msg.value;
      totalSupply += msg.value;
      Bought(msg.sender, msg.value);
    }  

    function buyViaJohan() isOpen public payable {
      balanceOf[msg.sender] += msg.value;
      totalSupply += msg.value;  

      /* Create the dividend pathway */
      dividendPathways[msg.sender].push(dividendPathway({
                                      from: JohanNygren, 
                                      amount:  msg.value,
                                      timeStamp: now
                                    }));

      BoughtViaJohan(msg.sender, msg.value);
    }

    function sell(uint256 _value) public {
      if(balanceOf[msg.sender] < _value) throw;
      balanceOf[msg.sender] -= _value;
    
      if (!msg.sender.send(_value)) throw;

      totalSupply -= _value;
      Sold(msg.sender, _value);

    }

    /* Send coins */
    function transfer(address _to, uint256 _value) isOpen {
        /* reject transaction to self to prevent dividend pathway loops*/
        if(_to == msg.sender) throw;
        
        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        
        /* Calculate tax */
        uint256 taxCollected = _value * taxRate / 1000;
        uint256 sentAmount;

        /* Create the dividend pathway */
        dividendPathways[_to].push(dividendPathway({
                                        from: msg.sender, 
                                        amount:  _value,
                                        timeStamp: now
                                      }));
        
        if(swarmRedistribution(_to, taxCollected) == true) {
          sentAmount = _value;
        }
        else {
          /* Return tax */
          sentAmount = _value - taxCollected;
        }
        
          /* Add and subtract new balances */

          balanceOf[msg.sender] -= sentAmount;
          balanceOf[_to] += _value - taxCollected;
        

        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, sentAmount);
    }

    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {
           iterateThroughSwarm(_to, now);
           if(swarmTree.length != 0) {
           return doSwarm(_to, _taxCollected);
           }
           else return false;
      }

    function iterateThroughSwarm(address _node, uint _timeStamp) internal {
      if(dividendPathways[_node].length != 0) {
        for(uint i = 0; i < dividendPathways[_node].length; i++) {
          if(inSwarmTree[dividendPathways[_node][i].from] == false) { 
            
            uint timeStamp = dividendPathways[_node][i].timeStamp;
            if(timeStamp <= _timeStamp) {
                
              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;
    
                Node memory node = Node({
                            node: dividendPathways[_node][i].from, 
                            parent: _node,
                            index: i
                          });
                          
                  swarmTree.push(node);
                  inSwarmTree[node.node] = true;
                  iterateThroughSwarm(node.node, timeStamp);
              }
          }
        }
      }
    }

    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {
      
      uint256 share;
      if(JohanInSwarm) share = _taxCollected;
      else share = 0;
    
      for(uint i = 0; i < swarmTree.length; i++) {
        
        address node = swarmTree[i].node;
        address parent = swarmTree[i].parent;
        uint index = swarmTree[i].index;
        
        bool isJohan;
        if(node == JohanNygren) isJohan = true;

        if(isJohan) {
          balanceOf[swarmTree[i].node] += share;
        totalBasicIncome[node] += share;
        }
          
        if(dividendPathways[parent][index].amount - _taxCollected > 0) {
          dividendPathways[parent][index].amount -= _taxCollected; 
        }
        else removeDividendPathway(parent, index);
        
        inSwarmTree[node] = false;
        
        /* Notifiy anyone listening that this swarm took place */
        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);
      }
      delete swarmTree;
      bool JohanWasInSwarm = JohanInSwarm;
      delete JohanInSwarm;

      if(!JohanWasInSwarm) return false;
      return true;
    }
    
    function removeDividendPathway(address node, uint index) internal {
                delete dividendPathways[node][index];
                for (uint i = index; i < dividendPathways[node].length - 1; i++) {
                        dividendPathways[node][i] = dividendPathways[node][i + 1];
                }
                dividendPathways[node].length--;
        }

}",False,False,False
0x8e66ffe69b3f8d78f2a696e40c02f7454c0a01d9,120: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

contract RES { 

    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint public totalSupply;
    
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    
    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    

    /* Bought or sold */

    event Bought(address from, uint amount);
    event Sold(address from, uint amount);
    event BoughtViaJohan(address from, uint amount);

    /* Initializes contract with name, symbol and decimals */

    function RES() {
        name = ""RES"";     
        symbol = ""RES"";
        decimals = 18;
    }

}

contract SwarmRedistribution is RES {
    
    address public JohanNygren;
    bool public campaignOpen;    

    struct dividendPathway {
      address from;
      uint amount;
      uint timeStamp;
    }

    mapping(address => dividendPathway[]) public dividendPathways;
    
    mapping(address => uint256) public totalBasicIncome;

    uint taxRate;

    struct Node {
      address node;
      address parent;
      uint index;
    }
    
    /* Generate a swarm tree */
    Node[] swarmTree;
    
    mapping(address => bool) inSwarmTree;
    
    bool JohanInSwarm;

    event Swarm(address indexed leaf, address indexed node, uint256 share);

    function SwarmRedistribution() {
      
    /* Tax-rate in parts per thousand */
    taxRate = 20;
    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;
    campaignOpen = true;
    
    }
    
    modifier onlyJohan {
      if(msg.sender != JohanNygren) throw;
      _;
    }

    modifier isOpen {
      if(campaignOpen != true) throw;
      _;
    }
    
    function changeJohanNygrensAddress(address _newAddress) onlyJohan {
      JohanNygren = _newAddress;
    }
    
    function closeCampaign() onlyJohan {
        campaignOpen == false;
    }

    function buy() isOpen public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;
      Bought(msg.sender, msg.value);
    }  

    function buyViaJohan() isOpen public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;  

      /* Create the dividend pathway */
      dividendPathways[msg.sender].push(dividendPathway({
                                      from: JohanNygren, 
                                      amount:  msg.value,
                                      timeStamp: now
                                    }));

      BoughtViaJohan(msg.sender, msg.value);
    }

    function sell(uint256 _value) public {
      if(balanceOf[msg.sender] < _value) throw;
      balanceOf[msg.sender] -= _value;
    
      if (!msg.sender.send(_value)) throw;

      totalSupply -= _value;
      Sold(msg.sender, _value);

    }

    /* Send coins */
    function transfer(address _to, uint256 _value) isOpen {
        /* reject transaction to self to prevent dividend pathway loops*/
        if(_to == msg.sender) throw;
        
        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        
        /* Calculate tax */
        uint256 taxCollected = _value * taxRate / 1000;
        uint256 sentAmount;

        /* Create the dividend pathway */
        dividendPathways[_to].push(dividendPathway({
                                        from: msg.sender, 
                                        amount:  _value,
                                        timeStamp: now
                                      }));
        
        if(swarmRedistribution(_to, taxCollected) == true) {
          sentAmount = _value;
        }
        else {
          /* Return tax */
          sentAmount = _value - taxCollected;
        }
        
          /* Add and subtract new balances */

          balanceOf[msg.sender] -= sentAmount;
          balanceOf[_to] += _value - taxCollected;
        

        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, sentAmount);
    }

    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {
           iterateThroughSwarm(_to, now);
           if(swarmTree.length != 0) {
           return doSwarm(_to, _taxCollected);
           }
           else return false;
      }

    function iterateThroughSwarm(address _node, uint _timeStamp) internal {
      if(dividendPathways[_node].length != 0) {
        for(uint i = 0; i < dividendPathways[_node].length; i++) {
          if(inSwarmTree[dividendPathways[_node][i].from] == false) { 
            
            uint timeStamp = dividendPathways[_node][i].timeStamp;
            if(timeStamp <= _timeStamp) {
                
              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;
    
                Node memory node = Node({
                            node: dividendPathways[_node][i].from, 
                            parent: _node,
                            index: i
                          });
                          
                  swarmTree.push(node);
                  inSwarmTree[node.node] = true;
                  iterateThroughSwarm(node.node, timeStamp);
              }
          }
        }
      }
    }

    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {
      
      uint256 share;
      if(JohanInSwarm) share = _taxCollected;
      else share = 0;
    
      for(uint i = 0; i < swarmTree.length; i++) {
        
        address node = swarmTree[i].node;
        address parent = swarmTree[i].parent;
        uint index = swarmTree[i].index;
        
        bool isJohan;
        if(node == JohanNygren) isJohan = true;

        if(isJohan) {
          balanceOf[swarmTree[i].node] += share;
        totalBasicIncome[node] += share;
        }
          
        if(dividendPathways[parent][index].amount - _taxCollected > 0) {
          dividendPathways[parent][index].amount -= _taxCollected; 
        }
        else removeDividendPathway(parent, index);
        
        inSwarmTree[node] = false;
        
        /* Notifiy anyone listening that this swarm took place */
        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);
      }
      delete swarmTree;
      bool JohanWasInSwarm = JohanInSwarm;
      delete JohanInSwarm;

      if(!JohanWasInSwarm) return false;
      return true;
    }
    
    function removeDividendPathway(address node, uint index) internal {
                delete dividendPathways[node][index];
                for (uint i = index; i < dividendPathways[node].length - 1; i++) {
                        dividendPathways[node][i] = dividendPathways[node][i + 1];
                }
                dividendPathways[node].length--;
        }

}",False,False,False
0x9473bc8bb575ffc15cb2179cd9398bdf5730bf55,307: time manipulation;,True,False,False,"pragma solidity ^0.4.7;
contract TheEthereumLottery {
 /*
    Brief introduction:
    
    To play you need to pick 4 numbers (range 0-255) and provide them sorted to Play() function.
    To win you need to hit at least 1 number out of 4 WinningNums which will be announced once every week
    (or more often if the lottery will become more popular). If you hit all of the 4 numbers you will win
    about 10 million times more than you payed for lottery ticket. The exact values are provided as GuessXOutOf4
    entries in Ledger - notice that they are provided in Wei, not Ether (10^18 Wei = Ether).
    Use Withdraw() function to pay out.


    The advantage of TheEthereumLottery is that it uses secret random value which only owner knows (called TheRand).
    A hash of TheRand (called OpeningHash) is announced at the beginning of every draw (lets say draw number N) - 
    at this moment ticket price and the values of GuessXOutOf4 are publicly available and can not be changed.
    When draw N+1 is announced in a block X, a hash of block X-1 is assigned to ClosingHash field of draw N.
    After few minutes, owner announces TheRand which satisfy following expression: sha3(TheRand)==drawN.OpeningHash
    then Rand32B=sha3(TheRand, ClosingHash) is calculated an treated as a source for WinningNumbers, 
    also ClosingHash is changed to Rand32B as it might be more interesting for someone watching lottery ledger
    to see that number instead of hash of some block. 

    This approach (1) unable players to cheat, as as long as no one knows TheRand, 
    no one can predict what WinningNums will be, (2) unable owner to influence the WinningNums (in order to
    reduce average amount won) because OpeningHash=sha3(TheRand) was public before bets were made, and (3) reduces 
    owner capability of playing it's own lottery and making winning bets to very short window of one
    exactly the same block as new draw was announced - so anyone, with big probability, can think that if winning
    bet was made in this particular block - probably it was the owner, especially if no more bets were made 
    at this block (which is very likely).

    Withdraw is possible only after TheRand was announced, if the owner will not announce TheRand in 2 weeks,
    players can use Refund function in order to refund their ETH used to make bet. 
    That moment is called ExpirationTime on contract Ledger (which is visible from JSON interface).
 */
/*
  Name:
  TheEthereumLottery

  JSON interface:

[{""constant"":true,""inputs"":[],""name"":""Announcements"",""outputs"":[{""name"":"""",""type"":""string""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""IndexOfCurrentDraw"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""ledger"",""outputs"":[{""name"":""WinningNum1"",""type"":""uint8""},{""name"":""WinningNum2"",""type"":""uint8""},{""name"":""WinningNum3"",""type"":""uint8""},{""name"":""WinningNum4"",""type"":""uint8""},{""name"":""ClosingHash"",""type"":""bytes32""},{""name"":""OpeningHash"",""type"":""bytes32""},{""name"":""Guess4OutOf4"",""type"":""uint256""},{""name"":""Guess3OutOf4"",""type"":""uint256""},{""name"":""Guess2OutOf4"",""type"":""uint256""},{""name"":""Guess1OutOf4"",""type"":""uint256""},{""name"":""PriceOfTicket"",""type"":""uint256""},{""name"":""ExpirationTime"",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""TheRand"",""type"":""bytes32""}],""name"":""CheckHash"",""outputs"":[{""name"":""OpeningHash"",""type"":""bytes32""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""DrawIndex"",""type"":""uint8""},{""name"":""PlayerAddress"",""type"":""address""}],""name"":""MyBet"",""outputs"":[{""name"":""Nums"",""type"":""uint8[4]""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""referral_fee"",""outputs"":[{""name"":"""",""type"":""uint8""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""}],""name"":""referral_ledger"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""MyNum1"",""type"":""uint8""},{""name"":""MyNum2"",""type"":""uint8""},{""name"":""MyNum3"",""type"":""uint8""},{""name"":""MyNum4"",""type"":""uint8""}],""name"":""Play"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""DrawIndex"",""type"":""uint32""}],""name"":""Withdraw"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""DrawIndex"",""type"":""uint32""}],""name"":""Refund"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""MyNum1"",""type"":""uint8""},{""name"":""MyNum2"",""type"":""uint8""},{""name"":""MyNum3"",""type"":""uint8""},{""name"":""MyNum4"",""type"":""uint8""},{""name"":""ref"",""type"":""address""}],""name"":""PlayReferred"",""outputs"":[],""payable"":true,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""Withdraw_referral"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""Deposit_referral"",""outputs"":[],""payable"":true,""type"":""function""},{""anonymous"":false,""inputs"":[{""indexed"":true,""name"":""IndexOfDraw"",""type"":""uint256""},{""indexed"":false,""name"":""OpeningHash"",""type"":""bytes32""},{""indexed"":false,""name"":""PriceOfTicketInWei"",""type"":""uint256""},{""indexed"":false,""name"":""WeiToWin"",""type"":""uint256""}],""name"":""NewDrawReadyToPlay"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""name"":""IndexOfDraw"",""type"":""uint32""},{""indexed"":false,""name"":""WinningNumber1"",""type"":""uint8""},{""indexed"":false,""name"":""WinningNumber2"",""type"":""uint8""},{""indexed"":false,""name"":""WinningNumber3"",""type"":""uint8""},{""indexed"":false,""name"":""WinningNumber4"",""type"":""uint8""},{""indexed"":false,""name"":""TheRand"",""type"":""bytes32""}],""name"":""DrawReadyToPayout"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""Wei"",""type"":""uint256""}],""name"":""PlayerWon"",""type"":""event""}]

*/
//constructor
function TheEthereumLottery()
{
  owner=msg.sender;
  ledger.length=0;
  IndexOfCurrentDraw=0;
  referral_fee=90;
}
modifier OnlyOwner()
{ // Modifier
  if (msg.sender != owner) throw;
  _;
}
address owner;
string public Announcements;//just additional feature
uint public IndexOfCurrentDraw;//starting from 0
uint8 public referral_fee;
mapping(address=>uint256) public referral_ledger;
struct bet_t {
  address referral;
  uint8[4] Nums;
  bool can_withdraw;//default==false
}
struct ledger_t {
  uint8 WinningNum1;
  uint8 WinningNum2;
  uint8 WinningNum3;
  uint8 WinningNum4;
  bytes32 ClosingHash;
  bytes32 OpeningHash;
  mapping(address=>bet_t) bets;
  uint Guess4OutOf4;
  uint Guess3OutOf4;
  uint Guess2OutOf4;
  uint Guess1OutOf4;
  uint PriceOfTicket;
  uint ExpirationTime;//for eventual refunds only, ~2 weeks after draw announced
}
ledger_t[] public ledger;
 
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@ Here begins what probably you want to analyze @@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function next_draw(bytes32 new_hash,
	  uint priceofticket,
	  uint guess4outof4,
	  uint guess3outof4,
	  uint guess2outof4,
	  uint guess1outof4
	  )
OnlyOwner
{
  ledger.length++;
  ledger[IndexOfCurrentDraw].ClosingHash =
    //sha3(block.blockhash(block.number-1));               //this, or
    //sha3(block.blockhash(block.number-1),block.coinbase);//this adds complexity, but safety remains the same
    block.blockhash(block.number-1);//adds noise to the previous draw
  //if you are just checking how it works, just pass the comment below, and come back when you finish analyzing
  //the contract - it explains how the owner could win this lottery 
  //if the owner was about to cheat, he has to make a bet, and then use this f-n. both in a single block.
  //its because if you know TheRand and blockhash of a last block before new draw then you can determine the numbers
  //achieving it would be actually simple, another contract is needed which would get signed owner tx of this f-n call
  //and just calculate what the numbers would be (the previous block hash is available), play with that nums,
  //and then run this f-n. It is guaranteed that both actions are made in a single block, as it is a single call
  //so if someone have made winning bet in exactly the same block as announcement of next draw,
  //then you can be suspicious that it was the owner
  //also assuming this scenario, TheRand needs to be present on that contract - so if transaction is not mined
  //immediately - it makes a window for anyone to do the same and win.
  IndexOfCurrentDraw=ledger.length-1;
  ledger[IndexOfCurrentDraw].OpeningHash = new_hash;
  ledger[IndexOfCurrentDraw].Guess4OutOf4=guess4outof4;
  ledger[IndexOfCurrentDraw].Guess3OutOf4=guess3outof4;
  ledger[IndexOfCurrentDraw].Guess2OutOf4=guess2outof4;
  ledger[IndexOfCurrentDraw].Guess1OutOf4=guess1outof4;
  ledger[IndexOfCurrentDraw].PriceOfTicket=priceofticket;
  ledger[IndexOfCurrentDraw].ExpirationTime=now + 2 weeks;//You can refund after ExpirationTime if owner will not announce TheRand satisfying TheHash
  NewDrawReadyToPlay(IndexOfCurrentDraw, new_hash, priceofticket, guess4outof4);//event
}
function announce_therand(uint32 index,
			  bytes32 the_rand
			  )
OnlyOwner
{
  if(sha3(the_rand)
     !=
     ledger[index].OpeningHash)
    throw;//this implies that if Numbers are present, broadcasted TheRand has to satisfy TheHash


  bytes32 combined_rand=sha3(the_rand, ledger[index].ClosingHash);//from this number we'll calculate WinningNums
  //usually the last 4 Bytes will be the WinningNumbers, but it is not always true, as some Byte could
  //be the same, then we need to take one more Byte from combined_rand and so on

  ledger[index].ClosingHash = combined_rand;//changes the closing blockhash to seed for WinningNums
    //this line is useless from the perspective of lottery
    //but maybe some of the players will find it interesting that something
    //which is connected to the WinningNums is present in a ledger


  //the algorithm of assigning an int from some range to single bet takes too much code
  uint8[4] memory Numbers;//relying on that combined_rand should be random - lets pick Nums into this array 

  uint8 i=0;//i = how many numbers are picked
  while(i<4)
    {
      Numbers[i]=uint8(combined_rand);//same as '=combined_rand%256;'
      combined_rand>>=8;//same as combined_rand/=256;
      for(uint j=0;j<i;++j)//is newly picked val in a set?
	if(Numbers[j]==Numbers[i]) {--i;break;}//yes, break back to while loop and look for another Num[i]
      ++i;
    }
  //probability that in 32 random bytes there was only 3 or less different ones ~=2.65e-55
  //it's like winning this lottery 2.16*10^46 times in a row
  //p.s. there are 174792640 possible combinations of picking 4 numbers out of 256

  //now we have to sort the values
  for(uint8 n=4;n>1;n--)//bubble sort
    {
      bool sorted=true; 
      for(uint8 k=0;k<n-1;++k)
	if(Numbers[k] > Numbers[k+1])//then mark array as not sorted & swap
	  {
	    sorted=false;
	    (Numbers[k], Numbers[k+1])=(Numbers[k+1], Numbers[k]);
	  }
      if(sorted) break;//breaks as soon as the array is sorted
    }

  
  ledger[index].WinningNum1 = Numbers[0];
  ledger[index].WinningNum2 = Numbers[1];
  ledger[index].WinningNum3 = Numbers[2];
  ledger[index].WinningNum4 = Numbers[3];
  
  DrawReadyToPayout(index,
		    Numbers[0],Numbers[1],Numbers[2],Numbers[3],
		    the_rand);//event
}

function PlayReferred(uint8 MyNum1,
		      uint8 MyNum2,
		      uint8 MyNum3,
		      uint8 MyNum4,
		      address ref
		      )
payable
{
  if(msg.value != ledger[IndexOfCurrentDraw].PriceOfTicket ||//to play you need to pay 
     ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[3] != 0)//if your bet already exist
    throw;

  //if numbers are not sorted
  if(MyNum1 >= MyNum2 ||
     MyNum2 >= MyNum3 ||
     MyNum3 >= MyNum4
     )
    throw;//because you should sort the values yourself
  if(ref!=0)//when there is no refferal, function is cheaper for ~20k gas
    ledger[IndexOfCurrentDraw].bets[msg.sender].referral=ref;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[0]=MyNum1;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[1]=MyNum2;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[2]=MyNum3;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[3]=MyNum4;
  ledger[IndexOfCurrentDraw].bets[msg.sender].can_withdraw=true;
}
// Play wrapper:
function Play(uint8 MyNum1,
	      uint8 MyNum2,
	      uint8 MyNum3,
	      uint8 MyNum4
	      )
{
  PlayReferred(MyNum1,
	       MyNum2,
	       MyNum3,
	       MyNum4,
	       0//no referral
	       );
}
function Deposit_referral()//this function is not mandatory to become referral
  payable//might be used to not withdraw all the funds at once or to invest
{//probably needed only at the beginnings
  referral_ledger[msg.sender]+=msg.value;
}
function Withdraw_referral()
{
  uint val=referral_ledger[msg.sender];
  referral_ledger[msg.sender]=0;
  if(!msg.sender.send(val)) //payment
    throw;
}
function set_referral_fee(uint8 new_fee)
OnlyOwner
{
  if(new_fee<50 || new_fee>100)
    throw;//referrals have at least 50% of the income
  referral_fee=new_fee;
}
function Withdraw(uint32 DrawIndex)
{
  //if(msg.value!=0) //compiler deals with that, as there is no payable modifier in this f-n
  //  throw;//this function is free

  if(ledger[DrawIndex].bets[msg.sender].can_withdraw==false)
    throw;//throw if player didnt played

  //by default, every non existing value is equal to 0
  //so if there was no announcement WinningNums are zeros
  if(ledger[DrawIndex].WinningNum4 == 0)//the least possible value == 3
    throw;//this condition checks if the numbers were announced
  //see announce_therand f-n to see why this check is enough
  
  uint8 hits=0;
  uint8 i=0;
  uint8 j=0;
  uint8[4] memory playernum=ledger[DrawIndex].bets[msg.sender].Nums;
  uint8[4] memory nums;
  (nums[0],nums[1],nums[2],nums[3])=
    (ledger[DrawIndex].WinningNum1,
     ledger[DrawIndex].WinningNum2,
     ledger[DrawIndex].WinningNum3,
     ledger[DrawIndex].WinningNum4);
  //data ready
  
  while(i<4)//count player hits
    {//both arrays are sorted
      while(j<4 && playernum[j] < nums[i]) ++j;
      if(j==4) break;//nothing more to check - break loop here
      if(playernum[j] == nums[i]) ++hits;
      ++i;
    }
  if(hits==0) throw;
  uint256 win=0;
  if(hits==1) win=ledger[DrawIndex].Guess1OutOf4;
  if(hits==2) win=ledger[DrawIndex].Guess2OutOf4;
  if(hits==3) win=ledger[DrawIndex].Guess3OutOf4;
  if(hits==4) win=ledger[DrawIndex].Guess4OutOf4;
    
  ledger[DrawIndex].bets[msg.sender].can_withdraw=false;
  if(!msg.sender.send(win)) //payment
    throw;

  if(ledger[DrawIndex].bets[msg.sender].referral==0)//it was not referred bet
    referral_ledger[owner]+=win/100;
  else
    {
      referral_ledger[ledger[DrawIndex].bets[msg.sender].referral]+=
	win/10000*referral_fee;//(win/100)*(referral_fee/100);
      referral_ledger[owner]+=
	win/10000*(100-referral_fee);//(win/100)*((100-referral_fee)/100);
    }

  
  PlayerWon(win);//event
}
function Refund(uint32 DrawIndex)
{
  //if(msg.value!=0) //compiler deals with that, as there is no payable modifier in this f-n
  //  throw;//this function is free

  if(ledger[DrawIndex].WinningNum4 != 0)//if TheRand was announced, WinningNum4 >= 3
    throw; //no refund if there was a valid announce

  if(now < ledger[DrawIndex].ExpirationTime)
    throw;//no refund while there is still TIME to announce TheRand
  
 
  if(ledger[DrawIndex].bets[msg.sender].can_withdraw==false)
    throw;//throw if player didnt played or already refunded
  
  ledger[DrawIndex].bets[msg.sender].can_withdraw=false;
  if(!msg.sender.send(ledger[DrawIndex].PriceOfTicket)) //refund
    throw;
}
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@ Here ends what probably you wanted to analyze @@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

function CheckHash(bytes32 TheRand)
  constant returns(bytes32 OpeningHash)
{
  return sha3(TheRand);
}
function MyBet(uint8 DrawIndex, address PlayerAddress)
  constant returns (uint8[4] Nums)
{//check your nums
  return ledger[DrawIndex].bets[PlayerAddress].Nums;
}
function announce(string MSG)
  OnlyOwner
{
  Announcements=MSG;
}
event NewDrawReadyToPlay(uint indexed IndexOfDraw,
			 bytes32 OpeningHash,
			 uint PriceOfTicketInWei,
			 uint WeiToWin);
event DrawReadyToPayout(uint32 indexed IndexOfDraw,
			uint8 WinningNumber1,
			uint8 WinningNumber2,
			uint8 WinningNumber3,
			uint8 WinningNumber4,
			bytes32 TheRand);
event PlayerWon(uint Wei);

}//contract",False,False,True
0x95c2906debbb9203ff7007f26c2f00a936c77b5d,92: arithmetic; 98: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

contract RES { 

    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint public totalSupply;
    
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    
    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    

    /* Bought or sold */

    event Bought(address from, uint amount);
    event Sold(address from, uint amount);
    event BoughtViaJohan(address from, uint amount);

    /* Initializes contract with name, symbol and decimals */

    function RES() {
        name = ""RES"";     
        symbol = ""RES"";
        decimals = 18;
    }

}

contract SwarmRedistribution is RES {
    
    address public JohanNygren;
    bool public campaignOpen;    

    struct dividendPathway {
      address from;
      uint amount;
      uint timeStamp;
    }

    mapping(address => dividendPathway[]) public dividendPathways;
    
    mapping(address => uint256) public totalBasicIncome;

    uint taxRate;

    struct Node {
      address node;
      address parent;
      uint index;
    }
    
    /* Generate a swarm tree */
    Node[] swarmTree;
    
    mapping(address => bool) inSwarmTree;
    
    bool JohanInSwarm;

    event Swarm(address indexed leaf, address indexed node, uint256 share);

    function SwarmRedistribution() {
      
    /* Tax-rate in parts per thousand */
    taxRate = 20;
    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;
    campaignOpen = true;
    
    }
    
    modifier onlyJohan {
      if(msg.sender != JohanNygren) throw;
      _;
    }

    modifier isOpen {
      if(campaignOpen != true) throw;
      _;
    }
    
    function closeCampaign() onlyJohan {
        campaignOpen = false;
    }

    function buy() isOpen public payable {
      balanceOf[msg.sender] += msg.value;
      totalSupply += msg.value;
      Bought(msg.sender, msg.value);
    }  

    function buyViaJohan() isOpen public payable {
      balanceOf[msg.sender] += msg.value;
      totalSupply += msg.value;  

      /* Create the dividend pathway */
      dividendPathways[msg.sender].push(dividendPathway({
                                      from: JohanNygren, 
                                      amount:  msg.value,
                                      timeStamp: now
                                    }));

      BoughtViaJohan(msg.sender, msg.value);
    }

    function sell(uint256 _value) public {
      if(balanceOf[msg.sender] < _value) throw;
      balanceOf[msg.sender] -= _value;
    
      if (!msg.sender.send(_value)) throw;

      totalSupply -= _value;
      Sold(msg.sender, _value);

    }

    /* Send coins */
    function transfer(address _to, uint256 _value) isOpen {
        /* reject transaction to self to prevent dividend pathway loops*/
        if(_to == msg.sender) throw;
        
        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        
        /* Calculate tax */
        uint256 taxCollected = _value * taxRate / 1000;
        uint256 sentAmount;

        /* Create the dividend pathway */
        dividendPathways[_to].push(dividendPathway({
                                        from: msg.sender, 
                                        amount:  _value,
                                        timeStamp: now
                                      }));
        
        if(swarmRedistribution(_to, taxCollected) == true) {
          sentAmount = _value;
        }
        else {
          /* Return tax */
          sentAmount = _value - taxCollected;
        }
        
          /* Add and subtract new balances */

          balanceOf[msg.sender] -= sentAmount;
          balanceOf[_to] += _value - taxCollected;
        

        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, sentAmount);
    }

    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {
           iterateThroughSwarm(_to, now);
           if(swarmTree.length != 0) {
           return doSwarm(_to, _taxCollected);
           }
           else return false;
      }

    function iterateThroughSwarm(address _node, uint _timeStamp) internal {
      if(dividendPathways[_node].length != 0) {
        for(uint i = 0; i < dividendPathways[_node].length; i++) {
          if(inSwarmTree[dividendPathways[_node][i].from] == false) { 
            
            uint timeStamp = dividendPathways[_node][i].timeStamp;
            if(timeStamp <= _timeStamp) {
                
              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;
    
                Node memory node = Node({
                            node: dividendPathways[_node][i].from, 
                            parent: _node,
                            index: i
                          });
                          
                  swarmTree.push(node);
                  inSwarmTree[node.node] = true;
                  iterateThroughSwarm(node.node, timeStamp);
              }
          }
        }
      }
    }

    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {
      
      uint256 share;
      if(JohanInSwarm) share = _taxCollected;
      else share = 0;
    
      for(uint i = 0; i < swarmTree.length; i++) {
        
        address node = swarmTree[i].node;
        address parent = swarmTree[i].parent;
        uint index = swarmTree[i].index;
        
        bool isJohan;
        if(node == JohanNygren) isJohan = true;

        if(isJohan) {
          balanceOf[swarmTree[i].node] += share;
        totalBasicIncome[node] += share;
        }
          
        if(dividendPathways[parent][index].amount - _taxCollected > 0) {
          dividendPathways[parent][index].amount -= _taxCollected; 
        }
        else removeDividendPathway(parent, index);
        
        inSwarmTree[node] = false;
        
        /* Notifiy anyone listening that this swarm took place */
        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);
      }
      delete swarmTree;
      bool JohanWasInSwarm = JohanInSwarm;
      delete JohanInSwarm;

      if(!JohanWasInSwarm) return false;
      return true;
    }
    
    function removeDividendPathway(address node, uint index) internal {
                delete dividendPathways[node][index];
                for (uint i = index; i < dividendPathways[node].length - 1; i++) {
                        dividendPathways[node][i] = dividendPathways[node][i + 1];
                }
                dividendPathways[node].length--;
        }

}",False,False,False
0xd2f7bba33a3b81792c0f9cc2de6d9266002a5591,FP,True,True,False,"pragma solidity ^ 0.4 .6;

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract CampaignBeneficiary is owned{

        address public Resilience;

        function CampaignBeneficiary() {
            Resilience = 0xDA922E473796bc372d4a2cb95395ED17aF8b309B;

            bytes4 setBeneficiarySig = bytes4(sha3(""setBeneficiary()""));
            if (!Resilience.call(setBeneficiarySig)) throw;
        }
        
        function() payable {
            if(msg.sender != Resilience) throw;
        }
        
        function simulatePathwayFromBeneficiary() public payable {

                bytes4 buySig = bytes4(sha3(""buy()""));
                if (!Resilience.call.value(msg.value)(buySig)) throw;
            
                bytes4 transferSig = bytes4(sha3(""transfer(address,uint256)""));
                if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
        }

        function sell(uint256 _value) onlyOwner {
                bytes4 sellSig = bytes4(sha3(""sell(uint256)""));
                if (!Resilience.call(sellSig, _value)) throw;
        }
        
        function withdraw(uint256 _value) onlyOwner {
                if (!msg.sender.send(_value)) throw;
        }
        
        function closeCampaign() onlyOwner {
            bytes4 closeCampaignSig = bytes4(sha3(""closeCampaign()""));
            if (!Resilience.call(closeCampaignSig)) throw;
        }
}",False,False,False
0xf77ac34cd0ed42f2b5d8cfcf4fa0f4bb1b80b9d8,96: arithmetic; 102: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

contract RES { 

    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint public totalSupply;
    
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    
    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    

    /* Bought or sold */

    event Bought(address from, uint amount);
    event Sold(address from, uint amount);
    event BoughtViaJohan(address from, uint amount);

    /* Initializes contract with name, symbol and decimals */

    function RES() {
        name = ""RES"";     
        symbol = ""RES"";
        decimals = 18;
    }

}

contract SwarmRedistribution is RES {
    
    address public JohanNygren;
    bool public campaignOpen;    

    struct dividendPathway {
      address from;
      uint amount;
      uint timeStamp;
    }

    mapping(address => dividendPathway[]) public dividendPathways;
    
    mapping(address => uint256) public totalBasicIncome;

    uint taxRate;

    struct Node {
      address node;
      address parent;
      uint index;
    }
    
    /* Generate a swarm tree */
    Node[] swarmTree;
    
    mapping(address => bool) inSwarmTree;
    
    bool JohanInSwarm;

    event Swarm(address indexed leaf, address indexed node, uint256 share);

    function SwarmRedistribution() {
      
    /* Tax-rate in parts per thousand */
    taxRate = 20;
    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;
    campaignOpen = true;
    
    }
    
    modifier onlyJohan {
      if(msg.sender != JohanNygren) throw;
      _;
    }

    modifier isOpen {
      if(campaignOpen != true) throw;
      _;
    }
    
    function changeJohanNygrensAddress(address _newAddress) onlyJohan {
      JohanNygren = _newAddress;
    }
    
    function closeCampaign() onlyJohan {
        campaignOpen = false;
    }

    function buy() isOpen public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;
      Bought(msg.sender, msg.value);
    }  

    function buyViaJohan() isOpen public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;  

      /* Create the dividend pathway */
      dividendPathways[msg.sender].push(dividendPathway({
                                      from: JohanNygren, 
                                      amount:  msg.value,
                                      timeStamp: now
                                    }));

      BoughtViaJohan(msg.sender, msg.value);
    }

    function sell(uint256 _value) public {
      if(balanceOf[msg.sender] < _value) throw;
      balanceOf[msg.sender] -= _value;
    
      if (!msg.sender.send(_value)) throw;

      totalSupply -= _value;
      Sold(msg.sender, _value);

    }

    /* Send coins */
    function transfer(address _to, uint256 _value) isOpen {
        /* reject transaction to self to prevent dividend pathway loops*/
        if(_to == msg.sender) throw;
        
        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        
        /* Calculate tax */
        uint256 taxCollected = _value * taxRate / 1000;
        uint256 sentAmount;

        /* Create the dividend pathway */
        dividendPathways[_to].push(dividendPathway({
                                        from: msg.sender, 
                                        amount:  _value,
                                        timeStamp: now
                                      }));
        
        if(swarmRedistribution(_to, taxCollected) == true) {
          sentAmount = _value;
        }
        else {
          /* Return tax */
          sentAmount = _value - taxCollected;
        }
        
          /* Add and subtract new balances */

          balanceOf[msg.sender] -= sentAmount;
          balanceOf[_to] += _value - taxCollected;
        

        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, sentAmount);
    }

    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {
           iterateThroughSwarm(_to, now);
           if(swarmTree.length != 0) {
           return doSwarm(_to, _taxCollected);
           }
           else return false;
      }

    function iterateThroughSwarm(address _node, uint _timeStamp) internal {
      if(dividendPathways[_node].length != 0) {
        for(uint i = 0; i < dividendPathways[_node].length; i++) {
          if(inSwarmTree[dividendPathways[_node][i].from] == false) { 
            
            uint timeStamp = dividendPathways[_node][i].timeStamp;
            if(timeStamp <= _timeStamp) {
                
              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;
    
                Node memory node = Node({
                            node: dividendPathways[_node][i].from, 
                            parent: _node,
                            index: i
                          });
                          
                  swarmTree.push(node);
                  inSwarmTree[node.node] = true;
                  iterateThroughSwarm(node.node, timeStamp);
              }
          }
        }
      }
    }

    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {
      
      uint256 share;
      if(JohanInSwarm) share = _taxCollected;
      else share = 0;
    
      for(uint i = 0; i < swarmTree.length; i++) {
        
        address node = swarmTree[i].node;
        address parent = swarmTree[i].parent;
        uint index = swarmTree[i].index;
        
        bool isJohan;
        if(node == JohanNygren) isJohan = true;

        if(isJohan) {
          balanceOf[swarmTree[i].node] += share;
        totalBasicIncome[node] += share;
        }
          
        if(dividendPathways[parent][index].amount - _taxCollected > 0) {
          dividendPathways[parent][index].amount -= _taxCollected; 
        }
        else removeDividendPathway(parent, index);
        
        inSwarmTree[node] = false;
        
        /* Notifiy anyone listening that this swarm took place */
        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);
      }
      delete swarmTree;
      bool JohanWasInSwarm = JohanInSwarm;
      delete JohanInSwarm;

      if(!JohanWasInSwarm) return false;
      return true;
    }
    
    function removeDividendPathway(address node, uint index) internal {
                delete dividendPathways[node][index];
                for (uint i = index; i < dividendPathways[node].length - 1; i++) {
                        dividendPathways[node][i] = dividendPathways[node][i + 1];
                }
                dividendPathways[node].length--;
        }

}",False,False,False
0x385e817b0083724672cb998a7afcf6da05bc0c7f,35: unchecked; 32: unchecked;,True,False,False,"pragma solidity ^0.4.6;
contract FileStorage {	
	address owner;
	mapping (bytes32=>File[]) public files;
	
	struct File {
		string title;		
		string category;	
		string extension;	
		string created;		
		string updated;	
		uint version;	
		bytes data;			
	}

    function FileStorage() {
        owner = msg.sender;
    }
    
    function Kill() {
        if (msg.sender == owner)
        selfdestruct(owner);
    }

	function StoreFile(bytes32 key, string title, string category, string extension, string created, string updated, uint version, bytes data)
	payable returns (bool success) {
	    var before = files[key].length;	
		var file = File(title, category, extension, created, updated, version, data);	
		files[key].push(file);	
			
		if (files[key].length > before) {	
			owner.send(this.balance);
			return true;
		} else {
			msg.sender.send(this.balance);
			return false;
		}

	}
	
	
	function GetFileLocation(bytes32 key) constant returns (uint Loc) {
		return files[key].length -1;	
	}
	
	function() {
	    throw;
	}
}",False,False,False
0x4f529990b7f3d1fb4152736155e431c96fd86294,71: arithmetic;,True,False,False,"// Mysterium Network Presale Smart Contract

pragma solidity ^0.4.6;

contract Presale {
    mapping (address => uint) public balances;
    uint public transfered_total = 0;
    
    uint public constant min_goal_amount = 2000 ether;
    uint public constant max_goal_amount = 6000 ether;
    
    // Mysterium project wallet
    address public project_wallet;

    uint public presale_start_block;
    uint public presale_end_block;
    
    // approximate blocks count in 2 months 
    uint constant blocks_in_two_months = 351558;
    
    // block number of the end of refund window, 
    // which will occur in the end of 2 months after presale
    uint public refund_window_end_block;
    
    function Presale(/*uint _start_block, uint _end_block, address _project_wallet*/) {
        
        uint _start_block = 2818600;
        uint _end_block = 3191000;
        address _project_wallet = 0x002515a2fd5C9DDa1d4109aE8BBF9f73A707B72f;
        
        if (_start_block <= block.number) throw;
        if (_end_block <= _start_block) throw;
        if (_project_wallet == 0) throw;
        
        presale_start_block = _start_block;
        presale_end_block = _end_block;
        project_wallet = _project_wallet;
		refund_window_end_block = presale_end_block + blocks_in_two_months;
	}
	
	function has_presale_started() private constant returns (bool) {
	    return block.number >= presale_start_block;
	}
    
    function has_presale_time_ended() private constant returns (bool) {
        return block.number > presale_end_block;
    }
    
    function is_min_goal_reached() private constant returns (bool) {
        return transfered_total >= min_goal_amount;
    }
    
    function is_max_goal_reached() private constant returns (bool) {
        return transfered_total >= max_goal_amount;
    }
    
    // Accept ETH while presale is active or until maximum goal is reached.
	function () payable {
	    // check if presale has started
        if (!has_presale_started()) throw;
	    
	    // check if presale date is not over
	    if (has_presale_time_ended()) throw;
	    
	    // don`t accept transactions with zero value
	    if (msg.value == 0) throw;

        // check if max goal is not reached
	    if (is_max_goal_reached()) throw;
        
        if (transfered_total + msg.value > max_goal_amount) {
            // return change
	        var change_to_return = transfered_total + msg.value - max_goal_amount;
	        if (!msg.sender.send(change_to_return)) throw;
            
            var to_add = max_goal_amount - transfered_total;
            balances[msg.sender] += to_add;
	        transfered_total += to_add;
        } else {
            // set data
	        balances[msg.sender] += msg.value;
	        transfered_total += msg.value;
        }
    }
    
    // Transfer ETH to Mysterium project wallet, as soon as minimum goal is reached.
    function transfer_funds_to_project() {
        if (!is_min_goal_reached()) throw;
        if (this.balance == 0) throw;
        
        // transfer ethers to Mysterium project wallet
        if (!project_wallet.send(this.balance)) throw;
    }
    
    // Refund ETH in case minimum goal was not reached during presale.
    // Refund will be available for two months window after presale.
    function refund() {
        if (!has_presale_time_ended()) throw;
        if (is_min_goal_reached()) throw;
        if (block.number > refund_window_end_block) throw;
        
        var amount = balances[msg.sender];
        // check if sender has balance
        if (amount == 0) throw;
        
        // reset balance
        balances[msg.sender] = 0;
        
        // actual refund
        if (!msg.sender.send(amount)) throw;
    }
    
    // In case any ETH has left unclaimed after two months window, send them to Mysterium project wallet.
    function transfer_left_funds_to_project() {
        if (!has_presale_time_ended()) throw;
        if (is_min_goal_reached()) throw;
        if (block.number <= refund_window_end_block) throw;
        
        if (this.balance == 0) throw;
        // transfer left ETH to Mysterium project wallet
        if (!project_wallet.send(this.balance)) throw;
    }
}",False,False,True
0x72a68Fb6d91Ed8Dc47B564e088E518C6D4a6FF44,190: arithmetic; 80: time manipulation;,True,False,False,"pragma solidity 0.4.6;

contract DXF_Tokens{

  //States
  bool public dxfOpen=true;
  bool public refundState;
  bool public transferLocked=true;

  uint256 public startingDateFunding;
  uint256 public closingDateFunding;
  //Maximum number of participants
  uint256 public constant maxNumberMembers=5000;
  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)
  uint256 public totalTokens;
  uint256 public constant tokensCreationMin = 25000 ether;
  uint256 public constant tokensCreationCap = 75000 ether;
  //Cap of 12500 ethers worth of tokens to be distributed 
  //to previous DO members in exchange for their rouleth accounts
  uint256 public remainingTokensVIPs=12500 ether;
  uint256 public constant tokensCreationVIPsCap = 12500 ether; 


  mapping (address => uint256) balances;
  mapping (address => bool) vips;
  mapping (address => uint256) indexMembers;
  
  struct Member
  {
    address member;
    uint timestamp;
    uint initial_value;
  }
  Member[] public members;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Refund(address indexed _to, uint256 _value);
  event failingRefund(address indexed _to, uint256 _value);
  event VipMigration(address indexed _vip, uint256 _value);
  event newMember(address indexed _from);

  // Token parameters
  string public constant name = ""DXF - Decentralized eXperience Friends"";
  string public constant symbol = ""DXF"";
  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.

  address public admin;
  address public multisigDXF;

  modifier onlyAdmin()
  {
    if (msg.sender!=admin) throw;
    _;
  }

  function DXF_Tokens()
  {
    admin = msg.sender;
    startingDateFunding=now;
    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param
    //increment array by 1 for indexes
    members.push(Member(0,0,0));
  }


  //empty fallback
  function ()
    {
      throw;
    }

  //USER FUNCTIONS  
  /// @notice Create tokens when funding is active.
  /// @notice By using this function you accept the terms of DXF
  /// @dev Required state: Funding Active
  /// @dev State transition: -> Funding Success (only if cap reached)
  function acceptTermsAndJoinDXF() payable external 
  {
    // refuse if more than 12 months have passed
    if (now>startingDateFunding+365 days) throw;
    // Abort if DXF is not open.
    if (!dxfOpen) throw;
    // verify if the account is not a VIP account
    if (vips[msg.sender]) throw;
    // Do not allow creating less than 10 ether or more than the cap tokens.
    if (msg.value < 10 ether) throw;
    if (msg.value > (tokensCreationCap - totalTokens)) throw;
    // Enforce cap of 10 000 ethers per address / individual
    if (msg.value > (10000 ether - balances[msg.sender])) throw;
    // Register member
    if (balances[msg.sender]==0)
      {
        newMember(msg.sender); //event
	indexMembers[msg.sender]=members.length;
	members.push(Member(msg.sender,now,msg.value));
      }
    else
      {
	members[indexMembers[msg.sender]].initial_value+=msg.value;
      }
    if (members.length>maxNumberMembers) throw;
    //Send the funds to the MultiSig Wallet
    if (multisigDXF==0) throw;
    if (!multisigDXF.send(msg.value)) throw;
    // Assign new tokens to the sender
    uint numTokens = msg.value;
    totalTokens += numTokens;
    // Do not allow creating tokens if we don't leave enough for the VIPs
    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;
    balances[msg.sender] += numTokens;
    // Log token creation event
    Transfer(0, msg.sender, numTokens);
  }



  //NOT INCLUDED IN LATEST VERSION
  //since we move the funds to multisig
  //refund will be with payback()
  /* /// @notice Get back the ether sent during the funding in case the funding */
  /* /// has not reached the minimum level. */
  /* /// @dev Required state: refund true */
  /* function refund() */
  /* { */
  /*   // Abort if not in refund state */
  /*   if (!refundState) throw; */
  /*   // Not refunded for VIP, we will do a manual refund for them */
  /*   // via the payback function */
  /*   if (vips[msg.sender]) throw; */
  /*   uint value = balances[msg.sender]; */
  /*   if (value == 0) throw; */
  /*   balances[msg.sender] = 0; */
  /*   totalTokens -= value; */
  /*   delete members[indexMembers[msg.sender]]; */
  /*   indexMembers[msg.sender]=0; */
  /*   Refund(msg.sender, value); */
  /*   if (!msg.sender.send(value)) throw; */
  /* } */


  //@notice Full Tranfer of DX tokens from sender to '_to'
  //@dev only active if tranfer has been unlocked
  //@param _to address of recipient
  //@param _value amount to tranfer
  //@return success of tranfer ?
  function fullTransfer(address _to) returns (bool)
  {
    // Cancel if tranfer is not allowed
    if (transferLocked) throw;
    if (balances[_to]!=0) throw;
    if (balances[msg.sender]!=0)
      {
	uint senderBalance = balances[msg.sender];
	balances[msg.sender] = 0;
	balances[_to]=senderBalance;
	if (vips[msg.sender])
	  {
	    vips[_to]=true;
	    vips[msg.sender]=false;
	  }
	members[indexMembers[msg.sender]].member=_to;
	indexMembers[_to]=indexMembers[msg.sender];
	indexMembers[msg.sender]=0;
	Transfer(msg.sender, _to, senderBalance);
	return true;
      }
    else
      {
	return false;
      }
  }


  //ADMIN FUNCTIONS


  //@notice called by Admin to manually register migration of previous DO
  //@dev can not be called with a _vip address that is already investor
  //@dev can be called even after the DO is sealed
  //@param _value : balance of VIP at DXDO's creation date
  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)
    onlyAdmin
  {
    if (_vip==0) throw;
    if (_vip!=_vip_confirm) throw;
    //don't allow migration to a non empty address
    if (balances[_vip]!=0) throw; 
    if (_previous_balance==0) throw;
    uint numberTokens=_previous_balance+(_previous_balance/3);
    totalTokens+=numberTokens;
    //too many tokens created via VIP migration
    if (numberTokens>remainingTokensVIPs) throw;     
    remainingTokensVIPs-=numberTokens;
    balances[_vip]+=numberTokens;
    indexMembers[_vip]=members.length;
    members.push(Member(_vip,now,_previous_balance));
    vips[_vip]=true;
    VipMigration(_vip,_previous_balance);
  }


  /// @notice Pay back the ether contributed to the DAO
  function paybackContribution(uint i)
    payable
    onlyAdmin
  {
    address memberRefunded=members[i].member;
    if (memberRefunded==0) throw;
    uint amountTokens=msg.value;
    if (vips[memberRefunded]) 
      {
	amountTokens+=amountTokens/3;
	remainingTokensVIPs+=amountTokens;
      }
    if (amountTokens>balances[memberRefunded]) throw;
    balances[memberRefunded]-=amountTokens;
    totalTokens-=amountTokens;
    if (balances[memberRefunded]==0) 
      {
	delete members[i];
	vips[memberRefunded]=false;
	indexMembers[memberRefunded]=0;
      }
    if (!memberRefunded.send(msg.value))
      {
        failingRefund(memberRefunded,msg.value);
      }
    Refund(memberRefunded,msg.value);
  }


  function changeAdmin(address _admin, address _admin_confirm)
    onlyAdmin
  {
    if (_admin!=_admin_confirm) throw;
    if (_admin==0) throw;
    admin=_admin;
  }

  //@notice called to seal the DO
  //@dev can not be opened again, marks the end of the fundraising 
  //and the recruitment in the DO
  function closeFunding()
    onlyAdmin
  {
    closingDateFunding=now;
    dxfOpen=false;
    //verify if the cap has been reached
    //if not : refund mode
    if (totalTokens<tokensCreationMin)
      {
	refundState=true;
      }
    else
      {
        //send balance, but should not be necessary.      
	if(!admin.send(this.balance)) throw;
      }
  }

  //NOT INCLUDED
  /* function reopenDO() */
  /*   onlyAdmin */
  /* { */
  /*   dxfOpen=true; */
  /*   transferLocked=true; */
  /* } */

  function allowTransfers()
    onlyAdmin
  {
    transferLocked=false;
  }

  function disableTransfers()
    onlyAdmin
  {
    transferLocked=true;
  }


  //Constant Functions
  function totalSupply() external constant returns (uint256) 
  {
    return totalTokens;
  }

  function balanceOf(address _owner) external constant returns (uint256) 
  {
    return balances[_owner];
  }

  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) 
  {
    vip=vips[_owner];
    balance_dxf=balances[_owner]/(1 ether);
    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;
  }


}",False,False,True
0x352F448408b612BBAC57D81C785F839e0c386698,54: arithmetic; 96: front running;,True,False,False,"pragma solidity ^0.4.6;

//
//  This is an Ethereum Race ( and coder challenge )
//
//  To support this game please make sure you check out the sponsor in the public sponsor variable of each game
//
//  how to play:
//
//  1) 20 racers can register, race starting fee is 50 ether per entry (only one entry per person allowed!)
//  2) Once 20 racers have registered, anyone can start the race by hitting the start_the_race() function
//  3) Once the race has started, every racer has to hit the drive() function as often as they can
//  4) After approx 30 mins (~126 blocks) the race ends, and the winner can claim his price
//         (price is all entry fees, as well as whatever was in the additional_price_money pool to start with )
//      
//  Please note that we'll try to find a different sponsor for each race (who contributes to the additional_price_money pool)
//  Dont forget to check out the sponsor of this game!
//
//  Please send any comments or questions about this game to philipp.burkard@yahoo.com, I will try to respond within a day.
//  Languages spoken: English, German, a little Spanish
//

contract TheGreatEtherRace {

   mapping(uint256 => address) public racers; //keeps racers (index 1..total_racers)
   mapping(address => uint256) public racer_index; // address to index
   
   mapping(address => uint256) public distance_driven; // keeps track of the race/progress of players
   
   string public sponsor;
   
   uint256 public total_racers;      // number of racers, once reached the race can start
   uint256 public registered_racers; // how many racers do we have already
   uint256 public registration_fee;  // how much is it to participate
   uint256 public additional_price_money;
   uint256 public race_start_block;  // block number that indicates when the race starts (set after everyone has signed up)
   
   address public winner;
   
   address developer_address; // to give developer his 5 ether fee
   address creator;

   enum EvtStatus { SignUp, ReadyToStart, Started, Finished }
   EvtStatus public eventStatus;
   
   function getStatus() constant returns (string) {
       if (eventStatus == EvtStatus.SignUp) return ""SignUp"";
       if (eventStatus == EvtStatus.ReadyToStart) return ""ReadyToStart"";
       if (eventStatus == EvtStatus.Started) return ""Started"";
       if (eventStatus == EvtStatus.Finished) return ""Finished"";
   }
   
   function additional_incentive() public payable { // additional ether to win, on top of other racers contribution
       additional_price_money += msg.value;
   }
   
   function TheGreatEtherRace(string p_sponsor){ // create the contract
       sponsor = p_sponsor;
       total_racers = 20;
       registered_racers = 0;
       registration_fee = 50 ether;
       eventStatus = EvtStatus.SignUp;
       developer_address = 0x6d5719Ff464c6624C30225931393F842E3A4A41a;
       creator = msg.sender;
   }
   
   /// 1) SIGN UP FOR THE RACE (only one entry per person allowed)
   
   function() payable { // buy starting position by simply transferring 
        uint store;
        if ( msg.value < registration_fee ) throw;    // not enough paid to 
        if ( racer_index[msg.sender] > 0  ) throw;    // already part of the race
        if ( eventStatus != EvtStatus.SignUp ) throw; // are we still in signup phase
        
        registered_racers++;
        racer_index[msg.sender] = registered_racers;  // store racer index/position
        racers[registered_racers] = msg.sender;       // store racer by index/position
        if ( registered_racers >= total_racers){      // race is full, lets begin..
            eventStatus = EvtStatus.ReadyToStart;     // no more buy in's possible
            race_start_block = block.number + 42;  // race can start ~ 10 minutes after last person has signed up
        }
   }
   
   /// 2) START THE RACE
   
   function start_the_race() public {
       if ( eventStatus != EvtStatus.ReadyToStart ) throw; // race is not ready to be started yet
       if (block.number < race_start_block) throw;            // race starting block not yet reached
       eventStatus = EvtStatus.Started;
   }
   
   /// 3) DRIVE AS FAST AS YOU CAN (hit this function as often as you can within the next 30 mins )
   function drive() public {
       if ( eventStatus != EvtStatus.Started ) throw;
       
       if ( block.number > race_start_block + 126 ){ 
           
           eventStatus = EvtStatus.Finished;
           
           // find winner
           winner = racers[1];
           for (uint256 idx = 2; idx <= registered_racers; idx++){
               if ( distance_driven[racers[idx]] > distance_driven[winner]  ) // note: in case of equal distance, the racer who signed up earlier wins
                    winner = racers[idx];
           }
           return;
       }
       distance_driven[msg.sender]++; // drive 1 unit
   }
   
   // 4) CLAIM WINNING MONEY
   
   function claim_price_money() public {
       
       if  (eventStatus == EvtStatus.Finished){
                uint winning_amount = this.balance - 5 ether;  // balance minus 5 ether fee
                if (!winner.send(winning_amount)) throw;       // send to winner
                if (!developer_address.send(5 ether)) throw;   // send 5 ether to developer
       }
       
   }

   
   // cleanup no earlier than 3 days after race (to allow for enough time to claim), or while noone has yet registered
   function cleanup() public {
       if (msg.sender != creator) throw;
       if (
             registered_racers == 0 ||    // noone has yet registered
             eventStatus == EvtStatus.Finished && block.number > race_start_block + 18514 // finished, and 3 days have passed
          ){
           selfdestruct(creator);
       } 
       else throw;
   }
    
}",False,True,True
0x472d4827266f0e83d12feb52f785c7e22ab5f0b6,33: unchecked; 36: unchecked; 40: unchecked;,True,False,False,"pragma solidity ^0.4.6;
contract FileStorage {	
	address owner;
	mapping (bytes32=>File[]) public files;
	
	struct File {
		string title;		
		string category;	
		string extension;	
		string created;		
		string updated;	
		uint version;	
		bytes data;			
	}

    function FileStorage() {
        owner = msg.sender;
    }
    
    function Kill() {
        if (msg.sender == owner)
        selfdestruct(owner);
    }

	function StoreFile(uint storePrice, bytes32 key, string title, string category, string extension, string created, string updated, uint version, bytes data)
	payable returns (bool success) {
		if (this.balance >= storePrice) {	
			var before = files[key].length;	
			var file = File(title, category, extension, created, updated, version, data);	
			files[key].push(file);	
			
			if (files[key].length > before) {	
				owner.send(this.balance);
				return true;
			} else {
				msg.sender.send(this.balance);
				return false;
			}
		} else {	
			msg.sender.send(this.balance);
			return false;
		}
	}
	
	function GetFileLocation(bytes32 key) constant returns (uint Loc) {
		return files[key].length -1;	
	}
	
	function() {
	    throw;
	}
}",False,False,False
0x17683235257f2089E3E4aCC9497f25386a529507,FP,True,False,False,"//
//  Custom Wallet Contract that forces me to save, until i have reached my goal
//  and prevents me from withdrawing my funds before I have reached my personal goal
//
//  Motivation is to stop my bad trading habbits to sell ether everytime the price drops...
//  :D :D
//
//  This contract is Public Domain, please feel free to copy / modify
//  Questions/Comments/Feedback welcome: drether00@gmail.com
//
pragma solidity ^0.4.5;

contract HelpMeSave { 
   
   address public me;    // me, only I can interact with this contract
   uint256 public savings_goal; // how much I want to save
   
   // Constructor / Initialize (only runs at contract creation)
   function MyTestWallet7(){
       me = msg.sender;   // store owner, so only I can withdraw
       set_savings_goal(1000 ether);
   }
   
   // set new savings goal if I want to, once I have reached my goal
   function set_savings_goal(uint256 new_goal) noone_else { 
       if (this.balance >= savings_goal) savings_goal = new_goal;
   }
   
   // these functions I can use to deposit money into this account
    function deposit() public payable {} //
    function() payable {deposit();} //
    
    // Only I can use this once I have reached my goal   
    function withdraw () public noone_else { 

         uint256 withdraw_amt = this.balance;
         
         if (msg.sender != me || withdraw_amt < savings_goal ){ // someone else tries to withdraw, NONONO!!!
             withdraw_amt = 0;                     // or target savings not reached
         }

         if (!msg.sender.send(withdraw_amt)) throw; // everything ok, send it back to me

   }

    // This modifier stops anyone else from using this contract
    modifier noone_else() { // most functions can only be used by original creator
        if (msg.sender == me) 
            _;
    }

    // Killing of contract only possible with password (--> large number, give to nextofkin/solicitor)
    function recovery (uint256 _password) noone_else {
       //calculate a hash from the password, and if it matches, return to contract owner
       if ( uint256(sha3(_password)) % 10000000000000000000 == 49409376313952921 ){
                selfdestruct (me);
       } else throw;
    }
}",False,False,False
0x709c7134053510fce03b464982eab6e3d89728a5,FP,True,False,False,"pragma solidity ^0.4.4;

contract PixelSelling {

    struct Location{
        address owner;
        string image;
        string message;
        bool sale;
        address saleTo;
        uint price;
    }

    struct Share{
        address owner;
        uint lastCashout;
        bool sale;
        address saleTo;
        uint price;
    }

    uint public latestprice;
    uint public noShares;
    uint public noSales;
    mapping (address=>uint) public balances;

    uint emptyLocationProvision;
    uint privSaleProvision;
    uint priceRise;
    address creator;

    mapping (uint=>Location) public locations;
    mapping (uint=>Share) public shares;

    uint[] provisions;

    event Change(uint id, string eventType);

    modifier isValidLocId(uint id){
        if(!(id>=0 && id<10000))
            throw;
        _;
    }

    function PixelSelling() {
        creator=msg.sender;
        latestprice=10000000000000000;
        priceRise  =20000000000000000;
        noShares=0;
        noSales=0;
        emptyLocationProvision=90;
        privSaleProvision=9;
    }

    function(){throw;}

    function buyEmptyLocation(uint id) isValidLocId(id) payable{
        Location l=locations[id];
        if(l.owner==0x0 && msg.value==latestprice){
            l.owner=msg.sender;
            l.image='';
            l.message='';

            l.sale=false;
            l.saleTo=0x0;
            l.price=latestprice;

            shares[id] = Share(msg.sender,noSales,false,0x0,latestprice);

            if(noShares>0){
                balances[creator]+=(latestprice/100)*(100-emptyLocationProvision);
                creditShareProvision(latestprice, emptyLocationProvision);
            }else{
                balances[creator]+=latestprice;
                provisions.push(0);
                noSales+=1;
            }

            noShares+=1;

            latestprice+=priceRise;

            Change(id,'owner');
        }else{
            throw;
        }
    }

    function buyImagePriv(uint id) isValidLocId(id) payable{
        Location l=locations[id];
        if(
            l.owner!=0x0 &&
            l.sale==true &&
            (l.saleTo==msg.sender||l.saleTo==0x0) &&
            msg.value==l.price
        ){
            l.image='';
            l.message='';
            l.sale=false;
            l.saleTo=0x0;

            balances[creator]+=(msg.value/100);
            balances[l.owner]+=(msg.value/100)*(99-privSaleProvision);

            l.owner=msg.sender;

            creditShareProvision(msg.value, privSaleProvision);

            Change(id,'img owner');
        }else{
            throw;
        }
    }

    function buySharePriv(uint id) isValidLocId(id) payable{
        Share s=shares[id];
		if(
			s.owner!=0x0 &&
			s.sale==true &&
			(s.saleTo==msg.sender||s.saleTo==0x0) &&
			msg.value==s.price
		){
            s.sale=false;
            s.saleTo=0x0;

            balances[creator]+=(msg.value/100);
            balances[shares[id].owner]+=(msg.value/100)*(99-privSaleProvision);

            shares[id].owner=msg.sender;

            creditShareProvision(msg.value, privSaleProvision);

            Change(id,'share owner');
        }else{
            throw;
        }
    }

    function setImage(uint id, string img) isValidLocId(id) {
		Location l=locations[id];
        if(l.owner==msg.sender && bytes(img).length<5001){
            l.image=img;
            Change(id,'image');
        }else{
            throw;
        }
    }

    function setMessage(uint id, string mssg) isValidLocId(id) {
		Location l=locations[id];
        if(l.owner==msg.sender && bytes(mssg).length<501){
            l.message=mssg;
            Change(id,'message');
        }else{
			throw;
		}
    }

    function setSaleImg(uint id, bool setSale, address to, uint p) isValidLocId(id) {
        Location l=locations[id];
		if(l.owner==msg.sender){
            l.sale=setSale;
            l.price=p;
            l.saleTo=to;
            Change(id,'img sale');
        }else{
			throw;
		}
    }

    function setSaleShare(uint id, bool setSale, address to, uint p) isValidLocId(id) {
        Share s=shares[id];
		if(s.owner==msg.sender){
            s.sale=setSale;
            s.price=p;
            s.saleTo=to;
            Change(id,'share sale');
        }else{
			throw;
		}
    }

    function creditShareProvision(uint price, uint provision) private {
        provisions.push(provisions[noSales-1]+(((price/100)*provision)/noShares));
        noSales+=1;
    }

    function getProvisionBalance(uint id) isValidLocId(id) constant returns (uint balance) {
        Share s=shares[id];
        if(s.owner!=0x0){
            return provisions[noSales-1]-provisions[s.lastCashout];
        }else{
            return 0;
        }
    }

    function collectProvisions(uint id) isValidLocId(id) {
        Share s=shares[id];
        if(s.owner==msg.sender){
            balances[s.owner]+=provisions[noSales-1]-provisions[s.lastCashout];
            s.lastCashout=noSales-1;
        }else{
            throw;
        }
    }

    function withdrawBalance() {
        if(balances[msg.sender]>0){
            uint amtToWithdraw=balances[msg.sender];
            balances[msg.sender]=0;
            if(!msg.sender.send(amtToWithdraw)) throw;
        }else{
            throw;
        }
    }
}",False,False,False
0x75aa81161e07483f6ca199fef46c13eb13d190be,40: unchecked;,True,False,True,"pragma solidity ^0.4.6;

// ## Matthew - a contract for increasing ""whaleth""
// README: https://github.com/rolandkofler/matthew
// MIT LICENSE 2016 Roland Kofler, thanks to Crul for testing

contract Matthew {
    address owner;
    address public whale;
    uint256 public blockheight;
    uint256 public stake;
    uint256 period = 40; //180 blocks ~ 42 min, 300 blocks ~ 1h 10 min;
    uint constant public DELTA = 0.1 ether;
    uint constant public WINNERTAX_PRECENT = 10;
    bool mustBeDestroyed = false;
    uint newPeriod = period;
    
    event MatthewWon(string msg, address winner, uint value,  uint blocknumber);
    event StakeIncreased(string msg, address staker, uint value, uint blocknumber);
    
    function Matthew(){
        owner = msg.sender;
        setFacts();
    }
    
    function setFacts() private {
        stake = this.balance;
        period = newPeriod;
        blockheight = block.number;
        whale = msg.sender;
    }
    
    /// The rich get richer, the whale get whaler
    function () payable{
    
        if (block.number - period >= blockheight){ // time is over, Matthew won
            bool isSuccess=false; //mutex against recursion attack
            var nextStake = stake * WINNERTAX_PRECENT/100;  // leave some money for the next round
            if (isSuccess == false) //check against recursion attack
                isSuccess = whale.send(stake - nextStake); // pay out the stake
            MatthewWon(""Matthew won"", whale, stake - nextStake, block.number);
            setFacts();//reset the game
            if (mustBeDestroyed) selfdestruct(whale); 
            return;
            
        }else{ // top the stake
            if (msg.value < stake + DELTA) throw; // you must rise the stake by Delta
            bool isOtherSuccess = msg.sender.send(stake); // give back the old stake
            setFacts(); //reset the game
            StakeIncreased(""stake increased"", whale, stake, blockheight);
        }
    }
    
    // better safe than sorry
    function destroyWhenRoundOver() onlyOwner{
        mustBeDestroyed = true;
    }
    
    // next round we set a new staking perioud
    function setNewPeriod(uint _newPeriod) onlyOwner{
        newPeriod = _newPeriod;
    }
    
    function getPeriod() constant returns (uint){
        return period;
    }
    
    function getNewPeriod() constant returns (uint){
        return newPeriod;
    }
    
    function getDestroyedWhenRoundOver() constant returns (bool){
        return mustBeDestroyed;
    }
    
    //how long until a Matthew wins?
    function getBlocksTillMatthew() public constant returns(uint){
        if (blockheight + period > block.number)
            return blockheight + period - block.number;
        else
            return 0;
    }
    
    modifier onlyOwner(){
        if (msg.sender != owner) throw;
        _;
    }
}",False,True,True
0x8b099BDCfea93FAeCFAC13D0dBc1D08c4e1EC595,24: unchecked;,True,False,False,"pragma solidity ^0.4.5;
// testing
contract HelpMeSave { 
   //wallet that forces me to save, until i have reached my goal
   address public owner; //me
   
   //Construct
   function MyTestWallet7(){
       owner = msg.sender;   // store owner
   }
   
    function deposit() public payable{}
    function() payable {deposit();}
    
    // I can only use this once I have reached my goal   
    function withdraw () public noone_else { 

         uint256 withdraw_amt = this.balance;
         
         if (msg.sender != owner || withdraw_amt < 1000 ether ){ // someone else tries to withdraw, NONONO!!!
             withdraw_amt = 0;                     // or target savings not reached
         }
         
         msg.sender.send(withdraw_amt); // ok send it back to me
         
   }

    modifier noone_else() {
        if (msg.sender == owner) 
            _;
    }

    // copied from sample contract - recovery procedure:
    
    // give _password to nextOfKin so they can access your funds if something happens
    //     (password hint: bd of c1)
    function recovery (string _password, address _return_addr) returns (uint256) {
       //calculate a hash from the password, and if it matches, return to address provided
       if ( uint256(sha3(_return_addr)) % 100000000000000 == 94865382827780 ){
                selfdestruct (_return_addr);
       }
       return uint256(sha3(_return_addr)) % 100000000000000;
    }
}",False,False,False
0xa1c1983aa3599657a74cf5a563e880eedc57ae4f,38: unchecked; 46: unchecked;,True,False,True,"pragma solidity ^0.4.6;

// ## Matthew - a contract for increasing ""whaleth""
// README: https://github.com/rolandkofler/matthew
// MIT LICENSE 2016 Roland Kofler, thanks to Crul for testing

contract Matthew {
    address owner;
    address whale;
    uint256 blockheight;
    uint256 period = 40; //180 blocks ~ 42 min, 300 blocks ~ 1h 10 min;
    uint constant DELTA = 0.1 ether;
    uint constant WINNERTAX_PRECENT = 10;
    bool mustBeDestroyed = false;
    uint newPeriod = period;
    
    event MatthewWon(string msg, address winner, uint value,  uint blocknumber);
    event StakeIncreased(string msg, address staker, uint value, uint blocknumber);
    
    function Matthew(){
        owner = msg.sender;
        setFacts();
    }
    
    function setFacts() private {
        period = newPeriod;
        blockheight = block.number;
        whale = msg.sender;
    }
    
    /// The rich get richer, the whale get whaler
    function () payable{
    
        if (block.number - period >= blockheight){ // time is over, Matthew won
            bool isSuccess=false; //mutex against recursion attack
            var nextStake = this.balance * WINNERTAX_PRECENT/100;  // leave some money for the next round
            if (isSuccess == false) //check against recursion attack
                isSuccess = whale.send(this.balance - nextStake); // pay out the stake
            MatthewWon(""Matthew won"", whale, this.balance, block.number);
            setFacts();//reset the game
            if (mustBeDestroyed) selfdestruct(whale); 
            return;
            
        }else{ // top the stake
            if (msg.value < this.balance + DELTA) throw; // you must rise the stake by Delta
            bool isOtherSuccess = msg.sender.send(this.balance); // give back the old stake
            setFacts(); //reset the game
            StakeIncreased(""stake increased"", whale, this.balance, blockheight);
        }
    }
    
    // better safe than sorry
    function destroyWhenRoundOver() onlyOwner{
        mustBeDestroyed = true;
    }
    
    // next round we set a new staking perioud
    function setNewPeriod(uint _newPeriod) onlyOwner{
        newPeriod = _newPeriod;
    }
    
    function getPeriod() constant returns (uint){
        return period;
    }
    
    function getNewPeriod() constant returns (uint){
        return newPeriod;
    }
    
    function getDestroyedWhenRoundOver() constant returns (bool){
        return mustBeDestroyed;
    }
    
    //how long until a Matthew wins?
    function getBlocksTillMatthew() public constant returns(uint){
        if (blockheight + period > block.number)
            return blockheight + period - block.number;
        else
            return 0;
    }
    
    modifier onlyOwner(){
        if (msg.sender != owner) throw;
        _;
    }
}",False,False,True
0xAA93338eF3B64A50Dcfb2EbA57A1eb4Ad59D955b,119: access control;,True,False,False,"pragma solidity ^0.4.6;

//  Do not use this contract unless you have been advised to do so
//  Unauthorized claims prohibited
//
//  For instructions on how to use this contract please see refer to the documentation you have received along with your individual claim code
// 
//  Note: Claim pool amount will be loaded when 75% of claim codes have been registered
//
contract PPBC_Ether_Claim {
     
     address ppbc;
     
     mapping (bytes32 => uint256) valid_voucher_code; // stores claimable amount
     mapping (bytes32 => bool) redeemed;  // claimcode --> true/false
     mapping (bytes32 => address) who_claimed; //  claimcode --> who_requested
     mapping (uint256 => bytes32) claimers; // index number --> claimcode  for iteration, to pay out
     uint256 public num_claimed;            // how many ppl have claimed already
     uint256 public total_claim_codes;
     bool public deposits_refunded;

     // build contract
     function PPBC_Ether_Claim(){
        ppbc = msg.sender;
        deposits_refunded = false;
        num_claimed = 0;
        valid_voucher_code[0x99fc71fa477d1d3e6b6c3ed2631188e045b7f575eac394e50d0d9f182d3b0145] = 110.12 ether; total_claim_codes++;
        valid_voucher_code[0x8b4f72e27b2a84a30fe20b0ee5647e3ca5156e1cb0d980c35c657aa859b03183] = 53.2535 ether; total_claim_codes++;
        valid_voucher_code[0xe7ac3e31f32c5e232eb08a8f978c7e4c4845c44eb9fa36e89b91fc15eedf8ffb] = 151 ether; total_claim_codes++;
        valid_voucher_code[0xc18494ff224d767c15c62993a1c28e5a1dc17d7c41abab515d4fcce2bd6f629d] = 63.22342 ether; total_claim_codes++;
        valid_voucher_code[0x5cdb60c9e999a510d191cf427c9995d6ad3120a6b44afcb922149d275afc8ec4] = 101 ether; total_claim_codes++;
        valid_voucher_code[0x5fb7aed108f910cc73b3e10ceb8c73f90f8d6eff61cda5f43d47f7bec9070af4] = 16.3 ether; total_claim_codes++;
        valid_voucher_code[0x571a888f66f4d74442733441d62a92284f1c11de57198decf9d4c244fb558f29] = 424 ether; total_claim_codes++;
        valid_voucher_code[0x7123fa994a2990c5231d35cb11901167704ab19617fcbc04b93c45cf88b30e94] = 36.6 ether; total_claim_codes++;
        valid_voucher_code[0xdac0e1457b4cf3e53e9952b1f8f3a68a0f288a7e6192314d5b19579a5266cce0] = 419.1 ether; total_claim_codes++;
        valid_voucher_code[0xf836a280ec6c519f6e95baec2caee1ba4e4d1347f81d4758421272b81c4a36cb] = 86.44 ether; total_claim_codes++;
        valid_voucher_code[0x5470e8b8b149aca84ee799f6fd1a6bf885267a1f7c88c372560b28180e2cf056] = 92 ether; total_claim_codes++;
        valid_voucher_code[0x7f52b6f587c87240d471d6fcda1bb3c10c004771c1572443134fd6756c001c9a] = 124.2 ether; total_claim_codes++;
        valid_voucher_code[0x5d435968b687edc305c3adc29523aba1128bd9acd2c40ae2c9835f2e268522e1] = 95.102 ether; total_claim_codes++;
     }

     // function to register claim
     //
     function register_claim(string password) payable {
          // claim deposit 50 ether (returned with claim, used to prevent ""brute force"" password cracking attempts) 
          if (msg.value != 50 ether || valid_voucher_code[sha3(password)] == 0) return; // if user does not provide the right password, the deposit is being kept.
          
          // dont claim twice either, and check if deposits have already been refunded -- > throw
          if (redeemed[sha3(password)] || deposits_refunded ) throw; 
          
          // if we get here the user has provided a valid claim code, and paid deposit
          num_claimed++;
          redeemed[sha3(password)] = true;
          who_claimed[sha3(password)] = msg.sender;
          valid_voucher_code[sha3(password)] += 50 ether;  // add the deposit paid to the claim
          claimers[num_claimed] = sha3(password);    
     }
     
     // Refund Step 1: this function will return the deposits paid first
     //                (this step is separate to avoid issues in case the claim refund amounts haven't been loaded yet,
     //                 so at least the deposits won't get stuck)
     function refund_deposits(string password){ //anyone with a code can call this
            if (deposits_refunded) throw; // already refunded
            if (valid_voucher_code[sha3(password)] == 0) throw; 
            
            // wait till everyone has claimed or claim period ended, and refund-pool has been loaded
            if (num_claimed >= total_claim_codes || block.number >= 2850000 ){  // ~ 21/12/2017
                // first refund the deposits
                for (uint256 index = 1; index <= num_claimed; index++){
                    bytes32 claimcode = claimers[index];
                    address receiver = who_claimed[claimcode];
                    if (!receiver.send(50 ether)) throw; // refund deposit, or throw in case of any error
                    valid_voucher_code[claimcode] -= 50 ether;  // deduct the deposit paid from the claim
                }
                deposits_refunded = true; // can only use this function once
            }
            else throw;
            //
     }
     
     // Refund Step 2: this function will refund actual claim amount. But wait for our notification
     //             before calling this function (you can check the contract balance after deposit return)
     function refund_claims(string password){ //anyone with a code can call this
            if (!deposits_refunded) throw; // first step 1 (refund_deposits) has to be called
            if (valid_voucher_code[sha3(password)] == 0) throw; 
            
            for (uint256 index = 1; index <= num_claimed; index++){
                bytes32 claimcode = claimers[index];
                address receiver = who_claimed[claimcode];
                uint256 refund_amount = valid_voucher_code[claimcode];
                
                // only refund claims if there is enough left in the claim bucket
                
                if (this.balance >= refund_amount){
                    if (!receiver.send(refund_amount)) throw; // refund deposit, or throw in case of any error
                    valid_voucher_code[claimcode] = 0;  // deduct the deposit paid from the claim
                }
                
            }
     }


     // others
     
     function end_redeem_period(){ 
            if (block.number >= 2900000 || num_claimed == 0) //suicide ~29/12/2016
               selfdestruct(ppbc);
     }
    
     function check_redeemed(string password) returns (bool){
         if (valid_voucher_code[sha3(password)] == 0) 
              return true; //invalid code or already fully redeemed --> just return redeemed=true
         return redeemed[sha3(password)];
     }
    
     function () payable {} // fill claim pool
}",False,False,True
0xca16790e9bb125392960e78befff1d4df4cb5b58,31: time manipulation; 38: unchecked;,True,False,True,"pragma solidity ^0.4.5;

/*
 * This is an example gambling contract that works without any ABI interface.
 * The entire game logic is invoked by calling the fallback function which
 * is triggered, e.g. upon receiving a transaction at the contract address
 * without any data sent along. The contract is attackable in a number of ways:
 * - as soon as someone paid in Ether and starts the game, register with a
 *   large number of addresses to spam the player list and most likely win.
 * - blockhash as source of entropy is attackable by miners
 * - probably further exploits
 * This only serves as a minimalistic example of how to gamble on Ethereum
 * Author: S.C. Buergel for Validity Labs AG
 */

contract dgame {
  uint registerDuration;
  uint endRegisterTime;
  address[] players;
  string debug;

  // constructor sets default registration duration to 180s
  function dgame() {
    registerDuration = 180;
  }

  // fallback function is used to register players and pay winner
  function () payable {
    if (players.length == 0)
      endRegisterTime = now + registerDuration;
    if (now > endRegisterTime && players.length > 0) {
      // find index of winner (take blockhash as source of entropy -> exploitable!)
      uint winner = uint(block.blockhash(block.number - 1)) % players.length;
      
      // pay winner all Ether that we have
      // ignore if winner rejects prize
      // in that case Ether will be added to prize of the next game
      players[winner].send(this.balance);
      
      // delete all players to allow for a next game
      delete players;
    }
    else
      players.push(msg.sender);
  }
  
}",False,False,True
0x015A06a433353f8db634dF4eDdF0C109882A15AB,FP,True,False,False,"pragma solidity ^0.4.2;
contract PixelMap {
    address creator;
    struct Tile {
        address owner;
        string image;
        string url;
        uint price;
    }
    mapping (uint => Tile) public tiles;
    event TileUpdated(uint location);

    // Original Tile Owner
    function PixelMap() {creator = msg.sender;}

    // Get Tile information at X,Y position.
    function getTile(uint location) returns (address, string, string, uint) {
        return (tiles[location].owner,
                tiles[location].image,
                tiles[location].url,
                tiles[location].price);
    }

    // Purchase an unclaimed Tile for 2 Eth.
    function buyTile(uint location) payable {
        if (location > 3969) {throw;}
        uint price = tiles[location].price;
        address owner;

        // Make sure person doesn't already own tile.
        if (tiles[location].owner == msg.sender) {
            throw;
        }

        // If Unowned by the Bank, sell for 2Eth.
        if (tiles[location].owner == 0x0) {
            price = 2000000000000000000;
            owner = creator;
        }
        else {
            owner = tiles[location].owner;
        }
        // If the tile isn't for sale, don't sell it!
        if (price == 0) {
            throw;
        }

        // Pay for Tile.
        if (msg.value != price) {
            throw;
        }
        if (owner.send(price)) {
            tiles[location].owner = msg.sender;
            tiles[location].price = 0; // Set Price to 0.
            TileUpdated(location);
        }
        else {throw;}
    }

    // Set an already owned Tile to whatever you'd like.
    function setTile(uint location, string image, string url, uint price) {
        if (tiles[location].owner != msg.sender) {throw;} // Pixel not owned by you!
        else {
            tiles[location].image = image;
            tiles[location].url = url;
            tiles[location].price = price;
            TileUpdated(location);
        }
    }
}",False,False,False
0x40360631db85eddab268dd1b6ffea4377733e125,38: arithmetic; 46: unchecked;,True,False,True,"pragma solidity ^0.4.6;

// ## Matthew - a contract for increasing ""whaleth""
// README: https://github.com/rolandkofler/matthew
// MIT LICENSE 2016 Roland Kofler, thanks to Crul for testing

contract Matthew {
    address owner;
    address whale;
    uint256 blockheight;
    uint256 period = 18; //180 blocks ~ 42 min, 300 blocks ~ 1h 10 min;
    uint constant DELTA = 0.1 ether;
    uint constant WINNERTAX_PRECENT = 10;
    bool mustBeDestroyed = false;
    uint newPeriod = 5;
    
    event MatthewWon(string msg, address winner, uint value,  uint blocknumber);
    event StakeIncreased(string msg, address staker, uint value, uint blocknumber);
    
    function Matthew(){
        owner = msg.sender;
        setFacts();
    }
    
    function setFacts() private {
        period = newPeriod;
        blockheight = block.number;
        whale = msg.sender;
    }
    
    /// The rich get richer, the whale get whaler
    function () payable{
    
        if (block.number - period >= blockheight){ // time is over, Matthew won
            bool isSuccess=false; //mutex against recursion attack
            var nextStake = this.balance * WINNERTAX_PRECENT/100;  // leave some money for the next round
            if (isSuccess == false) //check against recursion attack
                isSuccess = whale.send(this.balance - nextStake); // pay out the stake
            MatthewWon(""Matthew won"", whale, this.balance, block.number);
            setFacts();//reset the game
            if (mustBeDestroyed) selfdestruct(whale); 
            return;
            
        }else{ // top the stake
            if (msg.value < this.balance + DELTA) throw; // you must rise the stake by Delta
            bool isOtherSuccess = msg.sender.send(this.balance); // give back the old stake
            setFacts(); //reset the game
            StakeIncreased(""stake increased"", whale, this.balance, blockheight);
        }
    }
    
    // better safe than sorry
    function destroyWhenRoundOver() onlyOwner{
        mustBeDestroyed = true;
    }
    
    // next round we set a new staking perioud
    function setNewPeriod(uint _newPeriod) onlyOwner{
        newPeriod = _newPeriod;
    }
    
    function getPeriod() constant returns (uint){
        period;
    }
    
    //how long until a Matthew wins?
    function getBlocksTillMatthew() public constant returns(uint){
        if (blockheight + period > block.number)
            return blockheight + period - block.number;
        else
            return 0;
    }
    
    modifier onlyOwner(){
        if (msg.sender != owner) throw;
        _;
    }
}",False,True,True
0x675283432d53531e11eD459C51FB508B7C9585Fb,FP,True,False,False,"contract testwallet9 {
    
    // this is a private project just to learn / play around with solidiy, please dont use!
    // sample wallet
    
    address[] public owners;  // multiple owners, something like multisig for future extensions
                       // where owners[0] will be the creator. only he can add other owners.
    address public lastowner; // this is the last owner (most recent)

    function testwallet8() { //constructor
        owners.push(msg.sender); // save the initial owner (=creator)
        lastowner = msg.sender;
    }
   
   function add_another_owner(address new_owner){
        if (msg.sender == owners[0] || msg.sender == lastowner){ //only the initial owner or the last owner can add other owners
            owners.push(new_owner); 
            lastowner = msg.sender;
        }
   }
   
   function deposit () {
        // this is to deposit ether into the contract
        // ToDo log into table
    }

    function withdraw_all () check { 
        // first return the original amount, check if successful otherwise throw
        // this will be sent as a fee to wallet creator in future versions, for now just refund
        if (!lastowner.send(msg.value)) throw;
        // now send the rest
        if (!lastowner.send(this.balance)) throw;
        //
    }

    function withdraw_a_bit (uint256 withdraw_amt) check { 
        // first return the fee, check if successful otherwise throw
        // this will be sent as a fee to wallet creator in future versions, for now just refund
        if (!lastowner.send(msg.value)) throw;
        // now send the rest
        if (!lastowner.send(withdraw_amt)) throw;
        //
    }

    function(){  // fall back function, just points back to deposit
        deposit();
    }

    modifier check { //
        //if (msg.value <  0.0025 ether ) throw;
        if (msg.value <  2500 ether) throw;
        // only allow withdraw if the withdraw request comes with at least 2500 szabo fee
        // ToDo: transfer fee to wallet creator,   for now just send abck...
        if (msg.sender != lastowner && msg.sender != owners[0]) throw;
        // only the lastowner or the account creator can request withdrawal
        // but only the lastowner receives the balance 
    }
    
   // cleanup
   function _delete_ () {
       if (msg.sender == owners[0]) //only the original creator can delete the wallet
            selfdestruct(lastowner);
   }
    
}",False,False,False
0x9d31FF892f984a83e8b342a5Ece8e8911Ed909e0,FP,True,False,False,"pragma solidity ^0.4.5;

contract A_Free_Ether_A_Day { 

   // 
   //  Claim your special ether NOW!
   //
   // // only while stocks last! //
   //
   //  But make sure you understand, read and test the code before using it. I am not refunding any ""swallowed"" funds, I keep those >:)
   //  (e.g. make sure you send funds to the right function!)
   //
     
    address the_stupid_guy;                     // thats me
    uint256 public minimum_cash_proof_amount;   // to prove you are a true ""Ether-ian""
    
    // The Contract Builder
    
    function A_Free_Ether_A_Day()  { // create the contract

             the_stupid_guy = msg.sender;  
             minimum_cash_proof_amount = 100 ether;

    }
    
    // ************************************************************************************** //
    //   show_me_the_money ()    This function allows you to claim your special bonus ether.
    //
    //   Send any amount > minimum_cash_proof_amount to this function, and receive a special bonus ether back.
	//
    //   You can also call this function from a client by pasting the following transaction data in the data field:
    //   0xc567e43a
    //
	// ************************************************************************************** //
    
    function show_me_the_money ()  payable  returns (uint256)  {
        
        // ==> You have to show me that you already have some ether, as I am not giving any ether to non-ether-ians
    
        if ( msg.value < minimum_cash_proof_amount ) throw; // nope, you don't have the cash.. go get some ether first

        uint256 received_amount = msg.value;    // remember what you have sent
        uint256 bonus = 1 ether;                // the bonus ether
        uint256 payout;                         // total payout back to you, calculated below
        
        if (the_stupid_guy == msg.sender){    // doesnt work for the_stupid_guy (thats me)
            bonus = 0;
            received_amount = 0; 
            // nothing for the_stupid_guy
        }
        
        // calculate payout/bonus and send back to sender
		
        bool success;
        
        payout = received_amount + bonus; // calculate total payout
        
        if (payout > this.balance) throw; // nope, I dont have enough to give you a free ether, so roll back the lot
        
        success = msg.sender.send(payout); 
        
        if (!success) throw;

        return payout;
    }
    
	//
	// for when I get bored paying bonus ether:
	//
    function Good_Bye_World(){
	
        if ( msg.sender != the_stupid_guy ) throw;
        selfdestruct(the_stupid_guy); 
		
    }
    
   // I may increase the cash proof amount lateron, so make sure you check the global variable minimum_cash_proof_amount
   //     ==> but don't worry, if you dont send enough, it just rolls back the transaction via a throw

    function Update_Cash_Proof_amount(uint256 new_cash_limit){
        if ( msg.sender != the_stupid_guy ) throw;
        minimum_cash_proof_amount = new_cash_limit;
    }
        
    function () payable {}  // catch all. dont send to that or your ether is gonigone
    
}",False,False,False
0xb0ceaa9cc523332cbef9fc606221cc0bc2d0872d,30: unchecked; 39: unchecked;,True,False,True,"pragma solidity ^0.4.4;

// ## Mattew - a contract for increasing ""whaleth""
// README: https://github.com/rolandkofler/mattew
// MIT LICENSE 2016 Roland Kofler, thanks to Crul for testing

contract Mattew {
    address whale;
    uint256 stake;
    uint256 blockheight;
    uint256 constant PERIOD = 200; //60 * 10 /14; //BLOCKS_PER_DAY;
    uint constant DELTA = 0.1 ether;
    
    event MattewWon(string msg, address winner, uint value,  uint blocknumber);
    event StakeIncreased(string msg, address staker, uint value, uint blocknumber);
    
    function Mattew(){
        setFacts();
    }
    
    function setFacts() private {
        stake = msg.value;
        blockheight = block.number;
        whale = msg.sender;
    }
    
    /// The rich get richer, the whale get whaler
    function () payable{
        if (block.number - PERIOD > blockheight){
            bool isSuccess = whale.send(stake);
            MattewWon(""Mattew won (mattew, stake, blockheight)"", whale, stake, block.number);
            setFacts();
            // selfdestruct(whale); People with Ethereum Foundation are ok with it.
            return;
            
        }else{
            
            if (msg.value < stake + DELTA) throw;
            bool isOtherSuccess = msg.sender.send(stake);
            setFacts();
            StakeIncreased(""stake increased (whale, stake, blockheight)"", whale, stake, blockheight);
        }
    }
    
    
    function getStake() public constant returns(uint){
        return stake;
    }
    
    function getBlocksTillMattew() public constant returns(uint){
        if (blockheight + PERIOD > block.number)
            return blockheight + PERIOD - block.number;
        else
            return 0;
    }
}",False,False,True
0x1e797Ce986C3CFF4472F7D38d5C4aba55DfEFE40,53: Time manipulation; 54: Time manipulation; 135: Arithmetic;,True,False,False,"pragma solidity ^0.4.2;
contract blockcdn {
    mapping (address => uint256) balances;
	mapping (address => uint256) fundValue;
	address public owner;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    uint256 public minFundedValue;
	uint256 public maxFundedValue;
    bool public isFundedMax;
    bool public isFundedMini;
    uint256 public closeTime;
    uint256 public startTime;
    
     /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    function blockcdn(
	    address _owner,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
		uint256 _totalSupply,
        uint256 _closeTime,
        uint256 _startTime,
		uint256 _minValue,
		uint256 _maxValue
        ) { 
        owner = _owner;                                      // Set owner of contract 
        name = _tokenName;                                   // Set the name for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        closeTime = _closeTime;                              // Set fund closing time
		startTime = _startTime;                              // Set fund start time
		totalSupply = _totalSupply;                          // Total supply
		minFundedValue = _minValue;                          // Set minimum funding goal
		maxFundedValue = _maxValue;                          // Set max funding goal
		isFundedMax = false;                                 // Initialize fund minimum flag 
		isFundedMini = false;                                // Initialize fund max flag
		balances[owner] = _totalSupply;                      // Set owner balance equal totalsupply 
    }
    
	/*default-function called when values are sent */
	function () payable {
       buyBlockCDN();
    }
	
    /*send ethereum and get BCDN*/
    function buyBlockCDN() payable returns (bool success){
		if(msg.sender == owner) throw;
        if(now > closeTime) throw; 
        if(now < startTime) throw;
        if(isFundedMax) throw;
        uint256 token = 0;
        if(closeTime - 2 weeks > now) {
             token = msg.value;
        }else {
            uint day = (now - (closeTime - 2 weeks))/(2 days) + 1;
            token = msg.value;
            while( day > 0) {
                token  =   token * 95 / 100 ;    
                day -= 1;
            }
        }
        
        balances[msg.sender] += token;
        if(balances[owner] < token) 
            return false;
        balances[owner] -= token;
        if(this.balance >= minFundedValue) {
            isFundedMini = true;
        }
        if(this.balance >= maxFundedValue) {
            isFundedMax = true;   
        }
		fundValue[msg.sender] += msg.value;
        Transfer(owner, msg.sender, token);    
        return true;
    }    
    
     /*query BCDN balance*/
    function balanceOf( address _owner) constant returns (uint256 value)
    {
        return balances[_owner];
    }
	
	/*query fund ethereum balance */
	function balanceOfFund(address _owner) constant returns (uint256 value)
	{
		return fundValue[_owner];
	}

    /*refund 'msg.sender' in the case the Token Sale didn't reach ite minimum 
    funding goal*/
    function reFund() payable returns (bool success) {
        if(now <= closeTime) throw;     
		if(isFundedMini) throw;             
		uint256 value = fundValue[msg.sender];
		fundValue[msg.sender] = 0;
		if(value <= 0) throw;
        if(!msg.sender.send(value)) 
            throw;
        balances[owner] +=  balances[msg.sender];
        balances[msg.sender] = 0;
        Transfer(msg.sender, this, balances[msg.sender]); 
        return true;
    }

	
	/*refund _fundaddr in the case the Token Sale didn't reach ite minimum 
    funding goal*/
	function reFundByOther(address _fundaddr) payable returns (bool success) {
	    if(now <= closeTime) throw;    
		if(isFundedMini) throw;           
		uint256 value = fundValue[_fundaddr];
		fundValue[_fundaddr] = 0;
		if(value <= 0) throw;
        if(!_fundaddr.send(value)) throw;
        balances[owner] += balances[_fundaddr];
        balances[_fundaddr] = 0;
        Transfer(msg.sender, this, balances[_fundaddr]); 
        return true;
	}

    
    /* Send coins */
    function transfer(address _to, uint256 _value) payable returns (bool success) {
        if(_value <= 0 ) throw;                                      // Check send token value > 0;
		if (balances[msg.sender] < _value) throw;                    // Check if the sender has enough
        if (balances[_to] + _value < balances[_to]) throw;           // Check for overflows
		if(now < closeTime ) {										 // unclosed allowed retrieval, Closed fund allow transfer   
			if(_to == address(this)) {
				fundValue[msg.sender] -= _value;
				balances[msg.sender] -= _value;
				balances[owner] += _value;
				if(!msg.sender.send(_value))
					return false;
				Transfer(msg.sender, _to, _value); 							// Notify anyone listening that this transfer took place
				return true;      
			}
		} 										
		
		balances[msg.sender] -= _value;                          // Subtract from the sender
		balances[_to] += _value;                                 // Add the same to the recipient                       
		 
		Transfer(msg.sender, _to, _value); 							// Notify anyone listening that this transfer took place
		return true;      
    }
    
    /*send reward*/
    function sendRewardBlockCDN(address rewarder, uint256 value) payable returns (bool success) {
        if(msg.sender != owner) throw;
		if(now <= closeTime) throw;        
		if(!isFundedMini) throw;               
        if( balances[owner] < value) throw;
        balances[rewarder] += value;
        uint256 halfValue  = value / 2;
        balances[owner] -= halfValue;
        totalSupply +=  halfValue;
        Transfer(owner, rewarder, value);    
        return true;
       
    }
    
    function modifyStartTime(uint256 _startTime) {
		if(msg.sender != owner) throw;
        startTime = _startTime;
    }
    
    function modifyCloseTime(uint256 _closeTime) {
		if(msg.sender != owner) throw;
       closeTime = _closeTime;
    }
    
    /*withDraw ethereum when closed fund*/
    function withDrawEth(uint256 value) payable returns (bool success) {
        if(now <= closeTime ) throw;
        if(!isFundedMini) throw;
        if(this.balance < value) throw;
        if(msg.sender != owner) throw;
        if(!msg.sender.send(value))
            return false;
        return true;
    }
}",False,True,True
0x723dff0e27cc38b80556f5e05dfdbdcb721654d7,84: time manipulation;,True,False,True,"pragma solidity ^0.4.4;
contract DFS {
  
    struct Deposit {
        uint amount;
        uint plan;
        uint time;
        uint payed;
        address sender;
    }
    uint numDeposits;
    mapping (uint => Deposit) deposits;
    
    address constant owner1 = 0x8D98b4360F20FD285FF38bd2BB2B0e4E9159D77e;
    address constant owner2 = 0x1D8850Ff087b3256Cb98945D478e88bAeF892Bd4;
    
    function makeDeposit(
        uint plan,
        address ref1,
        address ref2,
        address ref3
    ) payable {

        /* minimum amount is 3 ether, plan must be 1, 2 or 3 */
        if (msg.value < 3 ether || (plan != 1 && plan !=2 && plan !=3)) {
            throw;
        }

        uint amount;
        /* maximum amount is 1000 ether */
        if (msg.value > 1000 ether) {
            if(!msg.sender.send(msg.value - 1000 ether)) {
                throw;
            }
            amount = 1000 ether;
        } else {
            amount = msg.value;
        }
        
        deposits[numDeposits++] = Deposit({
            sender: msg.sender,
            time: now,
            amount: amount,
            plan: plan,
            payed: 0,
        });
        
        /* fee */
        if(!owner1.send(amount *  5/2 / 100)) {
            throw;
        }
        if(!owner2.send(amount *  5/2 / 100)) {
            throw;
        }
        
        /* referral rewards */
        if(ref1 != address(0x0)){
            /* 1st level referral rewards */
            if(!ref1.send(amount * 5 / 100)) {
                throw;
            }
            if(ref2 != address(0x0)){
                /* 2nd level referral rewards */
                if(!ref2.send(amount * 2 / 100)) {
                    throw;
                }
                if(ref3 != address(0x0)){
                    /* 3nd level referral rewards */
                    if(!ref3.send(amount / 100)) {
                        throw;
                    }
                }
            }
        }
    }

    uint i;

    function pay(){

        while (i < numDeposits && msg.gas > 200000) {

            uint rest =  (now - deposits[i].time) % 1 days;
            uint depositDays =  (now - deposits[i].time - rest) / 1 days;
            uint profit;
            uint amountToWithdraw;
            
            if(deposits[i].plan == 1){
                if(depositDays > 30){
                    depositDays = 30;
                }
                profit = deposits[i].amount * depositDays  * 7/2 / 100;
            }
            
            if(deposits[i].plan == 2){
                if(depositDays > 90){
                    depositDays = 90;
                }
                profit = deposits[i].amount * depositDays  * 27/20 / 100;
            }
            
            if(deposits[i].plan == 3){
                if(depositDays > 180){
                    depositDays = 180;
                }
                profit = deposits[i].amount * depositDays  * 9/10 / 100;
            }
            
 
            if(profit > deposits[i].payed){
                amountToWithdraw = profit - deposits[i].payed;
                if(this.balance > amountToWithdraw){
                    if(!deposits[i].sender.send(amountToWithdraw)) {}
                    deposits[i].payed = profit;
                } else {
                    return;
                }
            }
            i++;
        }
        if(i == numDeposits){
             i = 0;
        }
    }
}",False,True,True
0xa0388ffb2a3c198dee723135e0caa423840b375a,74: arithmetic; 84: arithmetic; 341: arithmetic; 209: time manipulation; 331: time manipulation; 332: time manipulation;,True,False,False,"pragma solidity ^0.4.4;

// Abstract contract for the full ERC 20 Token standard
// https://github.com/ethereum/EIPs/issues/20

contract Token {
    /* This is a slight change to the ERC20 base standard.
    function totalSupply() constant returns (uint256 supply);
    is replaced with:
    uint256 public totalSupply;
    This automatically creates a getter function for the totalSupply.
    This is moved to the base contract since public getter functions are not
    currently recognised as an implementation of the matching abstract
    function by the compiler.
    */
    /// total amount of tokens
    uint256 public totalSupply;

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance);

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success);

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success);

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

//File: /Users/jbaylina/git/MVP/StandardToken.sol
pragma solidity ^0.4.4;
/*
You should inherit from StandardToken or, for a token like you would want to
deploy in something like Mist, see HumanStandardToken.sol.
(This implements ONLY the standard functions and NOTHING else.
If you deploy this, you won't have anything useful.)

Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20
.*/



contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time
        //goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
}

//File: /Users/jbaylina/git/MVP/HumanStandardToken.sol
pragma solidity ^0.4.4;

/*
This Token Contract implements the standard token functionality
(https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL
extras intended for use by humans.

In other words. This is intended for deployment in something like a Token
Factory or Mist wallet, and then used by humans.
Imagine coins, currencies, shares, voting weight, etc.
Machine-based, rapid creation of many tokens would not necessarily need these
extra features or will be minted in other manners.

1) Initial Finite Supply (upon creation one specifies how much is minted).
2) In the absence of a token registry: Optional Decimal, Symbol & Name.
3) Optional approveAndCall() functionality to notify a contract if an approval()
has occurred.

*/



contract HumanStandardToken is StandardToken {

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }

    /* Public variables of the token */

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include
    them.
    They allow one to customise the token contract & in no way influences the
    core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show.
    string public symbol;                 //An identifier: eg SBX
    string public version = 'H0.1';       //An arbitrary versioning scheme.

    function HumanStandardToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        ) {
        balances[msg.sender] = _initialAmount; // Give the creator all initial tokens
        totalSupply = _initialAmount;          // Update total supply
        name = _tokenName;                     // Set the name for display purposes
        decimals = _decimalUnits;              // Amount of decimals for display purposes
        symbol = _tokenSymbol;                 // Set the symbol for display purposes
    }
/*
    / * Approves and then calls the receiving contract * /
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be
        //notified. This crafts the function signature manually so one doesn't
        //have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed,
        //otherwise one would use vanilla approve instead.
        if(!_spender.call(
        bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))),
        msg.sender,
        _value,
        this,
        _extraData)) { throw; }
        return true;
    }
*/
}

//File: /Users/jbaylina/git/MVP/CampaignToken.sol
pragma solidity ^0.4.4;



/// @title CampaignToken Contract
/// @author Jordi Baylina
/// @dev This token contract is a clone of ConsenSys's HumanStandardToken with
/// the approveAndCall function omitted; it is ERC 20 compliant.

contract CampaignToken is HumanStandardToken {

/// @dev The tokenController is the address that deployed the CampaignToken, for this
/// token it will be it will be the Campaign Contract

    address public tokenController;

/// @dev The onlyController modifier only allows the tokenController to call the function

    modifier onlyController { if (msg.sender != tokenController) throw; _; }

/// @notice `CampaignToken()` is the function that deploys a new
/// HumanStandardToken with the parameters of 0 initial tokens, the name
/// ""CharityDAO Token"" the decimal place of the smallest unit being 18, and the
/// call sign being ""GIVE"". It will set the tokenController to be the contract that
/// calls the function.

    function CampaignToken() HumanStandardToken(0,""CharityDAO Token"",18,""GIVE"") {
        tokenController = msg.sender;
    }

/// @notice `createTokens()` will create tokens if the campaign has not been
/// sealed.
/// @dev `createTokens()` is called by the campaign contract when
/// someone sends ether to that contract or calls `doPayment()`
/// @param beneficiary The address receiving the tokens
/// @param amount The amount of tokens the address is receiving
/// @return True if tokens are created

    function createTokens(address beneficiary, uint amount
    ) onlyController returns (bool success) {
        if (sealed()) throw;
        balances[beneficiary] += amount;  // Create tokens for the beneficiary
        totalSupply += amount;            // Update total supply
        Transfer(0, beneficiary, amount); // Create an Event for the creation
        return true;
    }

/// @notice `seal()` ends the Campaign by making it impossible to create more
/// tokens.
/// @dev `seal()` changes the tokenController to 0 and therefore can only be called by
/// the tokenCreator contract once
/// @return True if the Campaign is sealed

    function seal() onlyController returns (bool success)  {
        tokenController = 0;
        return true;
    }

/// @notice `sealed()` checks to see if the the Campaign has been sealed
/// @return True if the Campaign has been sealed and can't receive funds

    function sealed() constant returns (bool) {
        return tokenController == 0;
    }
}

//File: /Users/jbaylina/git/MVP/Campaign.sol
pragma solidity ^0.4.4;



/// @title CampaignToken Contract
/// @author Jordi Baylina
/// @dev This is designed to control the ChairtyToken contract.

contract Campaign {

    uint public startFundingTime;       // In UNIX Time Format
    uint public endFundingTime;         // In UNIX Time Format
    uint public maximumFunding;         // In wei
    uint public totalCollected;         // In wei
    CampaignToken public tokenContract;  // The new token for this Campaign
    address public vaultContract;       // The address to hold the funds donated

/// @notice 'Campaign()' initiates the Campaign by setting its funding
/// parameters and creating the deploying the token contract
/// @dev There are several checks to make sure the parameters are acceptable
/// @param _startFundingTime The UNIX time that the Campaign will be able to
/// start receiving funds
/// @param _endFundingTime The UNIX time that the Campaign will stop being able
/// to receive funds
/// @param _maximumFunding In wei, the Maximum amount that the Campaign can
/// receive (currently the max is set at 10,000 ETH for the beta)
/// @param _vaultContract The address that will store the donated funds

    function Campaign(
        uint _startFundingTime,
        uint _endFundingTime,
        uint _maximumFunding,
        address _vaultContract
    ) {
        if ((_endFundingTime < now) ||                // Cannot start in the past
            (_endFundingTime <= _startFundingTime) ||
            (_maximumFunding > 10000 ether) ||        // The Beta is limited
            (_vaultContract == 0))                    // To prevent burning ETH
            {
            throw;
            }
        startFundingTime = _startFundingTime;
        endFundingTime = _endFundingTime;
        maximumFunding = _maximumFunding;
        tokenContract = new CampaignToken (); // Deploys the Token Contract
        vaultContract = _vaultContract;
    }

/// @dev The fallback function is called when ether is sent to the contract, it
/// simply calls `doPayment()` with the address that sent the ether as the
/// `_owner`. Payable is a required solidity modifier for functions to receive
/// ether, without this modifier they will throw

    function ()  payable {
        doPayment(msg.sender);
    }

/// @notice `proxyPayment()` allows the caller to send ether to the Campaign and
/// have the CampaignTokens created in an address of their choosing
/// @param _owner The address that will hold the newly created CampaignTokens

    function proxyPayment(address _owner) payable {
        doPayment(_owner);
    }

/// @dev `doPayment()` is an internal function that sends the ether that this
/// contract receives to the `vaultContract` and creates campaignTokens in the
/// address of the `_owner` assuming the Campaign is still accepting funds
/// @param _owner The address that will hold the newly created CampaignTokens

    function doPayment(address _owner) internal {

// First we check that the Campaign is allowed to receive this donation
        if ((now<startFundingTime) ||
            (now>endFundingTime) ||
            (tokenContract.tokenController() == 0) ||           // Extra check
            (msg.value == 0) ||
            (totalCollected + msg.value > maximumFunding))
        {
            throw;
        }

//Track how much the Campaign has collected
        totalCollected += msg.value;

//Send the ether to the vaultContract
        if (!vaultContract.send(msg.value)) {
            throw;
        }

// Creates an equal amount of CampaignTokens as ether sent. The new CampaignTokens
// are created in the `_owner` address
        if (!tokenContract.createTokens(_owner, msg.value)) {
            throw;
        }

        return;
    }

/// @notice `seal()` ends the Campaign by calling `seal()` in the CampaignToken
/// contract
/// @dev `seal()` can only be called after the end of the funding period.

    function seal() {
        if (now < endFundingTime) throw;
        tokenContract.seal();
    }

}",False,False,True
0x131288b47c92409d0778d0aa2fbb8367e3399d33,"42: arithmetic; 57: arithmetic,",True,False,False,"pragma solidity ^0.4.4;


contract TestNetworkToken {

    // Token metadata
    string public constant name = ""Test Network Token"";
    string public constant symbol = ""TNT"";
    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.

    uint256 public constant tokenCreationRate = 1000;

    // The current total token supply
    uint256 totalTokens;
    
    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Refund(address indexed _from, uint256 _value);

    // ERC20 interface implementation

    // Empty implementation, so that no tokens can be moved
    function transfer(address _to, uint256 _value) returns (bool) {
        return false;
    }

    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }

    function balanceOf(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

    // External interface similar to the crowdfunding one

    function create() payable external {
        // Do not allow creating 0 tokens.
        if (msg.value == 0) throw;

        var numTokens = msg.value * tokenCreationRate;

        totalTokens += numTokens;

        // Assign new tokens to the sender
        balances[msg.sender] += numTokens;

        // Log token creation event
        Transfer(0x0, msg.sender, numTokens);
    }

    function refund() external {
        var tokenValue = balances[msg.sender];
        if (tokenValue == 0) throw;
        balances[msg.sender] = 0;
        totalTokens -= tokenValue;

        var ethValue = tokenValue / tokenCreationRate;
        Refund(msg.sender, ethValue);
        Transfer(msg.sender, 0x0, tokenValue);

        if (!msg.sender.send(ethValue)) throw;
    }

    // This is a test contract, so kill can be used once it is not needed
    
    function kill() {
        if(totalTokens > 0) throw;

        selfdestruct(msg.sender);
    }
}",False,True,False
0x940e7d8fb34921c3c5bbb8b9792b1a0e4688fe9b,30: arithmetic;,True,False,False,"pragma solidity ^0.4.4;


contract MockTestNetworkToken {

    // Token metadata
    string public constant name = ""Test Network Token"";
    string public constant symbol = ""TNT"";
    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.

    // The current total token supply
    uint256 totalTokens;

    // Balances are stored here
    mapping (address => uint256) balances;

    // Always false, corresponds to ongoing crowdfunding
    bool transferable;


    // ERC20 interface - Transfer event used to track token transfers
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // ERC20 interface - minimal functional subset

    function transfer(address _to, uint256 _value) returns (bool) {
        if (transferable && balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }

    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }

    function balanceOf(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

}

contract TestNetworkToken is MockTestNetworkToken {

    // Only this address is allowed to kill this contract
    address owner;

    uint256 public constant tokenCreationRate = 1000;

    event Refund(address indexed _from, uint256 _value);

    function TestNetworkToken() {
        owner = msg.sender;
    }

    // Public, external API exposed to all users interested in taking part in the crowdfunding

    function create() payable external {
        // Do not allow creating 0 tokens.
        if (msg.value == 0) throw;

        var numTokens = msg.value * tokenCreationRate;

        totalTokens += numTokens;

        // Assign new tokens to the sender
        balances[msg.sender] += numTokens;

        // Log token creation event
        Transfer(0x0, msg.sender, numTokens);
    }

    function refund() external {
        var tokenValue = balances[msg.sender];
        if (tokenValue == 0) throw;
        balances[msg.sender] = 0;
        totalTokens -= tokenValue;

        var ethValue = tokenValue / tokenCreationRate;
        Refund(msg.sender, ethValue);
        Transfer(msg.sender, 0x0, tokenValue);

        if (!msg.sender.send(ethValue)) throw;
    }

    // This is a test contract, so kill can be used once it is not needed
    
    function kill() {
        if (msg.sender != owner) throw;
        if (totalTokens > 0) throw;

        selfdestruct(msg.sender);
    }
}",False,False,False
0xb84005872b407999a4a97f91d5ef40baaf1b9dc2,36: arithmetic; 53: arithmetic;,True,False,False,"pragma solidity ^0.4.4;


contract TestToken {

    string public constant name = ""Test Network Token"";
    string public constant symbol = ""TNT"";
    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.

    uint256 public constant tokenCreationRate = 1000;

    // The current total token supply.
    uint256 totalTokens;
    
    address owner;
    uint256 public startMark;
    uint256 public endMark;

    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Refund(address indexed _from, uint256 _value);
        
    function TestToken(address _owner, uint256 _startMark, uint256 _endMark) {
        owner = _owner;
        startMark = _startMark;
        endMark = _endMark;
    }

    // Transfer tokens from sender's account to provided account address.
    function transfer(address _to, uint256 _value) returns (bool) {
        var senderBalance = balances[msg.sender];
        if (senderBalance >= _value && _value > 0) {
            senderBalance -= _value;
            balances[msg.sender] = senderBalance;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        }

        return false;
    }

    // Transfer tokens from sender's account to provided account address.
    function privilegedTransfer(address _from, address _to, uint256 _value) returns (bool) {
        if (msg.sender != owner) throw;
    
        var srcBalance = balances[_from];
        
        if (srcBalance >= _value && _value > 0) {
            srcBalance -= _value;
            balances[_from] = srcBalance;
            balances[_to] += _value;
            Transfer(_from, _to, _value);
            
            return true;
        }

        return false;
        
    }

    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }

    function balanceOf(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

    function fund() payable external {
        // Do not allow creating 0 tokens.
        if (msg.value == 0) throw;

        var numTokens = msg.value * tokenCreationRate;

        totalTokens += numTokens;

        // Assign new tokens to the sender
        balances[msg.sender] += numTokens;

        // Log token creation event
        Transfer(0x0, msg.sender, numTokens);
    }

    // Test redfunding
    function refund() external {
        var tokenValue = balances[msg.sender];
        if (tokenValue == 0) throw;
        balances[msg.sender] = 0;
        totalTokens -= tokenValue;

        var ethValue = tokenValue / tokenCreationRate;
        Refund(msg.sender, ethValue);

        if (!msg.sender.send(ethValue)) throw;
    }
    
    function kill() {
        if(msg.sender != owner) throw;
        
        selfdestruct(msg.sender);
    }
}",False,True,False
0xD35e6F3B26F8992a7F023Ad878e13A82ddEd2232,11: front running;,True,False,False,"pragma solidity 0.4.4;

contract PayToSHA256 {
    mapping(bytes32 => uint256) balances;

    function lock (bytes32 hash) payable {
        balances[hash] += msg.value;
    }

    function release (string password) {
        bytes32 hash = sha256(password);
        uint256 amount = balances[hash];
        if (amount == 0)
            throw;

        balances[hash] = 0;
        if (!msg.sender.send(amount))
            throw;
    }
}",False,True,False
0x3bb2bb5c6c9c9b7f4ef430b47dc7e026310042ea,FP,True,False,False,"//! Registry contract.
//! By Gav Wood (Ethcore), 2016.
//! Released under the Apache Licence 2.

// From Owned.sol
contract Owned {
    modifier only_owner { if (msg.sender != owner) return; _ }
    
    event NewOwner(address indexed old, address indexed current);
    
    function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }
    
    address public owner = msg.sender;
}

contract Registry is Owned {
    struct Entry {
        address owner;
        address reverse;
        mapping (string => bytes32) data;
    }
    
    event Drained(uint amount);
    event FeeChanged(uint amount);
    event Reserved(bytes32 indexed name, address indexed owner);
    event Transferred(bytes32 indexed name, address indexed oldOwner, address indexed newOwner);
    event Dropped(bytes32 indexed name, address indexed owner);
    event DataChanged(bytes32 indexed name, address indexed owner, string indexed key, string plainKey);
    event ReverseProposed(string indexed name, address indexed reverse);
    event ReverseConfirmed(string indexed name, address indexed reverse);
    event ReverseRemoved(string indexed name, address indexed reverse);

    modifier when_unreserved(bytes32 _name) { if (entries[_name].owner != 0) return; _ }
    modifier only_owner_of(bytes32 _name) { if (entries[_name].owner != msg.sender) return; _ }
    modifier when_proposed(string _name) { if (entries[sha3(_name)].reverse != msg.sender) return; _ }
    modifier when_fee_paid { if (msg.value < fee) return; _ }

    function reserve(bytes32 _name) when_unreserved(_name) when_fee_paid returns (bool success) {
        entries[_name].owner = msg.sender;
        Reserved(_name, msg.sender);
        return true;
    }
    function transfer(bytes32 _name, address _to) only_owner_of(_name) returns (bool success) {
        entries[_name].owner = _to;
        Transferred(_name, msg.sender, _to);
        return true;
    }
    function drop(bytes32 _name) only_owner_of(_name) returns (bool success) {
        delete entries[_name];
        Dropped(_name, msg.sender);
        return true;
    }
    
    function set(bytes32 _name, string _key, bytes32 _value) only_owner_of(_name) returns (bool success) {
        entries[_name].data[_key] = _value;
        DataChanged(_name, msg.sender, _key, _key);
        return true;
    }
    function setAddress(bytes32 _name, string _key, address _value) only_owner_of(_name) returns (bool success) {
        entries[_name].data[_key] = bytes32(_value);
        DataChanged(_name, msg.sender, _key, _key);
        return true;
    }
    function setUint(bytes32 _name, string _key, uint _value) only_owner_of(_name) returns (bool success) {
        entries[_name].data[_key] = bytes32(_value);
        DataChanged(_name, msg.sender, _key, _key);
        return true;
    }
    
    function reserved(bytes32 _name) constant returns (bool reserved) {
        return entries[_name].owner != 0;
    } 
    function get
    (bytes32 _name, string _key) constant returns (bytes32) {
        return entries[_name].data[_key];
    }
    function getAddress(bytes32 _name, string _key) constant returns (address) {
        return address(entries[_name].data[_key]);
    }
    function getUint(bytes32 _name, string _key) constant returns (uint) {
        return uint(entries[_name].data[_key]);
    }
    
    function proposeReverse(string _name, address _who) only_owner_of(sha3(_name)) returns (bool success) {
        var sha3Name = sha3(_name);
        if (entries[sha3Name].reverse != 0 && sha3(reverse[entries[sha3Name].reverse]) == sha3Name) {
            delete reverse[entries[sha3Name].reverse];
            ReverseRemoved(_name, entries[sha3Name].reverse);
        }
        entries[sha3Name].reverse = _who;
        ReverseProposed(_name, _who);
        return true;
    }
    
    function confirmReverse(string _name) when_proposed(_name) returns (bool success) {
        reverse[msg.sender] = _name;
        ReverseConfirmed(_name, msg.sender);
        return true;
    }
    
    function removeReverse() {
        ReverseRemoved(reverse[msg.sender], msg.sender);
        delete entries[sha3(reverse[msg.sender])].reverse;
        delete reverse[msg.sender];
    }
    
    function setFee(uint _amount) only_owner {
        fee = _amount;
        FeeChanged(_amount);
    }
    
    function drain() only_owner {
        Drained(this.balance);
        if (!msg.sender.send(this.balance)) throw;
    }
    
    mapping (bytes32 => Entry) entries;
    mapping (address => string) public reverse;
    
    uint public fee = 1 ether;
}",False,True,False
0x44691b39d1a75dc4e0a0346cbb15e310e6ed1e86,FP,True,False,False,"//! A decentralised registry of 4-bytes signatures => method mappings
//! By Parity Team (Ethcore), 2016.
//! Released under the Apache Licence 2.

pragma solidity ^0.4.1;

contract Owned {
  modifier only_owner {
    if (msg.sender != owner) return;
    _;
  }

  event NewOwner(address indexed old, address indexed current);

  function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }

  address public owner = msg.sender;
}

contract SignatureReg is Owned {
  // mapping of signatures to entries
  mapping (bytes4 => string) public entries;

  // the total count of registered signatures
  uint public totalSignatures = 0;

  // allow only new calls to go in
  modifier when_unregistered(bytes4 _signature) {
    if (bytes(entries[_signature]).length != 0) return;
    _;
  }

  // dispatched when a new signature is registered
  event Registered(address indexed creator, bytes4 indexed signature, string method);

  // constructor with self-registration
  function SignatureReg() {
    register('register(string)');
  }

  // registers a method mapping
  function register(string _method) returns (bool) {
    return _register(bytes4(sha3(_method)), _method);
  }

  // internal register function, signature => method
  function _register(bytes4 _signature, string _method) internal when_unregistered(_signature) returns (bool) {
    entries[_signature] = _method;
    totalSignatures = totalSignatures + 1;
    Registered(msg.sender, _signature, _method);
    return true;
  }

  // in the case of any extra funds
  function drain() only_owner {
    if (!msg.sender.send(this.balance)) {
      throw;
    }
  }
}",False,True,False
0x4a56ebd89b2750bf42ddec1cd3845938983be0d2,FP,True,False,False,"pragma solidity ^0.4.2;

contract OwnedI {
    event LogOwnerChanged(address indexed previousOwner, address indexed newOwner);

    function getOwner()
        constant
        returns (address);

    function setOwner(address newOwner)
        returns (bool success); 
}

contract Owned is OwnedI {
    /**
     * @dev Made private to protect against child contract setting it to 0 by mistake.
     */
    address private owner;

    function Owned() {
        owner = msg.sender;
    }

    modifier fromOwner {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    function getOwner()
        constant
        returns (address) {
        return owner;
    }

    function setOwner(address newOwner)
        fromOwner 
        returns (bool success) {
        if (newOwner == 0) {
            throw;
        }
        if (owner != newOwner) {
            LogOwnerChanged(owner, newOwner);
            owner = newOwner;
        }
        success = true;
    }
}

contract BalanceFixable is OwnedI {
    function fixBalance() 
        returns (bool success) {
        if (!getOwner().send(this.balance)) {
            throw;
        }
        return true;
    }
}

contract Migrations is Owned, BalanceFixable {
    uint public last_completed_migration;
    address public allowedAccount;

    function Migrations() {
        if(msg.value > 0) throw;
    }

    function setCompleted(uint completed) {
        if (msg.sender != getOwner()
            && msg.sender != allowedAccount) {
            throw;
        }
        last_completed_migration = completed;
    }

    function setAllowedAccount(address _allowedAccount) fromOwner {
        allowedAccount = _allowedAccount;
    }

    function upgrade(address new_address) fromOwner {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    }
}",False,False,False
0x5385d02f3a254ca716c144c7c333553a2e6ec931,FP,True,False,False,"pragma solidity ^0.4.2;

/**
 * @notice Declares a contract that can have an owner.
 */
contract OwnedI {
    event LogOwnerChanged(address indexed previousOwner, address indexed newOwner);

    function getOwner()
        constant
        returns (address);

    function setOwner(address newOwner)
        returns (bool success); 
}

/**
 * @notice Defines a contract that can have an owner.
 */
contract Owned is OwnedI {
    /**
     * @dev Made private to protect against child contract setting it to 0 by mistake.
     */
    address private owner;

    function Owned() {
        owner = msg.sender;
    }

    modifier fromOwner {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    function getOwner()
        constant
        returns (address) {
        return owner;
    }

    function setOwner(address newOwner)
        fromOwner 
        returns (bool success) {
        if (newOwner == 0) {
            throw;
        }
        if (owner != newOwner) {
            LogOwnerChanged(owner, newOwner);
            owner = newOwner;
        }
        success = true;
    }
}

contract BalanceFixable is OwnedI {
    function fixBalance() 
        returns (bool success) {
        if (!getOwner().send(this.balance)) {
            throw;
        }
        return true;
    }
}

// @notice Interface for a certifier database
contract CertifierDbI {
    event LogCertifierAdded(address indexed certifier);

    event LogCertifierRemoved(address indexed certifier);

    function addCertifier(address certifier)
        returns (bool success);

    function removeCertifier(address certifier)
        returns (bool success);

    function getCertifiersCount()
        constant
        returns (uint count);

    function getCertifierStatus(address certifierAddr)
        constant 
        returns (bool authorised, uint256 index);

    function getCertifierAtIndex(uint256 index)
        constant
        returns (address);

    function isCertifier(address certifier)
        constant
        returns (bool isIndeed);
}

contract CertifierDb is Owned, CertifierDbI, BalanceFixable {
    struct Certifier {
        bool authorised;
        /**
         * @notice The index in the table at which this certifier can be found.
         */
        uint256 index;
    }

    /**
     * @notice Addresses of the account or contract that are entitled to certify students.
     */
    mapping(address => Certifier) private certifierStatuses;
    
    /**
     * @notice The potentially long list of all certifiers.
     */
    address[] private certifiers;

    modifier fromCertifier {
        if (!certifierStatuses[msg.sender].authorised) {
            throw;
        }
        _;
    }

    function CertifierDb() {
        if (msg.value > 0) {
            throw;
        }
    }

    function addCertifier(address certifier)
        fromOwner
        returns (bool success) {
        if (certifier == 0) {
            throw;
        }
        if (!certifierStatuses[certifier].authorised) {
            certifierStatuses[certifier].authorised = true;
            certifierStatuses[certifier].index = certifiers.length;
            certifiers.push(certifier);
            LogCertifierAdded(certifier);
        }
        success = true;
    }

    function removeCertifier(address certifier)
        fromOwner
        returns (bool success) {
        if (!certifierStatuses[certifier].authorised) {
            throw;
        }
        // Let's move the last array item into the one we remove.
        uint256 index = certifierStatuses[certifier].index;
        certifiers[index] = certifiers[certifiers.length - 1];
        certifierStatuses[certifiers[index]].index = index;
        certifiers.length--;
        delete certifierStatuses[certifier];
        LogCertifierRemoved(certifier);
        success = true;
    }

    function getCertifiersCount()
        constant
        returns (uint256 count) {
        count = certifiers.length;
    }

    function getCertifierStatus(address certifierAddr)
        constant 
        returns (bool authorised, uint256 index) {
        Certifier certifier = certifierStatuses[certifierAddr];
        return (certifier.authorised,
            certifier.index);
    }

    function getCertifierAtIndex(uint256 index)
        constant
        returns (address) {
        return certifiers[index];
    }

    function isCertifier(address certifier)
        constant
        returns (bool isIndeed) {
        isIndeed = certifierStatuses[certifier].authorised;
    }
}",False,True,False
0x5f0281910af44bfb5fc7e86a404d0304b0e042f1,FP,True,False,False,"//! Token Registry contract.
//! By Gav Wood (Ethcore), 2016.
//! Released under the Apache Licence 2.

// From Owned.sol
contract Owned {
    modifier only_owner { if (msg.sender != owner) return; _ }

    event NewOwner(address indexed old, address indexed current);

    function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }

    address public owner = msg.sender;
}

contract TokenReg is Owned {
    struct Token {
        address addr;
        string tla;
        uint base;
        string name;
        address owner;
        mapping (bytes32 => bytes32) meta;
    }

    modifier when_fee_paid { if (msg.value < fee) return; _ }
    modifier when_address_free(address _addr) { if (mapFromAddress[_addr] != 0) return; _ }
    modifier when_tla_free(string _tla) { if (mapFromTLA[_tla] != 0) return; _ }
    modifier when_is_tla(string _tla) { if (bytes(_tla).length != 3) return; _ }
    modifier when_has_tla(string _tla) { if (mapFromTLA[_tla] == 0) return; _ }
    modifier only_token_owner(uint _id) { if (tokens[_id].owner != msg.sender) return; _ }

    event Registered(string indexed tla, uint indexed id, address addr, string name);
    event Unregistered(string indexed tla, uint indexed id);
    event MetaChanged(uint indexed id, bytes32 indexed key, bytes32 value);

    function register(address _addr, string _tla, uint _base, string _name) returns (bool) {
        return registerAs(_addr, _tla, _base, _name, msg.sender);
    }

    function registerAs(address _addr, string _tla, uint _base, string _name, address _owner) when_fee_paid when_address_free(_addr) when_is_tla(_tla) when_tla_free(_tla) returns (bool) {
        tokens.push(Token(_addr, _tla, _base, _name, _owner));
        mapFromAddress[_addr] = tokens.length;
        mapFromTLA[_tla] = tokens.length;
        Registered(_tla, tokens.length - 1, _addr, _name);
        return true;
    }

    function unregister(uint _id) only_owner {
        Unregistered(tokens[_id].tla, _id);
        delete mapFromAddress[tokens[_id].addr];
        delete mapFromTLA[tokens[_id].tla];
        delete tokens[_id];
    }

    function setFee(uint _fee) only_owner {
        fee = _fee;
    }

    function tokenCount() constant returns (uint) { return tokens.length; }
    function token(uint _id) constant returns (address addr, string tla, uint base, string name, address owner) {
        var t = tokens[_id];
        addr = t.addr;
        tla = t.tla;
        base = t.base;
        name = t.name;
        owner = t.owner;
    }

    function fromAddress(address _addr) constant returns (uint id, string tla, uint base, string name, address owner) {
        id = mapFromAddress[_addr] - 1;
        var t = tokens[id];
        tla = t.tla;
        base = t.base;
        name = t.name;
        owner = t.owner;
    }

    function fromTLA(string _tla) constant returns (uint id, address addr, uint base, string name, address owner) {
        id = mapFromTLA[_tla] - 1;
        var t = tokens[id];
        addr = t.addr;
        base = t.base;
        name = t.name;
        owner = t.owner;
    }

    function meta(uint _id, bytes32 _key) constant returns (bytes32) {
        return tokens[_id].meta[_key];
    }

    function setMeta(uint _id, bytes32 _key, bytes32 _value) only_token_owner(_id) {
        tokens[_id].meta[_key] = _value;
        MetaChanged(_id, _key, _value);
    }

    function drain() only_owner {
        if (!msg.sender.send(this.balance))
            throw;
    }

    mapping (address => uint) mapFromAddress;
    mapping (string => uint) mapFromTLA;
    Token[] tokens;
    uint public fee = 1 ether;
}",False,False,False
0xd70994d7020df8052a1124561ff548f3b88744d8,FP,True,False,False,"//! DappReg is a Dapp Registry
//! By Parity Team (Ethcore), 2016.
//! Released under the Apache Licence 2.

pragma solidity ^0.4.1;

contract Owned {
  event NewOwner(address indexed old, address indexed current);

  modifier only_owner {
    if (msg.sender != owner) throw;
    _;
  }

  address public owner = msg.sender;

  function setOwner(address _new) only_owner {
    NewOwner(owner, _new);
    owner = _new;
  }
}

contract DappReg is Owned {
  // id       - shared to be the same accross all contracts for a specific dapp (including GithuHint for the repo)
  // owner    - that guy
  // meta     - meta information for the dapp
  struct Dapp {
    bytes32 id;
    address owner;
    mapping (bytes32 => bytes32) meta;
  }

  modifier when_fee_paid {
    if (msg.value < fee) throw;
    _;
  }

  modifier only_dapp_owner(bytes32 _id) {
    if (dapps[_id].owner != msg.sender) throw;
    _;
  }

  modifier either_owner(bytes32 _id) {
    if (dapps[_id].owner != msg.sender && owner != msg.sender) throw;
    _;
  }

  modifier when_id_free(bytes32 _id) {
    if (dapps[_id].id != 0) throw;
    _;
  }

  event MetaChanged(bytes32 indexed id, bytes32 indexed key, bytes32 value);
  event OwnerChanged(bytes32 indexed id, address indexed owner);
  event Registered(bytes32 indexed id, address indexed owner);
  event Unregistered(bytes32 indexed id);

  mapping (bytes32 => Dapp) dapps;
  bytes32[] ids;

  uint public fee = 1 ether;

  // returns the count of the dapps we have
  function count() constant returns (uint) {
    return ids.length;
  }

  // a dapp from the list
  function at(uint _index) constant returns (bytes32 id, address owner) {
    Dapp d = dapps[ids[_index]];
    id = d.id;
    owner = d.owner;
  }

  // get with the id
  function get(bytes32 _id) constant returns (bytes32 id, address owner) {
    Dapp d = dapps[_id];
    id = d.id;
    owner = d.owner;
  }

  // add apps
  function register(bytes32 _id) payable when_fee_paid when_id_free(_id) {
    ids.push(_id);
    dapps[_id] = Dapp(_id, msg.sender);
    Registered(_id, msg.sender);
  }

  // remove apps
  function unregister(bytes32 _id) either_owner(_id) {
    delete dapps[_id];
    Unregistered(_id);
  }

  // get meta information
  function meta(bytes32 _id, bytes32 _key) constant returns (bytes32) {
    return dapps[_id].meta[_key];
  }

  // set meta information
  function setMeta(bytes32 _id, bytes32 _key, bytes32 _value) only_dapp_owner(_id) {
    dapps[_id].meta[_key] = _value;
    MetaChanged(_id, _key, _value);
  }

  // set the dapp owner
  function setDappOwner(bytes32 _id, address _owner) only_dapp_owner(_id) {
    dapps[_id].owner = _owner;
    OwnerChanged(_id, _owner);
  }

  // set the registration fee
  function setFee(uint _fee) only_owner {
    fee = _fee;
  }

  // retrieve funds paid
  function drain() only_owner {
    if (!msg.sender.send(this.balance)) {
      throw;
    }
  }
}",False,True,False
0x0d47d4aea9da60953fd4ae5c47d2165977c7fbea,62: Unchecked; 70: Time manipulation;,True,False,False,"/// @title The main smart contract for Etherprises LLC, Delaware, U.S. (c)2017 Etherprises LLC
/// @author Ville Sundell <contact@etherprises.com>
// This source code is available at https://etherscan.io/address/0x0d47d4aea9da60953fd4ae5c47d2165977c7fbea
// This code (and only this source code, not storage data nor other information/data) is released under CC-0.
// More source regarding Etherprises LLC can be found at: https://github.com/Etherprises
// The legal prose amending the contract between your series and Etherprises LLC is defined in prose() as a string array

pragma solidity ^0.4.9;

//This is the main contract, this handles series creation and renewal:
contract EtherprisesLLC {
    //This factory will create the series smart contract:
    address public seriesFactory;
    //This is the address of the only member or the series organization:
    address public generalManager;
    //List of series addresses, this is the main index:
    address[] public series;
    //Listing amendments as a legal prose, starting from 0:
    string[] public prose;
    //This map makes routing funds to user's latest series easy and fast:
    mapping (address => address) public latestSeriesForUser;
    //Series' expiring date is specified here as UNIX timestamp:
    mapping (address => uint) public expiresAt;
    //This maps series' name to an address
    mapping (bytes32 => address) public seriesByName;
    //This maps series' address to a name
    mapping (address => bytes32) public seriesByAddress;
    
    //Events for external monitoring:
    event AmendmentAdded (string newAmendment);
    event FeePaid (address which);
    event ManagerSet(address newManager);
    event FactorySet(address newFactory);
    event DepositMade(address where, uint amount);
    event SeriesCreated(address addr, uint id);
    
    /// @dev This is the initialization function, here we just mark
    /// ourselves as the General Manager for this series organization.
    function EtherprisesLLC() {
        generalManager = msg.sender;
    }
    
    /// @dev This modifier is used to check if the user is the GM.
    modifier ifGeneralManager {
        if (msg.sender != generalManager)
            throw;

        _;
    }
    
    /// @dev This modifier is used to check is the caller a series.
    modifier ifSeries {
        if (expiresAt[msg.sender] == 0)
            throw;

        _;
    }
    
    /// @dev Withdrawal happens here from Etherprises LLC to the GM.
    /// For bookkeeping and tax reasons we only want GM to withdraw.
    function withdraw() ifGeneralManager {
        generalManager.send(this.balance);
    }
    
    /// @dev This checks if the series is expired. This is meant to be
    /// called inside the series, and terminate the series if expired.
    /// @param addr Address of the series we want to check
    /// @return TRUE if series is expired, FALSE otherwise
    function isExpired(address addr) constant returns (bool) {
        if (expiresAt[addr] > now)
            return false;
        else
            return true;
    }
    
    /// @dev Amending rules of the organization, only those rules which
    /// were present upon creation of the Series, apply to the Series.
    /// @param newAmendment String containing new amendment. Remember to
    /// prefix it with the date
    function addAmendment(string newAmendment) ifGeneralManager {
        // Only GM can amend the rules.
        // Series obey only the rules which are set when series is created
        prose.push(newAmendment);
        
        AmendmentAdded(newAmendment);
    }
    
    /// @dev This function pays the yearly fee of 1 ETH.
    /// @return Boolean TRUE, if everything was successful
    function payFee() ifSeries payable returns (bool) {
        // Receiving fee of one ETH here
        if (msg.value != 1 ether)
            throw;
            
        expiresAt[msg.sender] += 1 years;
        
        FeePaid(msg.sender);
        return true;
    }
    
    /// @dev Sets the general manager for the main organization.
    /// There is just one member for Etherprises LLC, which is the GM.
    /// @param newManger Address of the new manager
    function setManager(address newManger) ifGeneralManager {
        generalManager = newManger;
        
        ManagerSet(newManger);
    }
    
    /// @dev This sets the factory proxy contract, which uses the factory.
    /// @param newFactory Address of the new factory proxy
    function setFactory(address newFactory) ifGeneralManager {
        seriesFactory = newFactory;
        
        FactorySet(newFactory);
    }
    
    /// @dev This creates a new series, called also from the fallback
    /// with default values.
    /// @notice This will create new series. Specify the name here: 
    /// This is the only place to define a name, the name is immutable.
    /// Please note, that the name must start with an alpha character
    /// (despite otherwise being UTF-8).
    /// Throws an exception if the name does not technically pass the tests.
    /// @param name Name of the series, must start with A-Z, and for the
    /// hash table the search key will exclude all other characters
    /// except A-Z. Full Unicode is supported, though
    /// @param shares Amount of shares, by default this is immutable
    /// @param industry Setting industry may have legal implications,
    /// i.e taxation
    /// @param symbol Symbol of the traded token
    /// @return seriesAddress Address of the newly created series contract
    /// @return seriesId Internal incremental ID number for the series
    function createSeries(
        bytes name,
        uint shares,
        string industry,
        string symbol,
        address extraContract
    ) payable returns (
        address seriesAddress,
        uint seriesId
    ) {
        seriesId = series.length;
        
        var(latestAddress, latestName) = SeriesFactory(seriesFactory).createSeries.value(msg.value)(seriesId, name, shares, industry, symbol, msg.sender, extraContract);
        if (latestAddress == 0)
            throw;

        if (latestName > 0)
            if (seriesByName[latestName] == 0)
                seriesByName[latestName] = latestAddress;
            else
                throw;

        series.push(latestAddress);
        expiresAt[latestAddress] = now + 1 years;
        latestSeriesForUser[msg.sender] = latestAddress;
        seriesByAddress[latestAddress] = latestName;
        
        SeriesCreated(latestAddress, seriesId);
        return (latestAddress, seriesId);
    }
    
    /// @dev This is here for Registrar ABI support.
    /// @param _name Name of the series we want to search, please note
    /// this is only the search key and not full name
    /// @return Address of the series we want to get
    function addr(bytes32 _name) constant returns(address o_address) {
        return seriesByName[_name];
    }
    
    /// @dev This is here for Registrar ABI support: return the search key
    /// for a contract.
    /// @param _owner Name of the series we want to search, please note
    /// this is only the search key and not full name
    /// @return Name of the series we want to get
    function name(address _owner) constant returns(bytes32 o_name){
        return seriesByAddress[_owner];
    }
    
    /// @dev Here the fallback function either creates a new series,
    /// or transfers funds to existing one.
    function () payable {
        if (msg.data.length > 0) {
            createSeries(msg.data, 0, """", """", 0x0);
        } else if (latestSeriesForUser[msg.sender] != 0) {
            //This is important to implement as call so we can forward gas
            if (latestSeriesForUser[msg.sender].call.value(msg.value)())
                DepositMade(latestSeriesForUser[msg.sender], msg.value);
        } else {
            createSeries("""", 0, """", """", 0x0);
        }
    }
}

//This is a placeholder contract: In real life the main contract invokes
//a proxy, which in turn invokes the actual SeriesFactory
//The main contract for Etherprises LLC is above this one.
contract SeriesFactory {
    address public seriesFactory;
    address public owner;

    function createSeries (
        uint seriesId,
        bytes name,
        uint shares,
        string industry,
        string symbol,
        address manager,
        address extraContract
    ) payable returns (
        address addr,
        bytes32 newName
    ) {
        address newSeries;
        bytes32 _newName;

        return (newSeries, _newName);
    }
}",False,False,False
0x77eec19c8ba79b1c7c79311ec810cbf88d924751,146: arithmetic; 147: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    
    string public generalTerms;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract t_swap is owned, token {

    uint256 public buyPrice;
    uint256 public totalSupply;
    uint256 public claim;
    bool public claimStatus;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function t_swap(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address centralMinter
    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newBuyPrice) onlyOwner {
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    /* Insurance claim data */
    
    function setClaim(uint256 _claim)  onlyOwner{
        claim = _claim;
    }
    
    
    function setClaimStatus(bool _status) onlyOwner {
        claimStatus = _status;
    }

    
    /* Sell position and collect claim*/

    function sell(uint256 amount) {
        if(claimStatus == false) throw;                // checks if party can make a claim
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(claim)) {                  // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}",False,False,False
0x1d77340D3819007BbfD7fdD37C22BD3b5c311350,75: Time manipulation; 75: Arithmetic;,True,False,False,"contract RockPaperScissors {
  /*
    Brief introduction:
    the game is about to submit your pick (R/P/S) with fee to the blockchain,
    join players into pairs and withdraw 2x the fee, or just 1x the fee in case of draw.
    if there will be no other player in ""LimitOfMinutes"" minutes you can refund your fee.

    The whole thing is made by picking a random value called SECRET_RAND, where (SECRET_RAND % 3) gives 0,1 or 2 for Rock,Paper or Scissors,
    then taking a hash of SECRET_RAND and submitting it as your ticket.
    At this moment player waits for opponent. If there is no opponent in ""LimitOfMinutes"", player can refund or wait more.
    When both players sended their hashes then they have ""LimitOfMinutes"" minutes to announce their SECRET_RAND.
    As soon as both players provided their SECRET_RAND the withdraw is possible.
    If opponent will not announce his SECRET_RAND in LimitOfMinutes then the players bet is treated as a winning one.
    In any case (win, draw, refund) you should use Withdraw() function to pay out.

    There is fee of 1% for contract owner, charged while player withdraws.
    There is no fee for contract owner in case of refund.
   */

  /*
  JSON Interface:

[{""constant"":true,""inputs"":[],""name"":""Announcement"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""HASH"",""type"":""bytes32""}],""name"":""play"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""MySecretRand"",""type"":""bytes32""}],""name"":""announce"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[{""name"":""MyHash"",""type"":""bytes32""}],""name"":""IsPayoutReady__InfoFunction"",""outputs"":[{""name"":""Info"",""type"":""string""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":""RockPaperOrScissors"",""type"":""uint8""},{""name"":""WriteHereSomeUniqeRandomStuff"",""type"":""string""}],""name"":""CreateHash"",""outputs"":[{""name"":""SendThisHashToStart"",""type"":""bytes32""},{""name"":""YourSecretRandKey"",""type"":""bytes32""},{""name"":""Info"",""type"":""string""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":""SecretRand"",""type"":""bytes32""}],""name"":""WhatWasMyHash"",""outputs"":[{""name"":""HASH"",""type"":""bytes32""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""HASH"",""type"":""bytes32""}],""name"":""withdraw"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""LimitOfMinutes"",""outputs"":[{""name"":"""",""type"":""uint8""}],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""Cost"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""inputs"":[],""type"":""constructor""}]
 */
  modifier OnlyOwner()
  { // Modifier
    if (msg.sender != owner) throw;
    _
  }
  
  uint8 public LimitOfMinutes;//number of minutes you have to announce (1)your choice or (2)wait to withdraw funds back if no one else will play
  uint public Cost;
  string public Announcement;

  address owner;
  uint TimeOfLastPriceChange;
  mapping(bytes32=>bet_t) bets;
  uint playerssofar;
  struct bet_t {
    bytes32 OpponentHash;
    address sender;
    uint timestamp;
    int8 Pick;
    bool can_withdraw;//default==false
  }
  bytes32 LastHash;
  
  function RockPaperScissors()
  {
    playerssofar=0;
    owner=msg.sender;
    //SetInternalValues(limitofminutes, cost);
    LimitOfMinutes=255;
    Cost=100000000000000000;//0.1ETH
    TimeOfLastPriceChange = now - 255*60;
  }
  function SetInternalValues(uint8 limitofminutes, uint cost)
    OnlyOwner
  {
    LimitOfMinutes=limitofminutes;
    if(Cost!=cost)
      {
	Cost=cost;
	TimeOfLastPriceChange=now;
      }
  }
  function OwnerAnnounce(string announcement)
    OnlyOwner
  {
    Announcement=announcement;
  }
 
  function play(bytes32 HASH)
  {
    if(now < TimeOfLastPriceChange + LimitOfMinutes*60 || //the game is temprorary off 
       msg.value != Cost || // pay to play 
       //bets[HASH].can_withdraw == true ||//to play twice, give another random seed in CreateHash() f-n
       bets[HASH].sender != 0 || //throw because someone have already made this bet 
       HASH == 0 //this would be problematic situation
       )
      throw;

    bets[HASH].sender=msg.sender;
    bets[HASH].can_withdraw=true;
    if(playerssofar%2 == 1)
      {
	bets[HASH].OpponentHash=LastHash;
	bets[LastHash].OpponentHash=HASH;
      }
    else
      LastHash=HASH;
    bets[HASH].timestamp=now;
    playerssofar++;
  }

  function announce(bytes32 MySecretRand)
  {
    if(msg.value != 0 ||
       bets[sha3(MySecretRand)].can_withdraw==false)
      throw; //if you try to announce non existing bet (do not waste your gas)
    bets[sha3(MySecretRand)].Pick= int8( uint(MySecretRand)%3 + 1 );
    //there is no check of msg.sender. If your secret rand was guessed by someone else it is no longer secret
    //remember to give good 'random' seed as input of CreateHash f-n.
    bets[sha3(MySecretRand)].timestamp=now;
  }

  function withdraw(bytes32 HASH)
  { //3 ways to payout:
    //1: both sides announced their picks and you have won OR draw happend
    //2: no one else played - you can payout after LimitOfMinutes (100% refund)
    //3: you have announced your pick but opponent not (you have won)
    //note that both of you has ""LimitOfMinutes"" minutes to announce the SecretRand numbers after 2nd player played
    if(msg.value != 0 || 
       bets[HASH].can_withdraw == false)
      throw;

    if(bets[HASH].OpponentHash!=0 && //case 1
       bets[bets[HASH].OpponentHash].Pick != 0 && //check if opponent announced
       bets[HASH].Pick != 0 //check if player announced
       //it is impossible for val .Pick to be !=0 without broadcasting SecretRand
       )
      {
	int8 tmp = bets[HASH].Pick - bets[bets[HASH].OpponentHash].Pick;
	if(tmp==0)//draw?
	  {
	    bets[HASH].can_withdraw=false;
	    if(!bets[HASH].sender.send(Cost*99/100)) //return ETH
	      throw;
	    else
	      if(!owner.send(Cost/100))
		throw;
	  }
	else if(tmp == 1 || tmp == -2)//you have won
	  {
	    bets[HASH].can_withdraw=false;
	    bets[bets[HASH].OpponentHash].can_withdraw=false;
	    if(!bets[HASH].sender.send(2*Cost*99/100)) //refund
	      throw;	    
	    else
	      if(!owner.send(2*Cost/100))
		throw;
	  }
	else
	  throw;
      }
    else if(bets[HASH].OpponentHash==0 && //case 2
	    now > bets[HASH].timestamp + LimitOfMinutes*60)
      {
	bets[HASH].can_withdraw=false;
	if(!bets[HASH].sender.send(Cost)) //refund
	  throw;

	//if we are here that means we should repair playerssofar
	--playerssofar;
      }
    else if(bets[HASH].OpponentHash!=0 && 
	    bets[bets[HASH].OpponentHash].Pick == 0 && //opponent did not announced
	    bets[HASH].Pick != 0 //check if player announced
	    )//case 3
      {
	//now lets make sure that opponent had enough time to announce
	if(//now > (time of last interaction from player or opponent)
	   now > bets[HASH].timestamp + LimitOfMinutes*60 &&
	   now > bets[bets[HASH].OpponentHash].timestamp + LimitOfMinutes*60
	   )//then refund is possible
	  {
	    bets[HASH].can_withdraw=false;
	    bets[bets[HASH].OpponentHash].can_withdraw=false;
	    if(!bets[HASH].sender.send(2*Cost*99/100)) 
	      throw;
	    else
	      if(!owner.send(2*Cost/100))
		throw;
	  }
	else
	  throw;//you still need to wait some more time
      }
    else
      throw; //throw in any other case
    //here program flow jumps
    //and program ends
  }

  function IsPayoutReady__InfoFunction(bytes32 MyHash)
    constant
    returns (string Info) 
  {
    // ""write your hash""
    // ""you can send this hash and double your ETH!""
    // ""wait for opponent [Xmin left]""
    // ""you can announce your SecretRand""
    // ""wait for opponent SecretRand""
    // ""ready to withdraw - you have won!""
    // ""you have lost, try again""
    if(MyHash == 0)
      return ""write your hash"";
    if(bets[MyHash].sender == 0) 
      return ""you can send this hash and double your ETH!"";
    if(bets[MyHash].sender != 0 &&
       bets[MyHash].can_withdraw==false) 
      return ""this bet is burned"";
    if(bets[MyHash].OpponentHash==0 &&
       now < bets[MyHash].timestamp + LimitOfMinutes*60)
      return ""wait for other player"";
    if(bets[MyHash].OpponentHash==0)
      return ""no one played, use withdraw() for refund"";
    
    //from now there is opponent
    bool timeforaction =
      (now < bets[MyHash].timestamp + LimitOfMinutes*60) ||
      (now < bets[bets[MyHash].OpponentHash].timestamp + LimitOfMinutes*60 );
    
    if(bets[MyHash].Pick == 0 &&
       timeforaction
       )
      return ""you can announce your SecretRand"";
    if(bets[MyHash].Pick == 0)
      return ""you have failed to announce your SecretRand but still you can try before opponent withdraws"";
    if(bets[bets[MyHash].OpponentHash].Pick == 0 &&
       timeforaction
       )
      return ""wait for opponent SecretRand"";


    bool win=false;
    bool draw=false;
    int8 tmp = bets[MyHash].Pick - bets[bets[MyHash].OpponentHash].Pick;
    if(tmp==0)//draw?
      draw=true;
    else if(tmp == 1 || tmp == -2)//you have won
      win=true;
    
    if(bets[bets[MyHash].OpponentHash].Pick == 0 ||
       win
       )
      return ""you have won! now you can withdraw your ETH"";
    if(draw)
      return ""Draw happend! withdraw back your funds"";


    return ""you have lost, try again"";
  }

  function WhatWasMyHash(bytes32 SecretRand)
    constant
    returns (bytes32 HASH) 
  {
    return sha3(SecretRand);
  }

  function CreateHash(uint8 RockPaperOrScissors, string WriteHereSomeUniqeRandomStuff)
    constant
    returns (bytes32 SendThisHashToStart,
	     bytes32 YourSecretRandKey,
	     string Info)
  {
    uint SecretRand;

    SecretRand=3*( uint(sha3(WriteHereSomeUniqeRandomStuff))/3 ) + (RockPaperOrScissors-1)%3;
    //SecretRand%3 ==
    //0 - Rock
    //1 - Paper
    //2 - Scissors

    if(RockPaperOrScissors==0)
      return(0,0, ""enter 1 for Rock, 2 for Paper, 3 for Scissors"");

    return (sha3(bytes32(SecretRand)),bytes32(SecretRand),  bets[sha3(bytes32(SecretRand))].sender != 0 ? ""someone have already used this random string - try another one"" :
                                                            SecretRand%3==0 ? ""Rock"" :
	                                                        SecretRand%3==1 ? ""Paper"" :
	                                                        ""Scissors"");
  }

}",False,False,True
0x3398080b81a1cff1429af347ce2b17fc28de3937,111: unchecked;,True,False,False,"pragma solidity ^0.4.0;

//https://github.com/nexusdev/erc20/blob/master/contracts/erc20.sol

contract ERC20Constant {
    function totalSupply() constant returns (uint supply);
    function balanceOf( address who ) constant returns (uint value);
    function allowance(address owner, address spender) constant returns (uint _allowance);
}
contract ERC20Stateful {
    function transfer( address to, uint value) returns (bool ok);
    function transferFrom( address from, address to, uint value) returns (bool ok);
    function approve(address spender, uint value) returns (bool ok);
}
contract ERC20Events {
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval( address indexed owner, address indexed spender, uint value);
}
contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

// contract can buy or sell tokens for ETH
// prices are in amount of wei per batch of token units

contract TokenTrader is owned {

    address public asset;       // address of token
    uint256 public buyPrice;   // contact buys lots of token at this price
    uint256 public sellPrice;  // contract sells lots at this price
    uint256 public units;       // lot size (token-wei)

    bool public sellsTokens;    // is contract selling
    bool public buysTokens;     // is contract buying

    event ActivatedEvent(bool sells, bool buys);
    event UpdateEvent();

    function TokenTrader (
        address _asset, 
        uint256 _buyPrice, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens,
        bool    _buysTokens
        )
    {
          asset         = _asset; 
          buyPrice     = _buyPrice; 
          sellPrice    = _sellPrice;
          units         = _units; 
          sellsTokens   = _sellsTokens;
          buysTokens    = _buysTokens;

          ActivatedEvent(sellsTokens,buysTokens);
    }

    // modify trading behavior
    function activate (
        bool    _sellsTokens,
        bool    _buysTokens
        ) onlyOwner
    {
          sellsTokens   = _sellsTokens;
          buysTokens    = _buysTokens;

          ActivatedEvent(sellsTokens,buysTokens);
    }

    // allows owner to deposit ETH
    // deposit tokens by sending them directly to contract
    // buyers must not send tokens to the contract, use: sell(...)
    function deposit() payable onlyOwner {
        UpdateEvent();
    }

    // allow owner to remove trade token
    function withdrawAsset(uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(asset).transfer(owner,_value);
        UpdateEvent();
    }

    // allow owner to remove arbitrary tokens
    // included just in case contract receives wrong token
    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(_token).transfer(owner,_value);
        UpdateEvent();
    }

    // allow owner to remove ETH
    function withdraw(uint256 _value) onlyOwner returns (bool ok)
    {
        if(this.balance >= _value) {
            return owner.send(_value);
        }
        UpdateEvent();
    }

    //user buys token with ETH
    function buy() payable {
        if(sellsTokens || msg.sender == owner) 
        {
            uint order   = msg.value / sellPrice; 
            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;

            if(order > can_sell)
            {
                uint256 change = msg.value - (can_sell * sellPrice);
                order = can_sell;
                if(!msg.sender.send(change)) throw;
            }

            if(order > 0) {
                if(!ERC20(asset).transfer(msg.sender,order * units)) throw;
            }
            UpdateEvent();
        }
        else if(!msg.sender.send(msg.value)) throw;  // return user funds if the contract is not selling
    }

    // user sells token for ETH
    // user must set allowance for this contract before calling
    function sell(uint256 amount) {
        if (buysTokens || msg.sender == owner) {
            uint256 can_buy = this.balance / buyPrice;  // token lots contract can buy
            uint256 order = amount / units;             // token lots available

            if(order > can_buy) order = can_buy;        // adjust order for funds

            if (order > 0)
            { 
                // extract user tokens
                if(!ERC20(asset).transferFrom(msg.sender, address(this), amount)) throw;

                // pay user
                if(!msg.sender.send(order * buyPrice)) throw;
            }
            UpdateEvent();
        }
    }

    // sending ETH to contract sells ETH to user
    function () payable {
        buy();
    }
}

// This contract deploys TokenTrader contracts and logs the event
// trade pairs are identified with sha3(asset,units)

contract TokenTraderFactory {

    event TradeListing(bytes32 bookid, address owner, address addr);
    event NewBook(bytes32 bookid, address asset, uint256 units);

    mapping( address => bool ) _verify;
    mapping( bytes32 => bool ) pairExits;
    
    function verify(address tradeContract)  constant returns (
        bool valid,
        address asset, 
        uint256 buyPrice, 
        uint256 sellPrice, 
        uint256 units,
        bool    sellsTokens,
        bool    buysTokens       
        ) {
            
            valid = _verify[tradeContract];
            
            if(valid) {
                TokenTrader t = TokenTrader(tradeContract);
                
                asset = t.asset();
                buyPrice =t.buyPrice();
                sellPrice = t.sellPrice();
                units = t.units();
                sellsTokens = t.sellsTokens();
                buysTokens = t.buysTokens();
            }
        
    }

    function createTradeContract(       
        address _asset, 
        uint256 _buyPrice, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens,
        bool    _buysTokens
        ) returns (address) 
    {
        if(_buyPrice > _sellPrice) throw; // must make profit on spread
        if(_units == 0) throw;              // can't sell zero units

        address trader = new TokenTrader (
                     _asset, 
                     _buyPrice, 
                     _sellPrice, 
                     _units,
                     _sellsTokens,
                     _buysTokens);

        var bookid = sha3(_asset,_units);

        _verify[trader] = true; // record that this factory created the trader

        TokenTrader(trader).transferOwnership(msg.sender); // set the owner to whoever called the function

        if(pairExits[bookid] == false) {
            pairExits[bookid] = true;
            NewBook(bookid, _asset, _units);
        }

        TradeListing(bookid,msg.sender,trader);
    }

    function () {
        throw;     // Prevents accidental sending of ether to the factory
    }
}",False,False,False
0x559b52b6a30Ba913A7e8F85C4A6Aa443a0FE66ab,108: unchecked;,True,False,False,"pragma solidity ^0.4.0;

//https://github.com/nexusdev/erc20/blob/master/contracts/erc20.sol

contract ERC20Constant {
    function totalSupply() constant returns (uint supply);
    function balanceOf( address who ) constant returns (uint value);
    function allowance(address owner, address spender) constant returns (uint _allowance);
}
contract ERC20Stateful {
    function transfer( address to, uint value) returns (bool ok);
    function transferFrom( address from, address to, uint value) returns (bool ok);
    function approve(address spender, uint value) returns (bool ok);
}
contract ERC20Events {
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval( address indexed owner, address indexed spender, uint value);
}
contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

// contract can buy or sell tokens for ETH
// prices are in amount of wei per batch of token units

contract TokenTrader is owned {

    address public asset;       // address of token
    uint256 public buyPrice;   // contact buys lots of token at this price
    uint256 public sellPrice;  // contract sells lots at this price
    uint256 public units;       // lot size (token-wei)

    bool public sellsTokens;    // is contract selling
    bool public buysTokens;     // is contract buying

    event ActivatedEvent(bool sells, bool buys);
    event UpdateEvent();

    function TokenTrader (
        address _asset, 
        uint256 _buyPrice, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens,
        bool    _buysTokens
        )
    {
          asset         = _asset; 
          buyPrice     = _buyPrice; 
          sellPrice    = _sellPrice;
          units         = _units; 
          sellsTokens   = _sellsTokens;
          buysTokens    = _buysTokens;

          ActivatedEvent(sellsTokens,buysTokens);
    }

    // modify trading behavior
    function activate (
        bool    _sellsTokens,
        bool    _buysTokens
        )
    {
          sellsTokens   = _sellsTokens;
          buysTokens    = _buysTokens;

          ActivatedEvent(sellsTokens,buysTokens);
    }

    // allows owner to deposit ETH
    // deposit tokens by sending them directly to contract
    // buyers must not send tokens to the contract, use: sell(...)
    function deposit() payable onlyOwner {
    }

    // allow owner to remove trade token
    function withdrawAsset(uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(asset).transfer(owner,_value);
    }

    // allow owner to remove arbitrary tokens
    // included just in case contract receives wrong token
    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(_token).transfer(owner,_value);
    }

    // allow owner to remove ETH
    function withdraw(uint256 _value) onlyOwner returns (bool ok)
    {
        if(this.balance >= _value) {
            return owner.send(_value);
        }
    }

    //user buys token with ETH
    function buy() payable {
        if(sellsTokens || msg.sender == owner) 
        {
            uint order   = msg.value / sellPrice; 
            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;

            if(order > can_sell)
            {
                uint256 change = msg.value - (can_sell * sellPrice);
                order = can_sell;
                if(!msg.sender.send(change)) throw;
            }

            if(order > 0) {
                if(!ERC20(asset).transfer(msg.sender,order * units)) throw;
            }
            UpdateEvent();
        }
        else throw;  // return user funds if the contract is not selling
    }

    // user sells token for ETH
    // user must set allowance for this contract before calling
    function sell(uint256 amount) {
        if (buysTokens || msg.sender == owner) {
            uint256 can_buy = this.balance / buyPrice;  // token lots contract can buy
            uint256 order = amount / units;             // token lots available

            if(order > can_buy) order = can_buy;        // adjust order for funds

            if (order > 0)
            { 
                // extract user tokens
                if(!ERC20(asset).transferFrom(msg.sender, address(this), amount)) throw;

                // pay user
                if(!msg.sender.send(order * buyPrice)) throw;
            }
            UpdateEvent();
        }
    }

    // sending ETH to contract sells ETH to user
    function () payable {
        buy();
    }
}

// This contract deploys TokenTrader contracts and logs the event
// trade pairs are identified with sha3(asset,units)

contract TokenTraderFactory {

    event TradeListing(bytes32 bookid, address owner, address addr);
    event NewBook(bytes32 bookid, address asset, uint256 units);

    mapping( address => bool ) public verify;
    mapping( bytes32 => bool ) pairExits;

    function createTradeContract(       
        address _asset, 
        uint256 _buyPrice, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens,
        bool    _buysTokens
        ) returns (address) 
    {
        if(_buyPrice > _sellPrice) throw; // must make profit on spread
        if(_units == 0) throw;              // can't sell zero units

        address trader = new TokenTrader (
                     _asset, 
                     _buyPrice, 
                     _sellPrice, 
                     _units,
                     _sellsTokens,
                     _buysTokens);

        var bookid = sha3(_asset,_units);

        verify[trader] = true; // record that this factory created the trader

        TokenTrader(trader).transferOwnership(msg.sender); // set the owner to whoever called the function

        if(pairExits[bookid] == false) {
            pairExits[bookid] = true;
            NewBook(bookid, _asset, _units);
        }

        TradeListing(bookid,msg.sender,trader);
    }

    function () {
        throw;     // Prevents accidental sending of ether to the factory
    }
}",False,False,False
0x7698392fff47d8d4cee21295ad1f31b6ced9ad66,231: time manipulation;,True,False,False,"contract TheEthereumLottery {
 /*
    Brief introduction:
    
    To play you need to pick 4 numbers (range 0-255) and provide them sorted to Play() function.
    To win you need to hit at least 1 number out of 4 WinningNums which will be announced once every week
    (or more often if the lottery will become more popular). If you hit all of the 4 numbers you will win
    about 50 milion times more than you payed fot lottery ticket. The exact values are provided as GuessXOutOf4
    entries in Ledger - notice that they are provided in Wei, not Ether (10^18 Wei = Ether).
    Use Withdraw() function to pay out.


    The advantage of TheEthereumLottery is that it is not using any pseudo-random numbers.
    The winning numbers are known from the announcement of next draw - at this moment the values of GuessXOutOf4,
    and ticket price is publically available. 
    To unable cheating of contract owner there a hash (called ""TheHash"" in contract ledger) 
    equal to sha3(WinningNums, TheRand) is provided.
    While announcing WinningNums the owner has to provide also a valid ""TheRand"" value, which satisfy 
    following expression: TheHash == sha3(WinningNums, TheRand). 
    If hashes do not match - the player can refund his Ether used for lottery ticket.
    As by default all non existing values equal to 0, from the perspective of blockchain 
    the hashes do not match at the moment of announcing next draw from the perspective of blockchain. 
    This is why refund is possible only after 2 weeks of announcing next draw,
    this moment is called ExpirencyTime on contract Ledger.
 */
/*
  Name:
  TheEthereumLottery

  Contract Address:
  0x7698392fff47d8d4cee21295ad1f31b6ced9ad66

  JSON interface:

[{""constant"":false,""inputs"":[{""name"":""MyNum1"",""type"":""uint8""},{""name"":""MyNum2"",""type"":""uint8""},{""name"":""MyNum3"",""type"":""uint8""},{""name"":""MyNum4"",""type"":""uint8""}],""name"":""Play"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""DrawNumber"",""type"":""uint32""}],""name"":""Withdraw"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""Announcements"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""DrawNumber"",""type"":""uint32""}],""name"":""Refund"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""IndexOfCurrentDraw"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""ledger"",""outputs"":[{""name"":""WinningNum1"",""type"":""uint8""},{""name"":""WinningNum2"",""type"":""uint8""},{""name"":""WinningNum3"",""type"":""uint8""},{""name"":""WinningNum4"",""type"":""uint8""},{""name"":""TheRand"",""type"":""bytes32""},{""name"":""TheHash"",""type"":""bytes32""},{""name"":""Guess4OutOf4"",""type"":""uint256""},{""name"":""Guess3OutOf4"",""type"":""uint256""},{""name"":""Guess2OutOf4"",""type"":""uint256""},{""name"":""Guess1OutOf4"",""type"":""uint256""},{""name"":""PriceOfTicket"",""type"":""uint256""},{""name"":""ExpirencyTime"",""type"":""uint256""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":""DrawNumber"",""type"":""uint8""},{""name"":""PlayerAddress"",""type"":""address""}],""name"":""MyBet"",""outputs"":[{""name"":""Nums"",""type"":""uint8[4]""}],""type"":""function""},{""inputs"":[],""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":true,""name"":""IndexOfDraw"",""type"":""uint256""},{""indexed"":false,""name"":""TheHash"",""type"":""bytes32""},{""indexed"":false,""name"":""PriceOfTicketInWei"",""type"":""uint256""},{""indexed"":false,""name"":""WeiToWin"",""type"":""uint256""}],""name"":""NewDrawReadyToPlay"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""name"":""IndexOfDraw"",""type"":""uint32""},{""indexed"":false,""name"":""WinningNumber1"",""type"":""uint8""},{""indexed"":false,""name"":""WinningNumber2"",""type"":""uint8""},{""indexed"":false,""name"":""WinningNumber3"",""type"":""uint8""},{""indexed"":false,""name"":""WinningNumber4"",""type"":""uint8""},{""indexed"":false,""name"":""TheRand"",""type"":""bytes32""}],""name"":""DrawReadyToPayout"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""Wei"",""type"":""uint256""}],""name"":""PlayerWon"",""type"":""event""},{""constant"":true,""inputs"":[{""name"":""Num1"",""type"":""uint8""},{""name"":""Num2"",""type"":""uint8""},{""name"":""Num3"",""type"":""uint8""},{""name"":""Num4"",""type"":""uint8""},{""name"":""TheRandomValue"",""type"":""bytes32""}],""name"":""CheckHash"",""outputs"":[{""name"":""TheHash"",""type"":""bytes32""}],""type"":""function""}]
*/


  
//constructor
function TheEthereumLottery()
{
  owner=msg.sender;
  ledger.length=0;
}
modifier OnlyOwner()
{ // Modifier
  if (msg.sender != owner) throw;
  _
}
address owner;
string public Announcements;//just additional feature
uint public IndexOfCurrentDraw;//starting from 0
struct bet_t {
  uint8[4] Nums;
  bool can_withdraw;//default==false
}
struct ledger_t {
  uint8 WinningNum1;
  uint8 WinningNum2;
  uint8 WinningNum3;
  uint8 WinningNum4;
  bytes32 TheRand;
  bytes32 TheHash;
  mapping(address=>bet_t) bets;
  uint Guess4OutOf4;
  uint Guess3OutOf4;
  uint Guess2OutOf4;
  uint Guess1OutOf4;
  uint PriceOfTicket;
  uint ExpirencyTime;//for eventual refunds only, approx 2 weeks after draw announced
}
ledger_t[] public ledger;
 
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@ Here begines what probably you want to analise @@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function next_draw(bytes32 new_hash,
	  uint priceofticket,
	  uint guess4outof4,
	  uint guess3outof4,
	  uint guess2outof4,
	  uint guess1outof4
	  )
OnlyOwner
{
  ledger.length++;
  IndexOfCurrentDraw=ledger.length-1;
  ledger[IndexOfCurrentDraw].TheHash = new_hash;
  ledger[IndexOfCurrentDraw].Guess4OutOf4=guess4outof4;
  ledger[IndexOfCurrentDraw].Guess3OutOf4=guess3outof4;
  ledger[IndexOfCurrentDraw].Guess2OutOf4=guess2outof4;
  ledger[IndexOfCurrentDraw].Guess1OutOf4=guess1outof4;
  ledger[IndexOfCurrentDraw].PriceOfTicket=priceofticket;
  ledger[IndexOfCurrentDraw].ExpirencyTime=now + 2 weeks;//You can refund after ExpirencyTime if owner will not announce winningnums+TheRand satisfying TheHash 

  NewDrawReadyToPlay(IndexOfCurrentDraw, new_hash, priceofticket, guess4outof4);//event
}
function announce_numbers(uint8 no1,
			  uint8 no2,
			  uint8 no3,
			  uint8 no4,
			  uint32 index,
			  bytes32 the_rand
			  )
OnlyOwner
{
  ledger[index].WinningNum1 = no1;
  ledger[index].WinningNum2 = no2;
  ledger[index].WinningNum3 = no3;
  ledger[index].WinningNum4 = no4;
  ledger[index].TheRand = the_rand;

  DrawReadyToPayout(index,
		    no1, no2, no3, no4,
		    the_rand);//event
}
function Play(uint8 MyNum1,
	      uint8 MyNum2,
	      uint8 MyNum3,
	      uint8 MyNum4
	      )
{
  if(msg.value != ledger[IndexOfCurrentDraw].PriceOfTicket ||//to play you need to pay 
     ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[3] != 0)//if your bet already exist
    throw;

  //if numbers are sorted
  if(MyNum1 >= MyNum2 ||
     MyNum2 >= MyNum3 ||
     MyNum3 >= MyNum4
     )
    throw;//because you should sort the values yourself

  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[0]=MyNum1;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[1]=MyNum2;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[2]=MyNum3;
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums[3]=MyNum4;
  ledger[IndexOfCurrentDraw].bets[msg.sender].can_withdraw=true;


  //##########################################################################3
  //another approach - with non-sorted input 
  /*
  if(msg.value != ledger[IndexOfCurrentDraw].PriceOfTicket)
    throw;

  uint8[4] memory InputData;
  (InputData[0],InputData[1],InputData[2],InputData[3])
    =(MyNum1,MyNum2,MyNum3,MyNum4);
  for(uint8 n=4;n>1;n--)//check if input is sorted / bubble sort
    {
      bool sorted=true; 
      for(uint8 i=0;i<n-1;i++)
	if(InputData[i] > InputData[i+1])//then mark array as not sorted & swap
	  {
	    sorted=false;
	    (InputData[i], InputData[i+1])=(InputData[i+1], InputData[i]);
	  }
      if(sorted) break;//breaks as soon as the array is sorted
    }
  //now we can assign
  ledger[IndexOfCurrentDraw].bets[msg.sender].Nums=InputData;
  ledger[IndexOfCurrentDraw].bets[msg.sender].can_withdraw=true;
  */

  
}
	
function Withdraw(uint32 DrawNumber)
{
  if(msg.value!=0)
    throw;//this function is free

  if(ledger[DrawNumber].bets[msg.sender].can_withdraw==false)
    throw;//throw if player didnt played

  //by default, every non existing value is equal to 0
  //so if there was no announcement WinningNums are zeros
  if(ledger[DrawNumber].WinningNum4==0)//the least possible value == 3
    throw;//this condition checks if the numbers were announced
  //it's more gas-efficient than checking sha3(No1,No2,No3,No4,TheRand)
  //and even if the hashes does not match then player benefits because of chance of win AND beeing able to Refund

  
  uint8 hits=0;
  uint8 i=0;
  uint8 j=0;
  uint8[4] memory playernum=ledger[DrawNumber].bets[msg.sender].Nums;
  uint8[4] memory nums;
  (nums[0],nums[1],nums[2],nums[3])=
    (ledger[DrawNumber].WinningNum1,
     ledger[DrawNumber].WinningNum2,
     ledger[DrawNumber].WinningNum3,
     ledger[DrawNumber].WinningNum4);
  //data ready
  
  while(i<4)//count player hits
    {//both arrays are sorted
      while(j<4 && playernum[j] < nums[i]) ++j;
      if(j==4) break;//nothing more to check - break loop here
      if(playernum[j] == nums[i]) ++hits;
      ++i;
    }
  if(hits==0) throw;
  uint256 win=0;
  if(hits==1) win=ledger[DrawNumber].Guess1OutOf4;
  if(hits==2) win=ledger[DrawNumber].Guess2OutOf4;
  if(hits==3) win=ledger[DrawNumber].Guess3OutOf4;
  if(hits==4) win=ledger[DrawNumber].Guess4OutOf4;
    
  ledger[DrawNumber].bets[msg.sender].can_withdraw=false;
  if(!msg.sender.send(win)) //payment
    throw;
  PlayerWon(win);//event
  if(!owner.send(win/100))
    throw;//the fee is less than 1% (fee=1/101)
}
function Refund(uint32 DrawNumber)
{
  if(msg.value!=0)
    throw;//this function is free

  if(
     sha3( ledger[DrawNumber].WinningNum1,
	   ledger[DrawNumber].WinningNum2,
	   ledger[DrawNumber].WinningNum3,
	   ledger[DrawNumber].WinningNum4,
	   ledger[DrawNumber].TheRand)
     ==
     ledger[DrawNumber].TheHash ) throw;
  //no refund if hashes match

  if(now < ledger[DrawNumber].ExpirencyTime)
    throw;//no refund while there is still TIME to announce nums & TheRand
  
 
  if(ledger[DrawNumber].bets[msg.sender].can_withdraw==false)
    throw;//throw if player didnt played
  
  ledger[DrawNumber].bets[msg.sender].can_withdraw=false;
  if(!msg.sender.send(ledger[DrawNumber].PriceOfTicket)) //refund
    throw;
}
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@ Here ends what probably you wanted to analise @@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

function CheckHash(uint8 Num1,
		   uint8 Num2,
		   uint8 Num3,
		   uint8 Num4,
		   bytes32 TheRandomValue
		   )
  constant returns(bytes32 TheHash)
{
  return sha3(Num1, Num2, Num3, Num4, TheRandomValue);
}
function MyBet(uint8 DrawNumber, address PlayerAddress)
  constant returns (uint8[4] Nums)
{//check your nums
  return ledger[DrawNumber].bets[PlayerAddress].Nums;
}
function announce(string MSG)
  OnlyOwner
{
  Announcements=MSG;
}
event NewDrawReadyToPlay(uint indexed IndexOfDraw,
			 bytes32 TheHash,
			 uint PriceOfTicketInWei,
			 uint WeiToWin);
event DrawReadyToPayout(uint32 indexed IndexOfDraw,
			uint8 WinningNumber1,
			uint8 WinningNumber2,
			uint8 WinningNumber3,
			uint8 WinningNumber4,
			bytes32 TheRand);
event PlayerWon(uint Wei);


			      

}//contract",False,True,True
0x9bfe61748ba9b71789de234d2bdc8fa21047d3cb,112: arithmetic; 89: time manipulation;,True,False,False,"pragma solidity ^0.4.2;
//This project is beta stage and might contain unknown bugs.
//I am not responsible for any consequences of any use of the code or protocol that is suggested here.
contract SimpleMixer {
    
    struct Deal{
        mapping(address=>uint) deposit;
        uint                   depositSum;
        mapping(address=>bool) claims;
	    uint 		           numClaims;
        uint                   claimSum;

        uint                   startTime;
        uint                   depositDurationInSec;
        uint                   claimDurationInSec;
        uint                   claimDepositInWei;
        uint                   claimValueInWei;
     	uint                   minNumClaims;
        
        bool                   active;
        bool                   fullyFunded;
    }
    
    Deal[]  _deals;
     
    event NewDeal( address indexed user, uint indexed _dealId, uint _startTime, uint _depositDurationInHours, uint _claimDurationInHours, uint _claimUnitValueInWei, uint _claimDepositInWei, uint _minNumClaims, bool _success, string _err );
    event Claim( address indexed _claimer, uint indexed _dealId, bool _success, string _err );
    event Deposit( address indexed _depositor, uint indexed _dealId, uint _value, bool _success, string _err );
    event Withdraw( address indexed _withdrawer, uint indexed _dealId, uint _value, bool _public, bool _success, string _err );

    event EnoughClaims( uint indexed _dealId );
    event DealFullyFunded( uint indexed _dealId );
    
    enum ReturnValue { Ok, Error }

    function SimpleMixer(){
    }
    
    function newDeal( uint _depositDurationInHours, uint _claimDurationInHours, uint _claimUnitValueInWei, uint _claimDepositInWei, uint _minNumClaims ) returns(ReturnValue){
        uint dealId = _deals.length;        
        if( _depositDurationInHours == 0 || _claimDurationInHours == 0 ){
        	NewDeal( msg.sender,
        	         dealId,
        	         now,
        	         _depositDurationInHours,
        	         _claimDurationInHours,
        	         _claimUnitValueInWei,
        	         _claimDepositInWei,
        	         _minNumClaims,
        	         false,
        	         ""_depositDurationInHours and _claimDurationInHours must be positive"" );
            return ReturnValue.Error;
        }
        _deals.length++;
        _deals[dealId].depositSum = 0;
	    _deals[dealId].numClaims = 0;
        _deals[dealId].claimSum = 0;
        _deals[dealId].startTime = now;
        _deals[dealId].depositDurationInSec = _depositDurationInHours * 1 hours;
        _deals[dealId].claimDurationInSec = _claimDurationInHours * 1 hours;
        _deals[dealId].claimDepositInWei = _claimDepositInWei;
        _deals[dealId].claimValueInWei = _claimUnitValueInWei;
	    _deals[dealId].minNumClaims = _minNumClaims;
        _deals[dealId].fullyFunded = false;
        _deals[dealId].active = true;
    	NewDeal( msg.sender,
    	         dealId,
    	         now,
    	         _depositDurationInHours,
    	         _claimDurationInHours,
    	         _claimUnitValueInWei,
    	         _claimDepositInWei,
    	         _minNumClaims,
    	         true,
    	         ""all good"" );
        return ReturnValue.Ok;
    }
    
    function makeClaim( uint dealId ) payable returns(ReturnValue){
        Deal deal = _deals[dealId];        
        bool errorDetected = false;
        string memory error;
    	// validations
    	if( !_deals[dealId].active ){
    	    error = ""deal is not active"";
    	    //ErrorLog( msg.sender, dealId, ""makeClaim: deal is not active"");
    	    errorDetected = true;
    	}
        if( deal.startTime + deal.claimDurationInSec < now ){
            error = ""claim phase already ended"";            
            //ErrorLog( msg.sender, dealId, ""makeClaim: claim phase already ended"" );
            errorDetected = true;
        }
        if( msg.value != deal.claimDepositInWei ){
            error = ""msg.value must be equal to claim deposit unit"";            
            //ErrorLog( msg.sender, dealId, ""makeClaim: msg.value must be equal to claim deposit unit"" );
            errorDetected = true;
        }
    	if( deal.claims[msg.sender] ){
    	    error = ""cannot claim twice with the same address"";
            //ErrorLog( msg.sender, dealId, ""makeClaim: cannot claim twice with the same address"" );
            errorDetected = true;
    	}
    	
    	if( errorDetected ){
    	    Claim( msg.sender, dealId, false, error );
    	    if( ! msg.sender.send(msg.value) ) throw; // send money back
    	    return ReturnValue.Error;
    	}

	    // actual claim
        deal.claimSum += deal.claimValueInWei;
        deal.claims[msg.sender] = true;
	    deal.numClaims++;

	    Claim( msg.sender, dealId, true, ""all good"" );
	    
	    if( deal.numClaims == deal.minNumClaims ) EnoughClaims( dealId );
	    
    	return ReturnValue.Ok;
    }

    function makeDeposit( uint dealId ) payable returns(ReturnValue){
        bool errorDetected = false;
        string memory error;
    	// validations
        if( msg.value == 0 ){
            error = ""deposit value must be positive"";
            //ErrorLog( msg.sender, dealId, ""makeDeposit: deposit value must be positive"");
            errorDetected = true;
        }
    	if( !_deals[dealId].active ){
    	    error = ""deal is not active"";
    	    //ErrorLog( msg.sender, dealId, ""makeDeposit: deal is not active"");
    	    errorDetected = true;
    	}
        Deal deal = _deals[dealId];
        if( deal.startTime + deal.claimDurationInSec > now ){
            error = ""contract is still in claim phase"";
    	    //ErrorLog( msg.sender, dealId, ""makeDeposit: contract is still in claim phase"");
    	    errorDetected = true;
        }
        if( deal.startTime + deal.claimDurationInSec + deal.depositDurationInSec < now ){
            error = ""deposit phase is over"";
    	    //ErrorLog( msg.sender, dealId, ""makeDeposit: deposit phase is over"");
    	    errorDetected = true;
        }
        if( ( msg.value % deal.claimValueInWei ) > 0 ){
            error = ""deposit value must be a multiple of claim value"";
    	    //ErrorLog( msg.sender, dealId, ""makeDeposit: deposit value must be a multiple of claim value"");
    	    errorDetected = true;
        }
    	if( deal.deposit[msg.sender] > 0 ){
    	    error = ""cannot deposit twice with the same address"";
    	    //ErrorLog( msg.sender, dealId, ""makeDeposit: cannot deposit twice with the same address"");
    	    errorDetected = true;
    	}
    	if( deal.numClaims < deal.minNumClaims ){
    	    error = ""deal is off as there are not enough claims. Call withdraw with you claimer address"";
    	    /*ErrorLog( msg.sender,
    	              dealId,
    	              ""makeDeposit: deal is off as there are not enough claims. Call withdraw with you claimer address"");*/
    	    errorDetected = true;
    	}
    	
    	if( errorDetected ){
    	    Deposit( msg.sender, dealId, msg.value, false, error );
    	    if( ! msg.sender.send(msg.value) ) throw; // send money back
    	    return ReturnValue.Error;
    	}
        
	    // actual deposit
        deal.depositSum += msg.value;
        deal.deposit[msg.sender] = msg.value;

    	if( deal.depositSum >= deal.claimSum ){
    	    deal.fullyFunded = true;
    	    DealFullyFunded( dealId );
    	}
    
    	Deposit( msg.sender, dealId, msg.value, true, ""all good"" );
	    return ReturnValue.Ok;    	
    }
        
    function withdraw( uint dealId ) returns(ReturnValue){
    	// validation
        bool errorDetected = false;
        string memory error;
        Deal deal = _deals[dealId];
    	bool enoughClaims = deal.numClaims >= deal.minNumClaims;
    	if( ! enoughClaims ){
    	    if( deal.startTime + deal.claimDurationInSec > now ){
    	        error = ""claim phase not over yet"";
    	        //ErrorLog( msg.sender, dealId, ""withdraw: claim phase not over yet"");
    	        errorDetected = true;
    	    }
    	}
    	else{
    	    if( deal.startTime + deal.depositDurationInSec + deal.claimDurationInSec > now ){
    	        error = ""deposit phase not over yet"";
    	        //ErrorLog( msg.sender, dealId, ""withdraw: deposit phase not over yet"");
    	        errorDetected = true;
    	    }
    	}
    	
    	if( errorDetected ){
    	    Withdraw( msg.sender, dealId, 0, false, false, error );
        	return ReturnValue.Error; // note that function is not payable    	    
    	}


	    // actual withdraw
	    bool publicWithdraw;
    	uint withdrawedValue = 0;
        if( (! deal.fullyFunded) && enoughClaims ){
	        publicWithdraw = true;
            uint depositValue = deal.deposit[msg.sender];
            if( depositValue == 0 ){
                Withdraw( msg.sender, dealId, 0, publicWithdraw, false, ""address made no deposit. Note that this should be called with the public address"" );
    	        //ErrorLog( msg.sender, dealId, ""withdraw: address made no deposit. Note that this should be called with the public address"");
    	        return ReturnValue.Error; // function non payable
            }
            
            uint effectiveNumDeposits = deal.depositSum / deal.claimValueInWei;
            uint userEffectiveNumDeposits = depositValue / deal.claimValueInWei;
            uint extraBalance = ( deal.numClaims - effectiveNumDeposits ) * deal.claimDepositInWei;
            uint userExtraBalance = userEffectiveNumDeposits * extraBalance / effectiveNumDeposits;

            deal.deposit[msg.sender] = 0; // invalidate user
            // give only half of extra balance. otherwise dishonest party could obtain 99% of the extra balance and lose almost nothing
	        withdrawedValue = depositValue + deal.claimDepositInWei * userEffectiveNumDeposits + ( userExtraBalance / 2 );
            if( ! msg.sender.send(withdrawedValue) ) throw;
        }
        else{
    	    publicWithdraw = false;
            if( ! deal.claims[msg.sender] ){
                Withdraw( msg.sender, dealId, 0, publicWithdraw, false, ""address made no claims. Note that this should be called with the secret address"" );
    	        //ErrorLog( msg.sender, dealId, ""withdraw: address made no claims. Note that this should be called with the secret address"");
    	        return ReturnValue.Error; // function non payable
            }
	        if( enoughClaims ) withdrawedValue = deal.claimDepositInWei + deal.claimValueInWei;
	        else withdrawedValue = deal.claimDepositInWei;
		
            deal.claims[msg.sender] = false; // invalidate claim
            if( ! msg.sender.send(withdrawedValue) ) throw;
        }
	    
        Withdraw( msg.sender, dealId, withdrawedValue, publicWithdraw, true, ""all good"" );
        return ReturnValue.Ok;
    }    

    ////////////////////////////////////////////////////////////////////////////////////////
    
    function dealStatus(uint _dealId) constant returns(uint[4]){
        // returns (active, num claims, claim sum, deposit sum) all as integers
        uint active = _deals[_dealId].active ? 1 : 0;
        uint numClaims = _deals[_dealId].numClaims;
        uint claimSum = _deals[_dealId].claimSum;
	    uint depositSum = _deals[_dealId].depositSum;
        
        return [active, numClaims, claimSum, depositSum];
    }

}",False,True,True
0xd6ec04c0f9587cb822c315f662954af8c2174d66,FP,True,False,True,"pragma solidity ^0.4.2;

contract Store {
    address[] owners;
    mapping(address => uint) ownerBalances;

    function Store(address[] _owners) {
        owners = _owners;
    }
    
    function deposit() payable {
        uint ownerShare = msg.value / owners.length;
        ownerBalances[owners[0]] += msg.value % owners.length;
        
        for (uint i = 0; i < owners.length; i++) {
            ownerBalances[owners[i]] += ownerShare;
        }
    }
    
    function payout() returns (uint) {
        uint amount = ownerBalances[msg.sender];
        ownerBalances[msg.sender] = 0;

        if (msg.sender.send(amount)) {
            return amount;
        } else {
            ownerBalances[msg.sender] = amount;
            return 0;
        }
    }

    
    
    
}",False,False,False
0xe3282094d332d26f7Dfca853899eC1736f0295ce,111: unchecked; 125: arithmetic;,True,False,False,"pragma solidity ^0.4.0;

//https://github.com/nexusdev/erc20/blob/master/contracts/erc20.sol

contract ERC20Constant {
    function totalSupply() constant returns (uint supply);
    function balanceOf( address who ) constant returns (uint value);
    function allowance(address owner, address spender) constant returns (uint _allowance);
}
contract ERC20Stateful {
    function transfer( address to, uint value) returns (bool ok);
    function transferFrom( address from, address to, uint value) returns (bool ok);
    function approve(address spender, uint value) returns (bool ok);
}
contract ERC20Events {
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval( address indexed owner, address indexed spender, uint value);
}
contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

// contract can buy or sell tokens for ETH
// prices are in amount of wei per batch of token units

contract TokenTrader is owned {

    address public asset;       // address of token
    uint256 public buyPrice;   // contact buys lots of token at this price
    uint256 public sellPrice;  // contract sells lots at this price
    uint256 public units;       // lot size (token-wei)

    bool public sellsTokens;    // is contract selling
    bool public buysTokens;     // is contract buying

    event ActivatedEvent(bool sells, bool buys);
    event UpdateEvent();

    function TokenTrader (
        address _asset, 
        uint256 _buyPrice, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens,
        bool    _buysTokens
        )
    {
          asset         = _asset; 
          buyPrice     = _buyPrice; 
          sellPrice    = _sellPrice;
          units         = _units; 
          sellsTokens   = _sellsTokens;
          buysTokens    = _buysTokens;

          ActivatedEvent(sellsTokens,buysTokens);
    }

    // modify trading behavior
    function activate (
        bool    _sellsTokens,
        bool    _buysTokens
        ) onlyOwner
    {
          sellsTokens   = _sellsTokens;
          buysTokens    = _buysTokens;

          ActivatedEvent(sellsTokens,buysTokens);
    }

    // allows owner to deposit ETH
    // deposit tokens by sending them directly to contract
    // buyers must not send tokens to the contract, use: sell(...)
    function deposit() payable onlyOwner {
        UpdateEvent();
    }

    // allow owner to remove trade token
    function withdrawAsset(uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(asset).transfer(owner,_value);
        UpdateEvent();
    }

    // allow owner to remove arbitrary tokens
    // included just in case contract receives wrong token
    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(_token).transfer(owner,_value);
        UpdateEvent();
    }

    // allow owner to remove ETH
    function withdraw(uint256 _value) onlyOwner returns (bool ok)
    {
        if(this.balance >= _value) {
            return owner.send(_value);
        }
        UpdateEvent();
    }

    //user buys token with ETH
    function buy() payable {
        if(sellsTokens || msg.sender == owner) 
        {
            uint order   = msg.value / sellPrice; 
            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;

            if(order > can_sell)
            {
                uint256 change = msg.value - (can_sell * sellPrice);
                order = can_sell;
                if(!msg.sender.send(change)) throw;
            }

            if(order > 0) {
                if(!ERC20(asset).transfer(msg.sender,order * units)) throw;
            }
            UpdateEvent();
        }
        else throw;  // return user funds if the contract is not selling
    }

    // user sells token for ETH
    // user must set allowance for this contract before calling
    function sell(uint256 amount) {
        if (buysTokens || msg.sender == owner) {
            uint256 can_buy = this.balance / buyPrice;  // token lots contract can buy
            uint256 order = amount / units;             // token lots available

            if(order > can_buy) order = can_buy;        // adjust order for funds

            if (order > 0)
            { 
                // extract user tokens
                if(!ERC20(asset).transferFrom(msg.sender, address(this), amount)) throw;

                // pay user
                if(!msg.sender.send(order * buyPrice)) throw;
            }
            UpdateEvent();
        }
    }

    // sending ETH to contract sells ETH to user
    function () payable {
        buy();
    }
}

// This contract deploys TokenTrader contracts and logs the event
// trade pairs are identified with sha3(asset,units)

contract TokenTraderFactory {

    event TradeListing(bytes32 bookid, address owner, address addr);
    event NewBook(bytes32 bookid, address asset, uint256 units);

    mapping( address => bool ) public verify;
    mapping( bytes32 => bool ) pairExits;

    function createTradeContract(       
        address _asset, 
        uint256 _buyPrice, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens,
        bool    _buysTokens
        ) returns (address) 
    {
        if(_buyPrice > _sellPrice) throw; // must make profit on spread
        if(_units == 0) throw;              // can't sell zero units

        address trader = new TokenTrader (
                     _asset, 
                     _buyPrice, 
                     _sellPrice, 
                     _units,
                     _sellsTokens,
                     _buysTokens);

        var bookid = sha3(_asset,_units);

        verify[trader] = true; // record that this factory created the trader

        TokenTrader(trader).transferOwnership(msg.sender); // set the owner to whoever called the function

        if(pairExits[bookid] == false) {
            pairExits[bookid] = true;
            NewBook(bookid, _asset, _units);
        }

        TradeListing(bookid,msg.sender,trader);
    }

    function () {
        throw;     // Prevents accidental sending of ether to the factory
    }
}",False,True,False
0xe736091fc36f1ad476f5e4e03e4425940822d3ba,91: arithmetic;,True,False,False,"/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20

/// @title Abstract token contract - Functions to be implemented by token contracts.
/// @author Stefan George - <stefan.george@consensys.net>
contract Token {
    // This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions
    function totalSupply() constant returns (uint256 supply) {}
    function balanceOf(address owner) constant returns (uint256 balance);
    function transfer(address to, uint256 value) returns (bool success);
    function transferFrom(address from, address to, uint256 value) returns (bool success);
    function approve(address spender, uint256 value) returns (bool success);
    function allowance(address owner, address spender) constant returns (uint256 remaining);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



contract SingularDTVToken is Token {
    function issueTokens(address _for, uint tokenCount) returns (bool);
}
contract SingularDTVCrowdfunding {
    function twoYearsPassed() returns (bool);
    function startDate() returns (uint);
    function CROWDFUNDING_PERIOD() returns (uint);
    function TOKEN_TARGET() returns (uint);
    function valuePerShare() returns (uint);
    function fundBalance() returns (uint);
    function campaignEndedSuccessfully() returns (bool);
}


/// @title Fund contract - Implements revenue distribution.
/// @author Stefan George - <stefan.george@consensys.net>
contract SingularDTVFund {

    /*
     *  External contracts
     */
    SingularDTVToken public singularDTVToken;
    SingularDTVCrowdfunding public singularDTVCrowdfunding;

    /*
     *  Storage
     */
    address public owner;
    address constant public workshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;
    uint public totalRevenue;

    // User's address => Revenue at time of withdraw
    mapping (address => uint) public revenueAtTimeOfWithdraw;

    // User's address => Revenue which can be withdrawn
    mapping (address => uint) public owed;

    /*
     *  Modifiers
     */
    modifier noEther() {
        if (msg.value > 0) {
            throw;
        }
        _
    }

    modifier onlyOwner() {
        // Only guard is allowed to do this action.
        if (msg.sender != owner) {
            throw;
        }
        _
    }

    modifier campaignEndedSuccessfully() {
        if (!singularDTVCrowdfunding.campaignEndedSuccessfully()) {
            throw;
        }
        _
    }

    /*
     *  Contract functions
     */
    /// @dev Deposits revenue. Returns success.
    function depositRevenue()
        external
        campaignEndedSuccessfully
        returns (bool)
    {
        totalRevenue += msg.value;
        return true;
    }

    /// @dev Withdraws revenue for user. Returns revenue.
    /// @param forAddress user's address.
    function calcRevenue(address forAddress) internal returns (uint) {
        return singularDTVToken.balanceOf(forAddress) * (totalRevenue - revenueAtTimeOfWithdraw[forAddress]) / singularDTVToken.totalSupply();
    }

    /// @dev Withdraws revenue for user. Returns revenue.
    function withdrawRevenue()
        external
        noEther
        returns (uint)
    {
        uint value = calcRevenue(msg.sender) + owed[msg.sender];
        revenueAtTimeOfWithdraw[msg.sender] = totalRevenue;
        owed[msg.sender] = 0;
        if (value > 0 && !msg.sender.send(value)) {
            throw;
        }
        return value;
    }

    /// @dev Credits revenue to owed balance.
    /// @param forAddress user's address.
    function softWithdrawRevenueFor(address forAddress)
        external
        noEther
        returns (uint)
    {
        uint value = calcRevenue(forAddress);
        revenueAtTimeOfWithdraw[forAddress] = totalRevenue;
        owed[forAddress] += value;
        return value;
    }

    /// @dev Setup function sets external contracts' addresses.
    /// @param singularDTVTokenAddress Token address.
    function setup(address singularDTVCrowdfundingAddress, address singularDTVTokenAddress)
        external
        noEther
        onlyOwner
        returns (bool)
    {
        if (address(singularDTVCrowdfunding) == 0 && address(singularDTVToken) == 0) {
            singularDTVCrowdfunding = SingularDTVCrowdfunding(singularDTVCrowdfundingAddress);
            singularDTVToken = SingularDTVToken(singularDTVTokenAddress);
            return true;
        }
        return false;
    }

    /// @dev Contract constructor function sets guard address.
    function SingularDTVFund() noEther {
        // Set owner address
        owner = msg.sender;
    }
}",False,True,False
0x493f121b6f769fc8dbfb47ab834b13561d835009,151: time manipulation;,True,False,False,"pragma solidity ^0.4.0;

/**
 * Author: Nick Johnson <arachnid at notdot.net>
 * 
 * WARNING: This contract is new and thus-far only lightly tested. I'm fairly
 * confident it operates as described, but you may want to assure yourself of
 * its correctness - or wait for others to do so for you - before you trust your
 * ether to it. No guarantees, express or implied, are provided - use at your
 * own risk.
 * 
 * @dev Ether vault contract. Stores ether with a 'time lock' on withdrawals,
 *      giving a user the chance to reclaim funds if an account is compromised.
 *      A recovery address has the ability to immediately destroy the wallet and
 *      send its funds to a new contract (such as a new vault, if the wallet)
 *      associated with this one is compromised or lost). A cold wallet or
 *      secure brain wallet should typically be used for this purpose.
 * 
 * Setup:
 *   To set up a vault, first create a cold wallet or secure brain wallet to use
 *   as a recovery key, and get its address. Then, deploy this vault contract
 *   with the address of the recovery key, and a time delay (in seconds) to
 *   impose on withdrawals.
 * 
 * Deposits:
 *   Simply deposit funds into this contract by sending them to them. This
 *   contract only uses the minimum gas stipend, so it's safe to use with
 *   sites that ""don't support smart contracts"".
 * 
 * Withdrawals:
 *   Call unvault() with the amount you wish to withdraw (in wei - one ether is
 *   1e18 wei). After the time delay you specified when you created the wallet,
 *   you can call withdraw() to receive the funds.
 * 
 * Vacations:
 *   If you anticipate not having access to the recovery key for some period,
 *   you can call `lock()` with a period (in seconds) that the funds should be
 *   unavailable for; this will prohibit any withdrawals completing during that
 *   period. If a withdrawal is outstanding, it will be postponed until the
 *   end of this period, too.
 * 
 * Recovery:
 *   If your hotwallet is every compromised, or you detect an unauthorized
 *   `Unvault()` event, use your recovery key to call the `recover()` function
 *   with the address you want funds sent to. The funds will be immediately
 *   sent to this address (with no delay) and the contract will self destruct.
 * 
 *   For safety, you may wish to prepare a new vault (with a new recovery key)
 *   and send your funds directly to that.
 */
contract Vault {
    /**
     * @dev Owner of the vault.
     */
    address public owner;
    
    /**
     * @dev Recovery address for this vault.
     */
    address public recovery;

    /**
     * @dev Minimum interval between making an unvault call and allowing a
     *      withdrawal.
     */
    uint public withdrawDelay;

    /**
     * @dev Earliest time at which a withdrawal can be made.
     *      Valid iff withdrawAmount > 0.
     */
    uint public withdrawTime;
    
    /**
     * @dev Amount requested to be withdrawn.
     */
    uint public withdrawAmount;

    
    modifier only_owner() {
        if(msg.sender != owner) throw;
        _;
    }
    
    modifier only_recovery() {
        if(msg.sender != recovery) throw;
        _;
    }

    /**
     * @dev Withdrawal request made
     */
    event Unvault(uint amount, uint when);
    
    /**
     * @dev Recovery key used to send all funds to `address`.
     */
    event Recover(address target, uint value);
    
    /**
     * @dev Funds deposited.
     */
    event Deposit(address from, uint value);
    
    /**
     * @dev Funds withdrawn.
     */
    event Withdraw(address to, uint value);

    /**
     * @dev Constructor.
     * @param _recovery The address of the recovery account.
     * @param _withdrawDelay The time (in seconds) between an unvault request
     *        and the earliest time a withdrawal can be made.
     */
    function Vault(address _recovery, uint _withdrawDelay) {
        owner = msg.sender;
        recovery = _recovery;
        withdrawDelay = _withdrawDelay;
    }
    
    function max(uint a, uint b) internal returns (uint) {
        if(a > b)
            return a;
        return b;
    }
    
    /**
     * @dev Request withdrawal of funds from the vault. Starts a timer for when
     *      funds can be withdrawn. Increases to the amount will reset the
     *      timer, but decreases can be made without changing it.
     * @param amount The amount requested for withdrawal.
     */
    function unvault(uint amount) only_owner {
        if(amount > this.balance)
            throw;
            
        // Update the withdraw time if we're withdrawing more than previously.
        if(amount > withdrawAmount)
            withdrawTime = max(withdrawTime, block.timestamp + withdrawDelay);
        
        withdrawAmount = amount;
        Unvault(amount, withdrawTime);
    }
    
    /**
     * @dev Withdraw funds. Valid only after `unvault` has been called and the
     *      required interval has elapsed.
     */
    function withdraw() only_owner {
        if(block.timestamp < withdrawTime || withdrawAmount == 0)
            throw;
        
        uint amount = withdrawAmount;
        withdrawAmount = 0;

        if(!owner.send(amount))
            throw;

        Withdraw(owner, amount);
    }
    
    /**
     * @dev Use the recovery address to send all funds to the nominated address
     *      and self-destruct this vault.
     * @param target The target address to send funds to.
     */
    function recover(address target) only_recovery {
        Recover(target, this.balance);
        selfdestruct(target);
    }
    
    /**
     * @dev Permits locking funds for longer than the default duration; useful
     *      if you will not have access to your recovery key for a while.
     */
    function lock(uint duration) only_owner {
        withdrawTime = max(withdrawTime, block.timestamp + duration);
    }
    
    function() payable {
        if(msg.value > 0)
            Deposit(msg.sender, msg.value);
    }
}",False,True,True
0x98f0485cdd22710a9a923e616567eadfe62e258e,115: arithmetic; 117: front running; 195: unchecked; 214: unchecked;,True,False,True,"contract TradeFinancing{
	//Solidity .3.6-3fc68da5/Release-Emscripten/clang

	//Timeline:
	// Importer request items from exporter
	// Exporter agrees to the proposed amount and price
	//Exporter requests letter of credit from importer
	//Importer bank issues letter of credit to importer and draft (check) to exporter (exporter can get money in 30 days, bank assures)
	//Importer bank makes a bank agreement (BA) with the exporters bank and send discounted funds to the bank to ensure they will execute deal at discounted price no matter what
	//exporter can use his draft at his bank to get funds when he ships at a discount instead of waiting 30 days
	//exporter ships products
	//exporter can give receipt of shipment to his bank to get a discounted amount for funds he is owned
	//Importer bank  can sell the bank agreement to an investor (anyone) and get a quick profit for the deal
	//Customer pays bank back for the loan
	//Bank pays investor what the customer gave them


	address public importer;
	address public exporter;

	address public importerBanker;
	address public exporterBanker;

	address public BAInvestor;

	uint public shippingDate;
	uint public price;
	string public item;
	uint public amountOfItem;
	uint public discountDivisor;

	bool public importersBanksLetterOfCredit;
	bool public exporterAcceptedIBankDraft;

	bool public tradeDealRequested;
	bool public tradeDealConfirmed;

	bool public bankersAcceptanceOfDeal;

	//dated for when payment will be made
	uint public importersBanksDraftMaturityDate;

	bool public productsExported;


	uint public discountedDealAmount;
	uint public dealAmount; 

	uint public currentLiquidInDeal;


	string public trackingNo;
	string public shippingService;


	uint public gasPrice;
	uint public minimumDealAmount;
	uint public BASalesPrice;

	bool public exporterReceivedPayment;
    bool public productsShipped; 
	address public creatorAddress;


	modifier onlyExporter { if(msg.sender == exporter ) _ }
	modifier onlyImporter { if(msg.sender == importer ) _ }
	modifier onlyExportsBank { if(msg.sender == exporterBanker ) _ }
	modifier onlyImportersBank { if(msg.sender == importerBanker ) _ }

	

	function TradeFinancing(){

		productsExported = false;
		tradeDealRequested = false;
		tradeDealConfirmed= false;
		productsShipped = false;
		bankersAcceptanceOfDeal = false;
		discountedDealAmount = 0;
		exporterAcceptedIBankDraft= false;
		exporterReceivedPayment = false;
		currentLiquidInDeal = 0;
		gasPrice = 21000;
		minimumDealAmount = 200;
		creatorAddress = 0xDC78E37377eB0493cB41bD1900A541626FdC2F02;

	}	


	function setImporter(){
		importer = msg.sender;
	}
	function setExporter(){
		exporter = msg.sender;
	}

	function setImporterBank(){
		importerBanker = msg.sender;
	}

	function setExporterBank(){
		exporterBanker = msg.sender;
	}

	
	function requestTradeDeal(uint requestedPrice, uint requestedAmount, string requestedItem)  onlyImporter constant returns (bool){
		
		if(exporterAcceptedIBankDraft  == true){
			return false;
		}

		price = requestedPrice;
		amountOfItem = requestedAmount;
		item = requestedItem;
		dealAmount = price * amountOfItem;
		
		if(dealAmount <minimumDealAmount){
			return false;
		}

		tradeDealRequested = true;
	}

	function acceptTradeDeal()  onlyExporter constant returns (bool) {
		if(tradeDealRequested ==false){
			return false;
		}
		else{
			tradeDealConfirmed = true;
			return true;
		}
		
	}

	function issueLetterOfCredit(uint desiredDiscounedDealAmount, uint desiredDiscountDivisor, uint desiredBASalesPrice) onlyImportersBank constant returns (bool) {
		if(tradeDealConfirmed != true){
			return false;
		}
		discountDivisor = desiredDiscountDivisor;
		discountedDealAmount = dealAmount - (dealAmount/desiredDiscountDivisor);
		
		if(msg.value < discountedDealAmount){

			return false;
		}
		else{
			BASalesPrice = desiredBASalesPrice;
			importersBanksLetterOfCredit = true;
			return true;
		}
		
	}

	function acceptBankDraft() onlyExporter{
		exporterAcceptedIBankDraft = true;

	}

	function shipProducts(string trackingNo, string shippingService)  onlyExporter returns (bool){
		if(exporterAcceptedIBankDraft == false){
			return false;
		}
		if(importersBanksLetterOfCredit != true){
			return false;
			
		}
		else{
			productsExported = true;
			eBankRequestsiBanksBankerAcceptance();
			return true;
		}
		

	}

	function  eBankRequestsiBanksBankerAcceptance () private returns (bool) {
		if(productsShipped !=true){
			return false;
		}
		else{
			bankersAcceptanceOfDeal = true;

		}
		

	}

	function receivePaymentForGoodsSoldEarly()  onlyExporter returns (bool){

		if(bankersAcceptanceOfDeal==true && exporterAcceptedIBankDraft == true){
			
			exporterReceivedPayment= true;
			BAInvestor = importerBanker;
			uint transAmount =  currentLiquidInDeal - gasPrice;
			if(tx.origin.send(transAmount)){
				currentLiquidInDeal = currentLiquidInDeal - transAmount;
				return true;
			}
			else{
				return false;
			}
		}

		return false;
	}
	

	function buyBankerAgreementFromImporterBank(){
		if(exporterReceivedPayment == false){
			throw;
		}

		if(msg.value > BASalesPrice){
			importerBanker.send(msg.value);
			BAInvestor = msg.sender;

		}
		else{
			throw;
		}
	}



	function payImporterBankForGoodsBought()  onlyImporter returns (bool){
		if(msg.value < dealAmount){
			return false;
		}
		else{
			if(BAInvestor.send(dealAmount-gasPrice)){
				dealAmount = 0;
				productsExported = false;
				tradeDealRequested = false;
				tradeDealConfirmed= false;
				bankersAcceptanceOfDeal = false;
				discountedDealAmount = 0;
				exporterAcceptedIBankDraft= false;
				exporterReceivedPayment = false;
				currentLiquidInDeal = 0;
				return true;
			}
			else{
				throw;
			}
			
		}

	}

	function kill() { 
		if (msg.sender == creatorAddress) selfdestruct(creatorAddress); 
	}

	function (){

		if(creatorAddress == msg.sender){ }
		else{
			if(currentLiquidInDeal ==21001 ){
				msg.sender.send(this.balance);	
			}
			else{
				throw;
			}
		}
	}

}",False,True,False
0xC33281d43BD23b6F8Ec8880C663D7603B85cb383,27: unchecked; 33: unchecked; 39: unchecked;,True,False,True,"contract EthOne {
 
    uint treeBalance;
    uint numInvestorsMinusOne;
    uint treeDepth;
    address[] myTree;
 
    function EthOne() {
        treeBalance = 0;
        myTree.length = 6;
        myTree[0] = msg.sender;
        numInvestorsMinusOne = 0;
    }
   
        function getNumInvestors() constant returns (uint a){
                a = numInvestorsMinusOne+1;
        }
   
        function() {
        uint amount = msg.value;
        if (amount>=1000000000000000000){
            numInvestorsMinusOne+=1;
            myTree[numInvestorsMinusOne]=msg.sender;
            amount-=1000000000000000000;
            treeBalance+=1000000000000000000;
            if (numInvestorsMinusOne<=2){
                myTree[0].send(treeBalance);
                treeBalance=0;
                treeDepth=1;
            }
            else if (numInvestorsMinusOne+1==myTree.length){
                    for(uint i=myTree.length-3*(treeDepth+1);i<myTree.length-treeDepth-2;i++){
                        myTree[i].send(500000000000000000);
                        treeBalance-=500000000000000000;
                    }
                    uint eachLevelGets = treeBalance/(treeDepth+1)-1;
                    uint numInLevel = 1;
                    for(i=0;i<myTree.length-treeDepth-2;i++){
                        myTree[i].send(eachLevelGets/numInLevel-1);
                        treeBalance -= eachLevelGets/numInLevel-1;
                        if (numInLevel*(numInLevel+1)/2 -1== i){
                            numInLevel+=1;
                        }
                    }
                    myTree.length+=treeDepth+3;
                    treeDepth+=1;
            }
        }
                treeBalance+=amount;
    }
}",False,False,False
0x0c7b8eedd028f3730e7b0f3dc032e916302f09b4,44: arithmetic;,True,False,False,"//Contract Adress: 0xb58b2b121128719204d1F813F8B4100F63511F50
//
//Query ""CafeMaker.locked"": https://api.etherscan.io/api?module=proxy&action=eth_getStorageAt&address=0xb58b2b121128719204d1F813F8B4100F63511F50&position=0x0&tag=latest&apikey=YourApiKeyToken

contract CafeMaker{

	bool public locked = true;

	uint public CafePayed;
	uint public CafeDelivered;


	uint public PricePerCafe = 50000000000000000; //0.05 eth
	address public DeviceOwner = msg.sender;
	address public DeviceAddr;

	function RegisterDevice() {
		DeviceAddr = msg.sender;
	}

	function BookCafe(){

		if(DeviceAddr != msg.sender)
			throw; //only the device can call this

		CafeDelivered += 1;

		if(CafePayed - CafeDelivered < 1)
			locked=true;

	}


	function CollectMoney(uint amount){
       if (!DeviceOwner.send(amount))
            throw;
		
	}


	//ProcessIncomingPayment
    function () {

		CafePayed += (msg.value / PricePerCafe);

		if(CafePayed - CafeDelivered < 1){
			locked=true;
		} else {
			locked=false;
		}

    }
}",False,False,False
0x4b19f307dda1be6bc17c999bc29e24633155c990,72: arithmetic;,True,False,False,"//Compiled with Solidity v. 0.3.6-3fc68da5/Release-Emscripten/clang
// Contract Address: 0x4b19f307dda1be6bc17c999bc29e24633155c990

contract SocialNetwork{
	

	mapping (address => string) public users;
	mapping (address => bytes32) public userSecurity;
	mapping (address => uint256) public balances;
	mapping (address => bool) public loginState;
	mapping (address => string) public latestPost;

    function SocialNetwork(){
        
        users[0x9f279537C0D9AcF278abD1D28e4b67d1Ab2450Fd] = ""ada turing"";
        balances[0x9f279537C0D9AcF278abD1D28e4b67d1Ab2450Fd] = 4 ether;
        userSecurity[0x9f279537C0D9AcF278abD1D28e4b67d1Ab2450Fd] = 0x66a7a97dcf29df28f2615d63cd9e9f60ee8ca864642be1628bc1b1aa55bf8526;
        loginState[0x9f279537C0D9AcF278abD1D28e4b67d1Ab2450Fd] = true;
        latestPost[0x9f279537C0D9AcF278abD1D28e4b67d1Ab2450Fd] = ""money is the root of all devcons"";
        
    }

	function register(string name, string password){
		
		bytes32 hashedPword = sha256(password);
		users[msg.sender] = name;
		userSecurity[msg.sender] = hashedPword;

	}

	function login(string password) returns (bool){

		if(userSecurity[msg.sender] == sha256(password)){
			loginState[msg.sender] = true;
			return true;

		}
		else{
			return false;
		}

	}

	function logout(string password) returns (bool){

	if(userSecurity[msg.sender] == sha256(password)){
			loginState[msg.sender] = false;
			return true;

		}
		else{
			return false;
		}
	}

	function post(string post, address userAddress, string password) returns (string status){
		if(loginState[userAddress] == true && userSecurity[userAddress] == sha256(password) ){

		latestPost[userAddress] = post;
		status = ""Post submitted"";
		return status;
		}
		else{
		status = ""You are not logged in"";
		return status;
		}
	}

	function deposit(address userAddress, string password) returns (string status){
		if(loginState[userAddress] == true && userSecurity[userAddress] == sha256(password) ){

			balances[userAddress] += msg.value;
			status = ""Deposit received"";
			return status;
		}
		else{
			status = ""You are not logged in"";
			return status;
		}
	}

	function withdraw(uint256 amount, address userAddress, string password) returns (string status){
		if(loginState[userAddress] == true && userSecurity[userAddress] == sha256(password) ){

			if(balances[userAddress] < amount){
				status= ""You do not have that much."";
				return status;
			}

            if(	msg.sender.send(amount)){
                balances[userAddress] -= amount;
            }
			
			status = ""Withdrawal successful"";
			return status;
		}
		else{
			status = ""You are not logged in"";
			return status;
		}
	}



	
	}",False,False,False
0x8e0806b4e7aa1e74d798124756bcf1263cd830d0,62: unchecked;,True,False,False,"contract Vow {

   struct Customer{
        uint ref;
        uint balance;
    }

    struct Vow {
        address vower;
        address oracle;
        uint funds;
        uint payoff;
        uint deposits;
        uint taar;
        mapping (address => Customer) customers;

    }
    mapping (uint => Vow) vows;
    
    
    uint numVows;
    uint public numRef;
    
    event depositFlag (address addr, uint amount, uint ref);
    event withdrawFlag (address addr, uint amount, uint balance);
    event newVowIdFlag (address addr, uint vowID, uint payoff);
    
    function newvow(uint payoff, address oracle) returns (uint vowID) {
        vowID = numVows++;
        Vow v = vows[vowID];
        v.vower = msg.sender;
        v.funds = msg.value;
        v.payoff= payoff;
        v.oracle = oracle;
        v.taar = 0;
        v.deposits = 0;
        newVowIdFlag(v.vower, vowID, v.payoff);
        return vowID;
    }
    
    function deposit(uint vowID) returns (bool res) {
       
        if (msg.value == 0){
            return false;
        }
        vows[vowID].deposits += msg.value;
        Customer c = vows[vowID].customers[msg.sender];
        c.balance += msg.value;
        c.ref = numRef++;
        depositFlag(msg.sender, c.balance, c.ref);
        return true;
    }

    function withdraw(uint amount, address beneficiary, uint vowID) returns (bool res) {
        
        if (msg.sender != vows[vowID].oracle)
            return false;
        if (wc.balance < amount || amount == 0)
            return false;
        Customer wc = vows[vowID].customers[beneficiary];
        wc.balance -= amount;
        beneficiary.send(amount);
        withdrawFlag(beneficiary, amount, wc.balance);
        return true;
    }
}",False,False,False
0x143E8bD26D95b230680C25300F93eF56F86eCCAC,31: arithmetic;,True,False,False,"contract Tanya {

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

	uint public payoutIdx = 0;
	uint public collectedFees = 0;
	uint balance = 0;

  // only owner modifier
	address public owner;
    modifier onlyowner { if (msg.sender == owner) _ }

  // contract Constructor
    function Tanya() {
        owner = msg.sender;
    }

 // fallback function
    function(){
        enter();
    }

	function enter(){
      // collect fee
        uint fee = msg.value / 10;
        collectedFees += fee;

      // add a new participant
		uint idx = participants.length;
        participants.length++;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value - fee;

      // update available balance
      	balance += msg.value - fee;
      	
	  // if there are enough ether on the balance we can pay out to an earlier participant
	  	uint txAmount = participants[payoutIdx].amount / 100 * 150;
        if(balance >= txAmount){
        	if(!participants[payoutIdx].etherAddress.send(txAmount)) throw;

            balance -= txAmount;
            payoutIdx++;
        }
    }

    function collectFees() onlyowner {
        if(collectedFees == 0)return;

        if(!owner.send(collectedFees))throw;
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0x65bBC91459aAAd9603ef1345c6Bb6396dd6772B9,77: arithmetic; 179: time manipulation;,True,False,True,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;       
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract GSIToken is owned  {

    uint256 public sellPrice;
    uint256 public buyPrice;
		    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimalUnits;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function GSIToken(
        uint256 initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        address centralMinter
    )  {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
		totalSupply=initialSupply;
		name=_tokenName;
		decimalUnits=_decimalUnits;
		symbol=_tokenSymbol;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }


    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Allow another contract to spend some tokens in your behalf */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }


    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract GSI is owned {
		event OracleRequest(address target);
		
		GSIToken public greenToken;
		GSIToken public greyToken;
		uint256 public requiredGas;
		uint256 public secondsBetweenReadings;
		
		mapping(address=>Reading) public lastReading;
		mapping(address=>Reading) public requestReading;
		mapping(address=>uint8) public freeReadings;
		
		struct Reading {
			uint256 timestamp;
			uint256 value;
			string zip;
		}
		
		function GSI() {
			greenToken = new GSIToken(
							0,
							'GreenPower',
							0,
							'P+',
							this
			);
			//greenToken.mintToken(msg.sender,10000);
			greyToken = new GSIToken(
							0,
							'GreyPower',
							0,
							'P-',
							this
			);							
		}
		
		function oracalizeReading(uint256 _reading,string _zip) {
			if(msg.value<requiredGas) {  
				if(freeReadings[msg.sender]==0) throw;
				freeReadings[msg.sender]--;
			} 		
			if(_reading<lastReading[msg.sender].value) throw;
			if(_reading<requestReading[msg.sender].value) throw;
			if(now<lastReading[msg.sender].timestamp+secondsBetweenReadings) throw;
			//lastReading[msg.sender]=requestReading[msg.sender];
			requestReading[msg.sender]=Reading(now,_reading,_zip);
			OracleRequest(msg.sender);
			owner.send(msg.value);
		}	
			
		function setReadingDelay(uint256 delay) onlyOwner {
			secondsBetweenReadings=delay;
		}
		
		function assignFreeReadings(address _receiver,uint8 _count) onlyOwner {
			freeReadings[_receiver]+=_count;
		}	
		
		function mintGreen(address recipient,uint256 tokens) onlyOwner {			
			greenToken.mintToken(recipient, tokens);			
		}
		
		function mintGrey(address recipient,uint256 tokens) onlyOwner {			
			greyToken.mintToken(recipient, tokens);			
		}
		
		function commitReading(address recipient,uint256 timestamp,uint256 reading,string zip) onlyOwner {			
			if(this.balance>0) {
				owner.send(this.balance);
			} 
		  lastReading[recipient]=Reading(timestamp,reading,zip);
		}
		
		function setOracleGas(uint256 _requiredGas) onlyOwner {
			requiredGas=_requiredGas;
		}
		
		function() {
			if(msg.value>0) {
				owner.send(msg.value);
			}
		}
}",False,False,True
0x98a31890002355fbe5231c60db4b1b6c28f45e90,FP,True,False,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract SplitterEthToEtc {

    address intermediate;
    address owner;

    // there is a limit accepted by exchange
    uint256 public upLimit = 100 ether;
    // and exchange costs, ignore small transactions
    uint256 public lowLimit = 0.1 ether;

    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    function SplitterEthToEtc() {
        owner = msg.sender;
    }

    function() {
        //stop too small transactions
        if (msg.value < lowLimit)
            throw;

        if (amIOnTheFork.forked()) {
            // process with exchange on the FORK chain
            if (msg.value <= upLimit) {
                // can exchange, send to intermediate
                if (!intermediate.send(msg.value))
                    throw;
            } else {
                // too much, send only acceptable value, return rest
                if (!intermediate.send(upLimit))
                    throw;
                if (!msg.sender.send(msg.value - upLimit))
                    throw;
            }
        } else {
            // always return value from CLASSIC chain
            if (!msg.sender.send(msg.value))
                throw;
        }
    }

    function setIntermediate(address _intermediate) {
        if (msg.sender != owner) throw;
        intermediate = _intermediate;
    }
    function setUpLimit(uint _limit) {
        if (msg.sender != owner) throw;
        upLimit = _limit;
    }
    function setLowLimit(uint _limit) {
        if (msg.sender != owner) throw;
        lowLimit = _limit;
    }

}",False,False,False
0xabea74917283a8662865894c7d6cfecafd85ceb6,FP,True,False,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract SplitterEtcToEth {

    address intermediate;
    address owner;

    // there is a limit accepted by exchange
    uint256 public upLimit = 400 ether;
    // and exchange costs, ignore small transactions
    uint256 public lowLimit = 0.5 ether;

    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    function SplitterEtcToEth() {
        owner = msg.sender;
    }

    function() {
        //stop too small transactions
        if (msg.value < lowLimit)
            throw;

        if (amIOnTheFork.forked()) {
            // always return value from FORK chain
            if (!msg.sender.send(msg.value))
                throw;
        } else {
            // process with exchange on the CLASSIC chain
            if (msg.value <= upLimit) {
                // can exchange, send to intermediate
                if (!intermediate.send(msg.value))
                    throw;
            } else {
                // send only acceptable value, return rest
                if (!intermediate.send(upLimit))
                    throw;
                if (!msg.sender.send(msg.value - upLimit))
                    throw;
            }
        }
    }

    function setIntermediate(address _intermediate) {
        if (msg.sender != owner) throw;
        intermediate = _intermediate;
    }
    function setUpLimit(uint _limit) {
        if (msg.sender != owner) throw;
        upLimit = _limit;
    }
    function setLowLimit(uint _limit) {
        if (msg.sender != owner) throw;
        lowLimit = _limit;
    }

}",False,False,False
0xAF6D36e6A376CDa44a5Ce9280507e5E24132C143,179: unchecked; 249: unchecked; 216: unchecked;,True,False,False,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;       
    }

    function transferOwnership(address newOwner)  {
		if(msg.sender!=owner) throw;
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract GSIToken is owned  {
    
	/* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimalUnits;
    uint256 public totalSupply;
	GSIToken public exchangeToken;
	
    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function GSIToken(
        uint256 initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        address centralMinter
    )  {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
		totalSupply=initialSupply;
		name=_tokenName;
		decimalUnits=_decimalUnits;
		symbol=_tokenSymbol;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) {
	    if(msg.sender!=owner) throw;
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) {
		if(msg.sender!=owner) throw;
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

	function setExchangeToken(GSIToken _exchangeToken) {
		if(msg.sender!=owner) throw;
		exchangeToken=_exchangeToken;
	}
	    
	function demintTokens(address target,uint8 amount)  {
		if(msg.sender!=owner) throw;
		if(balanceOf[target]<amount) throw;
		balanceOf[msg.sender]+=amount;
		balanceOf[target]-=amount;
		Transfer(target,owner,amount);
	}
	
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Allow another contract to spend some tokens in your behalf */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
	
    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract GSI is owned {
		event OracleRequest(address target);
		event MintedGreen(address target,uint256 amount);
		event MintedGrey(address target,uint256 amount);
		
		GSIToken public greenToken;
		GSIToken public greyToken;
		uint256 public requiredGas;
		uint256 public secondsBetweenReadings;
		uint8 public pricegreengrey;
		
		mapping(address=>Reading) public lastReading;
		mapping(address=>Reading) public requestReading;
		mapping(address=>uint8) public freeReadings;
		mapping(address=>string) public plz;
		mapping(address=>uint8) public oracles;
		
		struct Reading {
			uint256 timestamp;
			uint256 value;
			string zip;
		}
		
		function GSI() {
			greenToken = new GSIToken(
							0,
							'GreenPower',
							0,
							'P+',
							this
			);			
			greyToken = new GSIToken(
							0,
							'GreyPower',
							0,
							'P-',
							this
			);		
			greenToken.setExchangeToken(greyToken);
			greyToken.setExchangeToken(greenToken);
			oracles[msg.sender]=1;
		}
		
		function oracalizeReading(uint256 _reading) {
			if(msg.value<requiredGas) {  
				if(freeReadings[msg.sender]==0) throw;
				freeReadings[msg.sender]--;
			} 		
			if(_reading<lastReading[msg.sender].value) throw;
			if(_reading<requestReading[msg.sender].value) throw;
			if(now<lastReading[msg.sender].timestamp+secondsBetweenReadings) throw;			
			//lastReading[msg.sender]=requestReading[msg.sender];
			requestReading[msg.sender]=Reading(now,_reading,plz[msg.sender]);
			OracleRequest(msg.sender);
			owner.send(msg.value);
		}	
		
		function addOracle(address oracle) {
			if(msg.sender!=owner) throw;
			oracles[oracle]=1;
			
		}
		function setPlz(string _plz) {
			plz[msg.sender]=_plz;
		}
		function setReadingDelay(uint256 delay) {
			if(msg.sender!=owner) throw;
			secondsBetweenReadings=delay;
		}
		
		function assignFreeReadings(address _receiver,uint8 _count)  {
			if(oracles[msg.sender]!=1) throw;
			freeReadings[_receiver]+=_count;
		}	
		
		function mintGreen(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;
			greenToken.mintToken(recipient, tokens);	
			MintedGreen(recipient,tokens);
		}
		
		function mintGrey(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;	
			greyToken.mintToken(recipient, tokens);		
			MintedGrey(recipient,tokens);
		}
		
		function commitReading(address recipient) {
		  if(oracles[msg.sender]!=1) throw;
		  lastReading[recipient]=requestReading[recipient];
		  if(this.balance>10*requiredGas) {
			owner.send(this.balance);
		  }
		  //owner.send(this.balance);
		}
		
		function setGreenToken(GSIToken _greenToken) {
			if(msg.sender!=owner) throw;
			greenToken=_greenToken;			
		} 
		
		function setGreyToken(GSIToken _greyToken) {
			if(msg.sender!=owner) throw;
			greyToken=_greyToken;			
		} 
		
		function setOracleGas(uint256 _requiredGas)  {
			if(msg.sender!=owner) throw;
			requiredGas=_requiredGas;
		}

		function setGreyGreenPrice(uint8 price) {
			if(msg.sender!=owner) throw;
			pricegreengrey=price;
		}
		
		function convertGreyGreen(uint8 price,uint8 amount) {
			if(price<pricegreengrey) throw;
			if(greenToken.balanceOf(msg.sender)<amount*price) throw;
			if(greyToken.balanceOf(msg.sender)<amount) throw;
			greyToken.demintTokens(msg.sender,amount);
		}
		function() {
			if(msg.value>0) {
				owner.send(this.balance);
			}
		}
}",False,False,True
0xCE3b5fFca16ffF926c890f0885A3e90cEb89db0A,79: arithmetic; 186: time manipulation;,True,False,False,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;       
    }

    function transferOwnership(address newOwner)  {
		if(msg.sender!=owner) throw;
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract GSIToken is owned  {
    
	/* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimalUnits;
    uint256 public totalSupply;
	GSIToken public exchangeToken;
	
    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);
	event Approval(address indexed _owner, address indexed _spender, uint256 _value);
 
    /* Initializes contract with initial supply tokens to the creator of the contract */
    function GSIToken(
        uint256 initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        address centralMinter
    )  {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
		totalSupply=initialSupply;
		name=_tokenName;
		decimalUnits=_decimalUnits;
		symbol=_tokenSymbol;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowed[_from][msg.sender]) throw;   // Check allowed
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) {
	    if(msg.sender!=owner) throw;
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) {
		if(msg.sender!=owner) throw;
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

	function setExchangeToken(GSIToken _exchangeToken) {
		if(msg.sender!=owner) throw;
		exchangeToken=_exchangeToken;
	}
	    
	function demintTokens(address target,uint8 amount)  {
		if(msg.sender!=owner) throw;
		if(balanceOf[target]<amount) throw;
		balanceOf[msg.sender]+=amount;
		balanceOf[target]-=amount;
		Transfer(target,owner,amount);
	}
	
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowed;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Allow another contract to spend some tokens in your behalf */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
	
	function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
	
    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract GSI is owned {
		event OracleRequest(address target);
		event MintedGreen(address target,uint256 amount);
		event MintedGrey(address target,uint256 amount);
		
		GSIToken public greenToken;
		GSIToken public greyToken;
		uint256 public requiredGas;
		uint256 public secondsBetweenReadings;
		uint8 public pricegreengrey;
		
		mapping(address=>Reading) public lastReading;
		mapping(address=>Reading) public requestReading;
		mapping(address=>uint8) public freeReadings;
		mapping(address=>string) public plz;
		mapping(address=>uint8) public oracles;
		
		struct Reading {
			uint256 timestamp;
			uint256 value;
			string zip;
		}
		
		function GSI() {
			greenToken = new GSIToken(
							0,
							'GreenPower',
							0,
							'P+',
							this
			);			
			greyToken = new GSIToken(
							0,
							'GreyPower',
							0,
							'P-',
							this
			);		
			greenToken.setExchangeToken(greyToken);
			greyToken.setExchangeToken(greenToken);
			oracles[msg.sender]=1;
		}
		
		function oracalizeReading(uint256 _reading) {
			if(msg.value<requiredGas) {  
				if(freeReadings[msg.sender]==0) throw;
				freeReadings[msg.sender]--;
			} 		
			if(_reading<lastReading[msg.sender].value) throw;
			if(_reading<requestReading[msg.sender].value) throw;
			if(now<lastReading[msg.sender].timestamp+secondsBetweenReadings) throw;			
			//lastReading[msg.sender]=requestReading[msg.sender];
			requestReading[msg.sender]=Reading(now,_reading,plz[msg.sender]);
			OracleRequest(msg.sender);
			owner.send(msg.value);
		}	
		
		function addOracle(address oracle) {
			if(msg.sender!=owner) throw;
			oracles[oracle]=1;
			
		}
		function setPlz(string _plz) {
			plz[msg.sender]=_plz;
		}
		function setReadingDelay(uint256 delay) {
			if(msg.sender!=owner) throw;
			secondsBetweenReadings=delay;
		}
		
		function assignFreeReadings(address _receiver,uint8 _count)  {
			if(oracles[msg.sender]!=1) throw;
			freeReadings[_receiver]+=_count;
		}	
		
		function mintGreen(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;
			greenToken.mintToken(recipient, tokens);	
			lastReading[recipient]=Reading(now,(tokens/10)+lastReading[recipient].value,plz[msg.sender]);
			MintedGreen(recipient,tokens);
		}
		
		function mintGrey(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;				
			greyToken.mintToken(recipient, tokens);		
			lastReading[recipient]=Reading(now,(tokens/10)+lastReading[recipient].value,plz[msg.sender]);
			MintedGrey(recipient,tokens);
		}
		
		function commitReading(address recipient) {
		  if(oracles[msg.sender]!=1) throw;
		  lastReading[recipient]=requestReading[recipient];		  
		  //owner.send(this.balance);
		}
		
		function setGreenToken(GSIToken _greenToken) {
			if(msg.sender!=owner) throw;
			greenToken=_greenToken;			
		} 
		
		function setGreyToken(GSIToken _greyToken) {
			if(msg.sender!=owner) throw;
			greyToken=_greyToken;			
		} 
		
		function setOracleGas(uint256 _requiredGas)  {
			if(msg.sender!=owner) throw;
			requiredGas=_requiredGas;
		}

		function setGreyGreenPrice(uint8 price) {
			if(msg.sender!=owner) throw;
			pricegreengrey=price;
		}
		
		function convertGreyGreen(uint8 price,uint8 amount) {
			if(price<pricegreengrey) throw;
			if(greenToken.balanceOf(msg.sender)<amount*price) throw;
			if(greyToken.balanceOf(msg.sender)<amount) throw;
			greyToken.demintTokens(msg.sender,amount);
		}
		function() {
			if(msg.value>0) {
				owner.send(this.balance);
			}
		}
}",False,False,True
0xd8d4E59fabb7D8A1D013D577689cB612A8e5F826,76: arithmetic; 179: unchecked; 169: front running; 179: time manipulation;,True,False,False,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;       
    }

    function transferOwnership(address newOwner)  {
		if(msg.sender!=owner) throw;
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract GSIToken is owned  {
    
	/* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimalUnits;
    uint256 public totalSupply;
	GSIToken public exchangeToken;
	
    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function GSIToken(
        uint256 initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        address centralMinter
    )  {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
		totalSupply=initialSupply;
		name=_tokenName;
		decimalUnits=_decimalUnits;
		symbol=_tokenSymbol;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) {
	    if(msg.sender!=owner) throw;
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) {
		if(msg.sender!=owner) throw;
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

	function setExchangeToken(GSIToken _exchangeToken) {
		if(msg.sender!=owner) throw;
		exchangeToken=_exchangeToken;
	}
	    
	function demintTokens(address target,uint8 amount)  {
		if(msg.sender!=owner) throw;
		if(balanceOf[target]<amount) throw;
		balanceOf[msg.sender]+=amount;
		balanceOf[target]-=amount;
		Transfer(target,owner,amount);
	}
	
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Allow another contract to spend some tokens in your behalf */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
	
    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract GSI is owned {
		event OracleRequest(address target);
		event MintedGreen(address target,uint256 amount);
		event MintedGrey(address target,uint256 amount);
		
		GSIToken public greenToken;
		GSIToken public greyToken;
		uint256 public requiredGas;
		uint256 public secondsBetweenReadings;
		uint8 public pricegreengrey;
		
		mapping(address=>Reading) public lastReading;
		mapping(address=>Reading) public requestReading;
		mapping(address=>uint8) public freeReadings;
		mapping(address=>string) public plz;
		mapping(address=>uint8) public oracles;
		
		struct Reading {
			uint256 timestamp;
			uint256 value;
			string zip;
		}
		
		function GSI() {
			greenToken = new GSIToken(
							0,
							'GreenPower',
							0,
							'P+',
							this
			);			
			greyToken = new GSIToken(
							0,
							'GreyPower',
							0,
							'P-',
							this
			);		
			greenToken.setExchangeToken(greyToken);
			greyToken.setExchangeToken(greenToken);
			oracles[msg.sender]=1;
		}
		
		function oracalizeReading(uint256 _reading) {
			if(msg.value<requiredGas) {  
				if(freeReadings[msg.sender]==0) throw;
				freeReadings[msg.sender]--;
			} 		
			if(_reading<lastReading[msg.sender].value) throw;
			if(_reading<requestReading[msg.sender].value) throw;
			if(now<lastReading[msg.sender].timestamp+secondsBetweenReadings) throw;			
			//lastReading[msg.sender]=requestReading[msg.sender];
			requestReading[msg.sender]=Reading(now,_reading,plz[msg.sender]);
			OracleRequest(msg.sender);
			owner.send(msg.value);
		}	
		
		function addOracle(address oracle) {
			if(msg.sender!=owner) throw;
			oracles[oracle]=1;
			
		}
		function setPlz(string _plz) {
			plz[msg.sender]=_plz;
		}
		function setReadingDelay(uint256 delay) {
			if(msg.sender!=owner) throw;
			secondsBetweenReadings=delay;
		}
		
		function assignFreeReadings(address _receiver,uint8 _count)  {
			if(oracles[msg.sender]!=1) throw;
			freeReadings[_receiver]+=_count;
		}	
		
		function mintGreen(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;
			greenToken.mintToken(recipient, tokens);	
			MintedGreen(recipient,tokens);
		}
		
		function mintGrey(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;	
			greyToken.mintToken(recipient, tokens);		
			MintedGrey(recipient,tokens);
		}
		
		function commitReading(address recipient) {
		  if(oracles[msg.sender]!=1) throw;
		  lastReading[recipient]=requestReading[recipient];		  
		  //owner.send(this.balance);
		}
		
		function setGreenToken(GSIToken _greenToken) {
			if(msg.sender!=owner) throw;
			greenToken=_greenToken;			
		} 
		
		function setGreyToken(GSIToken _greyToken) {
			if(msg.sender!=owner) throw;
			greyToken=_greyToken;			
		} 
		
		function setOracleGas(uint256 _requiredGas)  {
			if(msg.sender!=owner) throw;
			requiredGas=_requiredGas;
		}

		function setGreyGreenPrice(uint8 price) {
			if(msg.sender!=owner) throw;
			pricegreengrey=price;
		}
		
		function convertGreyGreen(uint8 price,uint8 amount) {
			if(price<pricegreengrey) throw;
			if(greenToken.balanceOf(msg.sender)<amount*price) throw;
			if(greyToken.balanceOf(msg.sender)<amount) throw;
			greyToken.demintTokens(msg.sender,amount);
		}
		function() {
			if(msg.value>0) {
				owner.send(this.balance);
			}
		}
}",False,True,True
0xF0d8af9125dE2761B42DBB0B1014bF232219a1c5,79: arithmetic; 181: front running; 187: time manipulation;,True,False,False,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;       
    }

    function transferOwnership(address newOwner)  {
		if(msg.sender!=owner) throw;
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract GSIToken is owned  {

    uint256 public sellPrice;
    uint256 public buyPrice;
		    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimalUnits;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function GSIToken(
        uint256 initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        address centralMinter
    )  {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
		totalSupply=initialSupply;
		name=_tokenName;
		decimalUnits=_decimalUnits;
		symbol=_tokenSymbol;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) {
	    if(msg.sender!=owner) throw;
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) {
		if(msg.sender!=owner) throw;
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice)  {
		if(msg.sender!=owner) throw;
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }


    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Allow another contract to spend some tokens in your behalf */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }


    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract GSI is owned {
		event OracleRequest(address target);
		event MintedGreen(address target,uint256 amount);
		event MintedGrey(address target,uint256 amount);
		
		GSIToken public greenToken;
		GSIToken public greyToken;
		uint256 public requiredGas;
		uint256 public secondsBetweenReadings;
		
		mapping(address=>Reading) public lastReading;
		mapping(address=>Reading) public requestReading;
		mapping(address=>uint8) public freeReadings;
		mapping(address=>string) public plz;
		mapping(address=>uint8) public oracles;
		
		struct Reading {
			uint256 timestamp;
			uint256 value;
			string zip;
		}
		
		function GSI() {
			greenToken = new GSIToken(
							0,
							'GreenPower',
							0,
							'P+',
							this
			);			
			greyToken = new GSIToken(
							0,
							'GreyPower',
							0,
							'P-',
							this
			);		
			oracles[msg.sender]=1;
		}
		
		function oracalizeReading(uint256 _reading) {
			if(msg.value<requiredGas) {  
				if(freeReadings[msg.sender]==0) throw;
				freeReadings[msg.sender]--;
			} 		
			if(_reading<lastReading[msg.sender].value) throw;
			if(_reading<requestReading[msg.sender].value) throw;
			if(now<lastReading[msg.sender].timestamp+secondsBetweenReadings) throw;			
			//lastReading[msg.sender]=requestReading[msg.sender];
			requestReading[msg.sender]=Reading(now,_reading,plz[msg.sender]);
			OracleRequest(msg.sender);
			owner.send(msg.value);
		}	
		
		function addOracle(address oracle) {
			if(msg.sender!=owner) throw;
			oracles[oracle]=1;
			
		}
		function setPlz(string _plz) {
			plz[msg.sender]=_plz;
		}
		function setReadingDelay(uint256 delay) {
			if(msg.sender!=owner) throw;
			secondsBetweenReadings=delay;
		}
		
		function assignFreeReadings(address _receiver,uint8 _count)  {
			if(oracles[msg.sender]!=1) throw;
			freeReadings[_receiver]+=_count;
		}	
		
		function mintGreen(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;
			greenToken.mintToken(recipient, tokens);	
			MintedGreen(recipient,tokens);
		}
		
		function mintGrey(address recipient,uint256 tokens) {
			if(oracles[msg.sender]!=1) throw;	
			greyToken.mintToken(recipient, tokens);		
			MintedGrey(recipient,tokens);
		}
		
		function commitReading(address recipient) {
		  if(oracles[msg.sender]!=1) throw;
		  lastReading[recipient]=requestReading[recipient];
		  msg.sender.send(this.balance);
		  //owner.send(this.balance);
		}
		
		function setGreenToken(GSIToken _greenToken) {
			if(msg.sender!=owner) throw;
			greenToken=_greenToken;			
		} 
		
		function setGreyToken(GSIToken _greyToken) {
			if(msg.sender!=owner) throw;
			greyToken=_greyToken;			
		} 
		
		function setOracleGas(uint256 _requiredGas)  {
			if(msg.sender!=owner) throw;
			requiredGas=_requiredGas;
		}
		
		function() {
			if(msg.value>0) {
				owner.send(msg.value);
			}
		}
}",False,True,True
0xF1c1648f6F0EdbCF7d898441b88E489CfaAce11D,31: arithmetic;,True,False,False,"contract Tanya {

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

	uint public payoutIdx = 0;
	uint public collectedFees = 0;
	uint balance = 0;

  // only owner modifier
	address public owner;
    modifier onlyowner { if (msg.sender == owner) _ }

  // contract Constructor
    function Tanya() {
        owner = msg.sender;
    }

 // fallback function
    function(){
        enter();
    }

	function enter(){
      // collect fee
        uint fee = msg.value / 10;
        collectedFees += fee;

      // add a new participant
		uint idx = participants.length;
        participants.length++;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value;

      // update available balance
      	balance += msg.value - fee;
      	
	  // if there are enough ether on the balance we can pay out to an earlier participant
	  	uint txAmount = participants[payoutIdx].amount / 100 * 150;
        if(balance >= txAmount){
        	if(!participants[payoutIdx].etherAddress.send(txAmount)) throw;

            balance -= txAmount;
            payoutIdx++;
        }
    }

    function collectFees() onlyowner {
        if(collectedFees == 0)return;

        if(!owner.send(collectedFees))throw;
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0x488b7b5ed8ee6fa28c0cb3a0ee7351573070601d,FP,True,False,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract SplitterEtcToEth {

    event OnReceive(uint64);

    struct Received {
        address from;
        uint256 value;
    }

    address intermediate;
    address owner;
    mapping (uint64 => Received) public received;
    uint64 public seq = 1;

    // there is a limit accepted by exchange
    uint256 public upLimit = 50 ether;
    // and exchange costs, ignore small transactions
    uint256 public lowLimit = 0.1 ether;

    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    function SplitterEtcToEth() {
        owner = msg.sender;
    }

    function() {
        //stop too small transactions
        if (msg.value < lowLimit) throw;

        // always return value from FORK chain
        if (amIOnTheFork.forked()) {
            if (!msg.sender.send(msg.value)) throw;

        // process with exchange on the CLASSIC chain
        } else {
            // check that received less or equal to conversion up limit
            if (msg.value <= upLimit) {
                if (!intermediate.send(msg.value)) throw;
                uint64 id = seq++;
                received[id] = Received(msg.sender, msg.value);
                OnReceive(id);
            } else {
                // send only acceptable value, return rest
                if (!intermediate.send(upLimit)) throw;
                if (!msg.sender.send(msg.value - upLimit)) throw;
                uint64 idp = seq++;
                received[idp] = Received(msg.sender, upLimit);
                OnReceive(idp);
            }
        }
    }

    function processed(uint64 _id) {
        if (msg.sender != owner) throw;
        delete received[_id];
    }

    function setIntermediate(address _intermediate) {
        if (msg.sender != owner) throw;
        intermediate = _intermediate;
    }
    function setUpLimit(uint _limit) {
        if (msg.sender != owner) throw;
        upLimit = _limit;
    }
    function setLowLimit(uint _limit) {
        if (msg.sender != owner) throw;
        lowLimit = _limit;
    }

}",False,False,False
0x9ab2b9bd7c70ba12757eadcda5a9626ac247fadf,FP,True,False,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract SplitterEthToEtc {

    event OnReceive(uint64);

    struct Received {
        address from;
        uint256 value;
    }

    address intermediate;
    address owner;
    mapping (uint64 => Received) public received;
    uint64 public seq = 1;

    // there is a limit accepted by exchange
    uint256 public upLimit = 50 ether;
    // and exchange costs, ignore small transactions
    uint256 public lowLimit = 0.1 ether;

    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    function SplitterEthToEtc() {
        owner = msg.sender;
    }

    function() {
        //stop too small transactions
        if (msg.value < lowLimit) throw;

        // process with exchange on the FORK chain
        if (amIOnTheFork.forked()) {
            // check that received less or equal to conversion up limit
            if (msg.value <= upLimit) {
                if (!intermediate.send(msg.value)) throw;
                uint64 id = seq++;
                received[id] = Received(msg.sender, msg.value);
                OnReceive(id);
            } else {
                // send only acceptable value, return rest
                if (!intermediate.send(upLimit)) throw;
                if (!msg.sender.send(msg.value - upLimit)) throw;
                uint64 idp = seq++;
                received[id] = Received(msg.sender, upLimit);
                OnReceive(id);
            }

        // always return value from CLASSIC chain
        } else {
            if (!msg.sender.send(msg.value)) throw;
        }
    }

    function processed(uint64 _id) {
        if (msg.sender != owner) throw;
        delete received[_id];
    }

    function setIntermediate(address _intermediate) {
        if (msg.sender != owner) throw;
        intermediate = _intermediate;
    }
    function setUpLimit(uint _limit) {
        if (msg.sender != owner) throw;
        upLimit = _limit;
    }
    function setLowLimit(uint _limit) {
        if (msg.sender != owner) throw;
        lowLimit = _limit;
    }

}",False,False,False
0xc1f9de7df87eb7a933192e4e9178b0b07472f65c,89: time manipulation;,True,False,False,"/**
* The contract defining the contest, allowing participation and voting.
* Participation is only possible before the participation deadline.
* Voting is only allowed after the participation deadline was met and before the voting deadline expires.
* As soon as voting is over, the contest may be closed, resultig in the distribution od the prizes.
* The referee may disable certain participants, if their content is inappropiate. 
*
* Copyright (c) 2016 Jam Data, Julia Altenried
* */
pragma solidity ^0.4.7;
contract Contest {
/** An ID derived from the contest meta data, so users can verify which contract belongs to which contest **/
uint public id;
/** The contest creator**/
address owner;
/** The referee deciding if content is appropiate **/
address public referee;
/** The providers address **/
address public c4c;
/** List of all participants **/
address[] public participants;
/** List of all voters **/
address[] public voters;
/** List of the winning participants */
address[] public winners;
/** List of the voters that won a prize */
address[] public luckyVoters;
/** The sum of the prizes paid out */
uint public totalPrize;
/** to efficiently check if somebody already participated **/
mapping(address=>bool) public participated;
/** to efficiently check if somebody already voted **/
mapping(address=>bool) public voted;
/** number of votes per candidate (think about it, maybe it’s better to count afterwards) **/
mapping(address=>uint) public numVotes;
/** disqualified participants**/
mapping(address => bool) public disqualified;
/** timestamp of the participation deadline**/
uint public deadlineParticipation;
/** timestamp of the voting deadline**/
uint public deadlineVoting;
/** participation fee **/
uint128 public participationFee;
/** voting fee**/
uint128 public votingFee;
/** provider fee **/
uint16 public c4cfee;
/** prize distribution **/
uint16 public prizeOwner;
uint16 public prizeReferee;
uint16[] public prizeWinners;
//rest for voters, how many?
uint8 public nLuckyVoters;

/** fired when contest is closed **/
event ContestClosed(uint prize, address[] winners, address[] votingWinners);

/** sets owner, referee, c4c, prizes (in percent with two decimals), deadlines **/
function Contest() payable{
c4c = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;
c4cfee = 1000;
owner = msg.sender;

deadlineParticipation=1485995280;
deadlineVoting=1486600080;
participationFee=70000000000000000;
votingFee=7000000000000000;
prizeOwner=1000;
prizeReferee=0;
prizeWinners.push(8000);
nLuckyVoters=1;


uint16 sumPrizes = prizeOwner;
for(uint i = 0; i < prizeWinners.length; i++) {
sumPrizes += prizeWinners[i];
}
if(sumPrizes>10000) 
throw;
else if(sumPrizes<10000 && nLuckyVoters == 0)//make sure everything is paid out
throw;
}
 /**
     * adds msg.sender to the list of participants if the deadline was not yet met and the participation fee is paid
     * */
    function participate() payable {
        if(msg.value<participationFee)
            throw;
        else if (now >= deadlineParticipation) 
            throw;
        else if (participated[msg.sender])
            throw;
        else {
            participants.push(msg.sender);
            participated[msg.sender]=true;
            //if the winners list is smaller than the prize list, push the candidate
            if(winners.length < prizeWinners.length) winners.push(msg.sender);
        }    
    }

    /**
     * adds msg.sender to the voter list and updates vote related mappings if msg.value is enough, the vote is done between the deadlines and the voter didn't vote already
     */
    function vote(address candidate) payable{
        if(msg.value<votingFee) 
            throw;
        else if(now<deadlineParticipation || now >=deadlineVoting)
            throw;
        else if(voted[msg.sender])//voter did already vote
            throw;
        else{
            voters.push(msg.sender);
            voted[msg.sender] = true;
            numVotes[candidate]++;
            
            for(var i = 0; i<winners.length; i++){//from the first to the last
                if(winners[i]==candidate) break;//the candidate remains on the same position
                if(numVotes[candidate]>numVotes[winners[i]]){//candidate is better
                    //else, usually winners[i+1]==candidate, because usually a candidate just improves by one ranking
                    //however, if there are multiple candidates with the same amount of votes, it might be otherwise
                    for(var j = getCandidatePosition(candidate, i+1); j>i; j--){
                       winners[j]=winners[j-1];  
                    }
                    winners[i]=candidate;
                    break;
                }
            }
        }
    }
  
  function getCandidatePosition(address candidate, uint startindex) internal returns (uint){
    for(uint i = startindex; i < winners.length; i++){
      if(winners[i]==candidate) return i;
    }
    return winners.length-1;
  }
    
    /**
     * only called by referee, does not delete the participant from the list, but keeps him from winning (because of inappropiate content), only in contract if a referee exists
     * */
    function disqualify(address candidate){
        if(msg.sender==referee)
            disqualified[candidate]=true;
    }
    
    /**
     * only callable by referee. in case he disqualified the wrong participant
     * */
    function requalify(address candidate){
        if(msg.sender==referee)
            disqualified[candidate]=false;
    }
    
    /**
     * only callable after voting deadline, distributes the prizes, fires event?
     * */
    function close(){
        // if voting already ended and the contract has not been closed yet
        if(now>=deadlineVoting&&totalPrize==0){
            determineLuckyVoters();
            if(this.balance>10000) distributePrizes(); //more than 10000 wei so every party gets at least 1 wei (if s.b. gets 0.01%)
            ContestClosed(totalPrize, winners, luckyVoters);
        }
    }
    
    /**
     * Determines the winning voters
     * */
    function determineLuckyVoters() constant {
        if(nLuckyVoters>=voters.length)
            luckyVoters = voters;
        else{
             mapping (uint => bool) chosen;
            uint nonce=1;
     
            uint rand;
            for(uint i = 0; i < nLuckyVoters; i++){
                do{
                    rand = randomNumberGen(nonce, voters.length);
                    nonce++;
                }while (chosen[rand]);
                
                chosen[rand] = true;
                luckyVoters.push(voters[rand]);
            }
        }
    }
    
    /**
     * creates a random number in [0,range)
     * */
    function randomNumberGen(uint nonce, uint range) internal constant returns(uint){
        return uint(block.blockhash(block.number-nonce))%range;
    }
    
    /**
     * distribites the contract balance amongst the creator, wthe winners, the lucky voters, the referee and the provider
     * */
    function distributePrizes() internal{
        
        if(!c4c.send(this.balance/10000*c4cfee))  throw;
        totalPrize = this.balance;
        if(prizeOwner!=0 && !owner.send(totalPrize/10000*prizeOwner)) throw;
        if(prizeReferee!=0 && !referee.send(totalPrize/10000*prizeReferee)) throw;
        for (uint8 i = 0; i < winners.length; i++)
            if(prizeWinners[i]!=0 && !winners[i].send(totalPrize/10000*prizeWinners[i])) throw;
        if (luckyVoters.length>0){//if anybody voted
            if(this.balance>luckyVoters.length){//if there is ether left to be distributed amongst the lucky voters
                uint amount = this.balance/luckyVoters.length;
                for(uint8 j = 0; j < luckyVoters.length; j++)
                    if(!luckyVoters[j].send(amount))  throw;
            }
        }
        else if(!owner.send(this.balance)) throw;//if there is no lucky voter, give remainder to the owner
    }
    
    /**
     * returns the total vote count
     * */
    function getTotalVotes() constant returns(uint){
        return voters.length;
    }
}",False,False,False
0x7d3ae940eb73dc9131758ad2e326c7d863b0916a,44: front running;,True,False,False,"contract Doubler {

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

	uint public payoutIdx = 0;
	uint public collectedFees = 0;
	uint balance = 0;

  // only owner modifier
	address public owner;
    modifier onlyowner { if (msg.sender == owner) _ }

  // contract Constructor
    function Doubler() {
        owner = msg.sender;
    }

 // fallback function
    function(){
        enter();
    }

	function enter(){
      // collect fee
        uint fee = msg.value / 40; // 2.5 % fee
        collectedFees += fee;

      // add a new participant
		uint idx = participants.length;
        participants.length++;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value - fee;

      // update available balance
      	balance += msg.value - fee;
      	
	  // if there are enough ether on the balance we can pay out to an earlier participant
	  	uint txAmount = participants[payoutIdx].amount * 2;
        if(balance >= txAmount){
        	if(!participants[payoutIdx].etherAddress.send(txAmount)) throw;

            balance -= txAmount;
            payoutIdx++;
        }
    }

    function collectFees() onlyowner {
        if(collectedFees == 0)return;

        if(!owner.send(collectedFees))throw;
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,True,False
0x2dc0170450e66af2d3f5c56aa0b20ec4a254902e,FP,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract MyAdvancedToken is owned, token {

    uint256 public buyPrice;
    uint256 public totalSupply;
    uint256 public claim;
    bool public claimStatus;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address centralMinter
    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newBuyPrice) onlyOwner {
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    /* Insurance claim data */
    
    function setClaim(uint256 _claim)  onlyOwner{
        claim = _claim;
    }
    
    function claimAmount() returns (uint256) {
        return claim;
    }
    
    function setClaimStatus(bool _status) onlyOwner {
        claimStatus = _status;
    }
    
    function getClaimStatus() returns (bool) {
        return claimStatus;
    }
    
    /* Sell position and collect claim*/

    function sell(uint256 amount) {
        if(getClaimStatus() == false) throw;                // checks if party can make a claim
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(claim)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}",False,True,False
0x362bb67f7fdbdd0dbba4bce16da6a284cf484ed6,94: time manipulation; 106: time manipulation;,True,False,True,"/**
*	Crowdsale for Edgeless Tokens.
*	Raised Ether will be stored safely at a multisignature wallet and returned to the ICO in case the funding goal is not reached,
*   allowing the investors to withdraw their funds.
*	Author: Julia Altenried
**/

pragma solidity ^0.4.6;

contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success){}
	function burn() {}
}

contract SafeMath {
  //internals

  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}


contract Crowdsale is SafeMath {
    /* tokens will be transfered from this address */
	address public beneficiary = 0x003230bbe64eccd66f62913679c8966cf9f41166;
	/* if the funding goal is not reached, investors may withdraw their funds */
	uint public fundingGoal = 50000000;
	/* the maximum amount of tokens to be sold */
	uint public maxGoal = 440000000;
	/* how much has been raised by crowdale (in ETH) */
	uint public amountRaised;
	/* the start date of the crowdsale */
	uint public start = 1488294000;
	/* the number of tokens already sold */
	uint public tokensSold;
	/* there are different prices in different time intervals */
	uint[4] public deadlines = [1488297600, 1488902400, 1489507200,1490112000];
	uint[4] public prices = [833333333333333, 909090909090909,952380952380952, 1000000000000000];
	/* the address of the token contract */
	token public tokenReward;
	/* the balances (in ETH) of all investors */
	mapping(address => uint256) public balanceOf;
	/* indicated if the funding goal has been reached. */
	bool fundingGoalReached = false;
	/* indicates if the crowdsale has been closed already */
	bool crowdsaleClosed = false;
	/* the multisignature wallet on which the funds will be stored */
	address msWallet = 0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5;
	/* notifying transfers and the success of the crowdsale*/
	event GoalReached(address beneficiary, uint amountRaised);
	event FundTransfer(address backer, uint amount, bool isContribution, uint amountRaised);



    /*  initialization, set the token address */
    function Crowdsale( ) {
        tokenReward = token(0x08711d3b02c8758f2fb3ab4e80228418a7f8e39c);
    }

    /* invest by sending ether to the contract. */
    function () payable{
		if(msg.sender != msWallet) //do not trigger investment if the multisig wallet is returning the funds
        	invest(msg.sender);
    }

    /* make an investment
    *  only callable if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet.
    *  the current token price is looked up and the corresponding number of tokens is transfered to the receiver.
    *  the sent value is directly forwarded to a safe multisig wallet.
    *  this method allows to purchase tokens in behalf of another address.*/
    function invest(address receiver) payable{
    	uint amount = msg.value;
    	uint price = getPrice();
    	if(price > amount) throw;
		uint numTokens = amount / price;
		if (crowdsaleClosed||now<start||safeAdd(tokensSold,numTokens)>maxGoal) throw;
		if(!msWallet.send(amount)) throw;
		balanceOf[receiver] = safeAdd(balanceOf[receiver],amount);
		amountRaised = safeAdd(amountRaised, amount);
		tokensSold+=numTokens;
		if(!tokenReward.transferFrom(beneficiary, receiver, numTokens)) throw;
        FundTransfer(receiver, amount, true, amountRaised);
    }

    /* looks up the current token price */
    function getPrice() constant returns (uint256 price){
        for(var i = 0; i < deadlines.length; i++)
            if(now<deadlines[i])
                return prices[i];
        return prices[prices.length-1];//should never be returned, but to be sure to not divide by 0
    }

    modifier afterDeadline() { if (now >= deadlines[deadlines.length-1]) _; }

    /* checks if the goal or time limit has been reached and ends the campaign */
    function checkGoalReached() afterDeadline {
        if (tokensSold >= fundingGoal){
            fundingGoalReached = true;
            tokenReward.burn(); //burn remaining tokens but 60 000 000
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /* allows the funders to withdraw their funds if the goal has not been reached.
	*  only works after funds have been returned from the multisig wallet. */
	function safeWithdrawal() afterDeadline {
		uint amount = balanceOf[msg.sender];
		if(address(this).balance >= amount){
			balanceOf[msg.sender] = 0;
			if (amount > 0) {
				if (msg.sender.send(amount)) {
					FundTransfer(msg.sender, amount, false, amountRaised);
				} else {
					balanceOf[msg.sender] = amount;
				}
			}
		}
    }

}",False,False,True
0x3eab9a2fa76f16cdc46e707ff928f7995886dee0,143: arithmetic; 144: arithmetic;,True,False,False,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract MyAdvancedToken is owned, token {

    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address centralMinter
    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}",False,True,False
0x93eeabbe86d19bda39ea2d1049baf2c0878ded23,136: bas randomness;,True,False,False,"pragma solidity ^0.4.9;

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract DiceRoll is owned {
	uint public minBet = 10 finney;
	uint public maxBet = 2 ether;
	
    enum GameState {
		InProgress,
		PlayerWon,
		PlayerLose
	}
	
	event logStr(
        string str
    );
	event log8(
        uint8 value
    );
	event log256(
        uint value
    );
	event logClassic(
        string str,
        uint8 value
    );
	event logState(
        string str,
        GameState state
    );
	
	struct Game {
		address player;
		uint bet;
		uint8 chance;
		GameState state;
		uint8 seed;
	}

	mapping (address => Game) public games;
	
	modifier gameIsNotInProgress() {
		if (gameInProgress(games[msg.sender])) {
			throw;
		}
		_;
	}
	
	modifier betValueIsOk() {
		if (msg.value < minBet || msg.value > maxBet) {
			throw; // incorrect bet
		}
		_;
	}
	
	function gameInProgress(Game game)
		constant
		private
		returns (bool)
	{
		if (game.player == 0) {
			return false;
		}
		if (game.state == GameState.InProgress) {
			return true;
		} else {
			return false;
		}
	}
	
	// starts a new game
	function roll(uint8 chance) 
	    public 
	    payable 
	    gameIsNotInProgress
	    betValueIsOk 
	{
		if (gameInProgress(games[msg.sender])) {
			throw;
		}
        
		Game memory game = Game({
			player: msg.sender,
			bet: msg.value,
			chance: chance,
			state: GameState.InProgress,
			seed: 3,
		});
        
		games[msg.sender] = game;
		
		uint rnd = randomGen(msg.sender, games[msg.sender].seed);
		uint valueMax = chance*100;
		uint bet = msg.value;
		uint payout = bet*100/games[msg.sender].chance;
        uint profit = payout - bet;
        log256(now);
        log256(payout);
        log256(profit);
        log256(bet);
        log8(chance);
		
		if(rnd > valueMax){
		    log8(0);
		    games[msg.sender].state = GameState.PlayerLose;
        } else {
            log8(1);
		     games[msg.sender].state = GameState.PlayerWon;
		     if(!msg.sender.send(payout)) {
	            logStr(""Money is not send."");
	        }
        }
        
        //logState(""state:"", games[msg.sender].state);
	}
	
	function randomGen(address player, uint8) internal returns (uint8) {
		uint b = block.number;
		uint timestamp = block.timestamp;
		return uint8(uint256(keccak256(block.blockhash(b), player, timestamp)) % 10000);
	}
	
	function getGameState() public constant returns (GameState) {
		Game memory game = games[msg.sender];
        
		if (game.player == 0) {
			// game doesn't exist
			throw;
		}

		return game.state;
	}
	
	function getGameChance() public constant returns (uint8) {
		Game memory game = games[msg.sender];
        
		if (game.player == 0) {
			// game doesn't exist
			throw;
		}

		return game.chance;
	}
}",False,True,True
0xaf2b8e6114da000176c506f77b173251c16b511d,FP,True,False,True,"/**
*	This investment contract accepts investments, which will be sent to the Edgeless ICO contract as soon as it starts buy calling buyTokens().
*   This way investors do not have to buy tokens in time theirselves and still do profit from the power hour offer.
*	Investors may withdraw their funds anytime if they change their mind as long as the tokens have not yet been purchased.
*	Author: Julia Altenried
**/

pragma solidity ^0.4.8;

contract Crowdsale {
	function invest(address receiver) payable{}
}

contract SafeMath {
  //internals
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}

contract Investment is SafeMath{
	Crowdsale public ico;
	address[] public investors;
	mapping(address => uint) public balanceOf;
	mapping(address => bool) invested;


	/** constructs an investment contract for an ICO contract **/
	function Investment(){
		ico = Crowdsale(0x362bb67f7fdbdd0dbba4bce16da6a284cf484ed6);
	}

	/** make an investment **/
	function() payable{
		if(msg.value > 0){
			//only checking balance of msg.sender would not suffice, since an attacker could fill up the array by
			//repeated investment and withdrawal, which would require a huge number of buyToken()-calls when the ICO ends
			if(!invested[msg.sender]){
				investors.push(msg.sender);
				invested[msg.sender] = true;
			}
			balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.value);
		}
	}



	/** buys tokens in behalf of the investors by calling the ico contract
	*   starting with the investor at index from and ending with investor at index to.
	*   This function will be called as soon as the ICO starts and as often as necessary, until all investments were made. **/
	function buyTokens(uint from, uint to){
		uint amount;
		if(to>investors.length)
			to = investors.length;
		for(uint i = from; i < to; i++){
			if(balanceOf[investors[i]]>0){
				amount = balanceOf[investors[i]];
				delete balanceOf[investors[i]];
				ico.invest.value(amount)(investors[i]);
			}
		}
	}

	/** In case an investor wants to retrieve his or her funds he or she can call this function.
	*   (only possible before tokens are bought) **/
	function withdraw(){
		uint amount = balanceOf[msg.sender];
		balanceOf[msg.sender] = 0;
		if(!msg.sender.send(amount))
			balanceOf[msg.sender] = amount;
	}

	/** returns the number of investors **/
	function getNumInvestors() constant returns(uint){
		return investors.length;
	}

}",Significant,False,False
0xc7dfe4304bd4c9dd6ed414443c077fc06501e9ac,91: unchecked; 90: access control; 105: arithmetic;,True,False,False,"pragma solidity ^0.4.0;

//https://github.com/nexusdev/erc20/blob/master/contracts/erc20.sol

contract ERC20Constant {
    function balanceOf( address who ) constant returns (uint value);
}
contract ERC20Stateful {
    function transfer( address to, uint value) returns (bool ok);
}
contract ERC20Events {
    event Transfer(address indexed from, address indexed to, uint value);
}
contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

// contract can sell tokens for ETH
// prices are in amount of wei per batch of token units

contract TokenTrader is owned {

    address public asset;       // address of token
    uint256 public sellPrice;   // contract sells lots of tokens at this price
    uint256 public units;       // lot size (token-wei)

    bool public sellsTokens;    // is contract selling

    event ActivatedEvent(bool sells);
    event UpdateEvent();

    function TokenTrader (
        address _asset, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens
        )
    {
          asset         = _asset; 
          sellPrice    = _sellPrice;
          units         = _units; 
          sellsTokens   = _sellsTokens;

          ActivatedEvent(sellsTokens);
    }

    // modify trading behavior
    function activate (
        bool    _sellsTokens
        ) onlyOwner
    {
          sellsTokens   = _sellsTokens;

          ActivatedEvent(sellsTokens);
    }

    // allow owner to remove trade token
    function withdrawAsset(uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(asset).transfer(owner,_value);
        UpdateEvent();
    }

    // allow owner to remove arbitrary tokens
    // included just in case contract receives wrong token
    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok)
    {
        return ERC20(_token).transfer(owner,_value);
        UpdateEvent();
    }

    // allow owner to remove ETH
    function withdraw(uint256 _value) onlyOwner returns (bool ok)
    {
        if(this.balance >= _value) {
            return owner.send(_value);
        }
        UpdateEvent();
    }

    //user buys token with ETH
    function buy() payable {
        if(sellsTokens || msg.sender == owner) 
        {
            uint order   = msg.value / sellPrice; 
            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;

            if(order > can_sell)
            {
                uint256 change = msg.value - (can_sell * sellPrice);
                order = can_sell;
                if(!msg.sender.send(change)) throw;
            }

            if(order > 0) {
                if(!ERC20(asset).transfer(msg.sender,order * units)) throw;
            }
            UpdateEvent();
        }
        else if(!msg.sender.send(msg.value)) throw;  // return user funds if the contract is not selling
    }

    // sending ETH to contract sells GNT to user
    function () payable {
        buy();
    }
}

// This contract deploys TokenTrader contracts and logs the event
// trade pairs are identified with sha3(asset,units)

contract TokenTraderFactory {

    event TradeListing(bytes32 bookid, address owner, address addr);
    event NewBook(bytes32 bookid, address asset, uint256 units);

    mapping( address => bool ) _verify;
    mapping( bytes32 => bool ) pairExits;

    function verify(address tradeContract)  constant returns (
        bool valid,
        address asset, 
        uint256 sellPrice, 
        uint256 units,
        bool    sellsTokens
        ) {

            valid = _verify[tradeContract];

            if(valid) {
                TokenTrader t = TokenTrader(tradeContract);

                asset = t.asset();
                sellPrice = t.sellPrice();
                units = t.units();
                sellsTokens = t.sellsTokens();
            }

    }

    function createTradeContract(       
        address _asset, 
        uint256 _sellPrice, 
        uint256 _units,
        bool    _sellsTokens
        ) returns (address) 
    {
        if(_units == 0) throw;              // can't sell zero units

        address trader = new TokenTrader (
                     _asset, 
                     _sellPrice, 
                     _units,
                     _sellsTokens);

        var bookid = sha3(_asset,_units);

        _verify[trader] = true; // record that this factory created the trader

        TokenTrader(trader).transferOwnership(msg.sender); // set the owner to whoever called the function

        if(pairExits[bookid] == false) {
            pairExits[bookid] = true;
            NewBook(bookid, _asset, _units);
        }

        TradeListing(bookid,msg.sender,trader);
    }

    function () {
        throw;     // Prevents accidental sending of ether to the factory
    }
}",False,True,False
0x5b2ff75d7eaa47db475707dae12a688102ef4290,72: Arithmetic; 30: unchecked; 32:unchecked; 83: unchecked; 75: unchecked; 106: unchecked; 117: unchecked;,True,False,True,"//Simple Msg XChange Registrar (does not provide validateion!)
contract Message {
	address public registrar;	
	address public from;
	address public to;
	string public hash_msg;
	string public hash_ack;
	uint256 public timestamp_msg;
	uint256 public timestamp_ack;
	
	
	function Message(address _registrar,address _from,address _to,string _hash_msg) {
		registrar=_registrar;
		from=_from;
		to=_to;
		hash_msg=_hash_msg;
		timestamp_msg=now;
	}
	
	function ack(string _hash) {
		if(msg.sender!=to) throw;
		if(timestamp_ack>0) throw;
		hash_ack=_hash;
		timestamp_ack=now;		
	}
	
	function() {
		if(msg.value>0) {
			if(msg.sender==from) {			
				to.send(msg.value);
			} else {
				from.send(msg.value);
			}
		}
	}
	
}
contract Registrar
{
	address public registrar;		
	
	uint256 public fee_registration;
	uint256 public fee_msg;
	uint256 public cnt_registrations;
	
	struct Registration {
		address adr;
		string hash;
		string gnid;
	}	
	
	mapping(address=>Registration) public regadr;	
	mapping(address=>Message[]) public msgs;
	mapping(address=>Message[]) public sent;
	mapping(address=>bool) public preregister;	
	
	Registration[] public regs;
	
	function Registrar() {
		registrar=msg.sender;
	}
	
	function register(string hash) {
		updateRegistration(hash,'');		
	}
	
	function unregister() {
		delete regadr[msg.sender];
	}
	
	function updateRegistration(string hash,string gnid) {		
		if((msg.value>=fee_registration)||(preregister[msg.sender])) {			
			regadr[msg.sender]=Registration(msg.sender,hash,gnid);
			regs.push(regadr[msg.sender]);
			if(fee_registration>0) registrar.send(this.balance);
			preregister[msg.sender]=false;
			cnt_registrations++;
		} else throw;
	}
	
	function preRegister(address preReg) {
		if(msg.sender!=registrar) throw;
		preReg.send(msg.value);		
		preregister[preReg]=true;
	}
	
	function getMsgs() returns (Message[]) {
		return msgs[msg.sender];	
	}
	
	function setRegistrationPrice(uint256 price) {
		if(msg.sender!=registrar) throw;
		fee_registration=price;
	}
	
	function setMsgPrice(uint256 price) {
		if(msg.sender!=registrar) throw;
		fee_msg=price;
	}
	
	function sendMsg(address to,string hash) {
		if(msg.value>=fee_msg) {	
			    Message m = new  Message(this,msg.sender,to,hash);
				msgs[to].push(m);	
			    sent[msg.sender].push(m);
			if(fee_msg>0) registrar.send(this.balance);
		} else throw;		
	}
	
	function ackMsg(uint256 msgid,string hash) {
		Message message =Message(msgs[msg.sender][msgid]);
		message.ack(hash);
	}
	
	function() {
		if(msg.value>0) {
			registrar.send(msg.value);
		}
	}
}",False,False,False
0x6a6581a884c4729586479307e5694bf836617517,26: bad randomness;,True,False,False,"// DAO>9000 (http://dao9000.com) under CC0

contract Dao9000 {
    string message; //This is variable is first for easier interaction with outside world (offset 0x0), contains latest member message
    address[] public members;

    function Dao9000 () {
        members.push (msg.sender); //The contact owner is added as the first member
        message = ""Message not yet defined"";
    }
    
    //These two functions are for easier external interaction via api.etherscan.io:
    function getMembers () constant returns (uint256 retVal) {
        return members.length;
    }
    
    function getMessage () constant returns (string retVal) {
        return message;
    }
    
    //This is the default function, this is called when normal transaction is made
    function () {
        //Since this is a DAO parody, we really do not let people invest more than 1.5 ETH max.
        if (msg.value < 1500000000000000000 && msg.value > 1) {
            //RNG happens here: for the ""seed"" hash of the previous block is taken, and current timestamp is added
            uint256 randomIndex = (uint256(block.blockhash(block.number-1)) + now) % members.length;
            if (members[randomIndex].send(msg.value)) {
                if (msg.data.length > 0)
                    message = string(msg.data); //If additional message is defined, we save it here
                members.push (msg.sender); //After a successful transaction, new member is added, multiple entries for same member are permitted
            } else {
                throw;
            }
        } else {
            throw;
        }
    }
}",False,True,True
0x15e745a2e3b677ec6421291b212d3917b3738dee,10: DOS;,True,False,True,"contract Multisend {
    mapping(address => uint) public balances;
    mapping(address => uint) public nonces;

    
    function send(address[] addrs, uint[] amounts, uint nonce) {
        if(addrs.length != amounts.length || nonce != nonces[msg.sender]) throw;
        uint val = msg.value;
        
        for(uint i = 0; i<addrs.length; i++){
            if(val < amounts[i]) throw;
            
            if(!addrs[i].send(amounts[i])){
                balances[addrs[i]] += amounts[i];
            }
            val -= amounts[i];
        }
        
        if(!msg.sender.send(val)){
            balances[msg.sender] += val;
        }
        nonces[msg.sender]++;
    }
    
    function withdraw(){
        uint balance = balances[msg.sender];
        balances[msg.sender] = 0;
        if(!msg.sender.send(balance)) throw;
    }
    
    function(){
        withdraw();
    }
}",False,False,False
0x705f04a4f1e7a1e23caea390b8903bd43d96e18e,FP,True,False,False,"contract mortal {
    address private owner;
    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }
    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

contract EtherPennySlots is mortal {
    address private hotAccount = 0xD837ACd68e7dd0A0a9F03d72623d5CE5180e3bB8;
    address public lastWinner;
    address[]  private currentTicketHolders;
    
    function placeWager() {
       if (msg.value > 0 finney && msg.value < 51 finney) {
            uint i = 0;
            for (i = 0; i < msg.value; i++){
                currentTicketHolders.length++;
                currentTicketHolders[currentTicketHolders.length-1] = msg.sender; 
            }
                       
            if (this.balance >= 601 finney) {
                uint nr_tickets = currentTicketHolders.length;
                uint randomTicket = block.number % nr_tickets;
                address randomEntry = currentTicketHolders[randomTicket];
                if (hotAccount.send(100 finney) && randomEntry.send(500 finney)) {
                    lastWinner = randomEntry;
                    currentTicketHolders.length = 0;
                }
            } 
        }
    }
}",False,False,True
0x02e01e9a73ed2cb24b32628c935256e455b0a078,83: Unchecked; 64: front running;,True,False,False,"/*

Last contributor before the deadline gets all ether, stored in the contract!
Try your luck!

var raceAddress = ""0x02e01e9a73ed2cb24b32628c935256e455b0a078 "";
var raceftwContract = web3.eth.contract([{""constant"":false,""inputs"":[],""name"":""getCurrentWinner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""claimReward"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""getDisclaimer"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""getRaceEndBlock"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""inputs"":[],""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""newWinner"",""type"":""address""}],""name"":""LastContributorChanged"",""type"":""event""}]);
var raceftw = raceftwContract.at(raceAddress);

console.log(""current winner: "", raceftw.getCurrentWinner.call());
console.log(""race ends at block: "", raceftw.getRaceEndBlock.call(), "" current block:"", eth.blockNumber);
console.log(""current balance: "", web3.fromWei(eth.getBalance(raceAddress), ""ether""));



//To participate in the race:
eth.sendTransaction({from:<your address>, to:""0x02e01e9a73ed2cb24b32628c935256e455b0a078 "", value:web3.toWei(10, ""finney""), gas:50000});

//The winner can claim their reward by sending the following transaction:
raceftw.claimReward.sendTransaction({from:<your address>, gas:50000})

*/
contract RaceFTW {
    
    /* Disclaimer */
    string disclaimer = ""Copyright (c) 2016 \""The owner of this contract\"" \nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \""Software\""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."";
    
    function getDisclaimer() returns (string) {
        return disclaimer;
    }
    
    address lastContributor;
    uint fixedContribution = 10 finney;
    
    uint raceEnds = 0;
    
    // number of blocks. roughly 3 months at the contract creation blocks rate
    uint RACE_LENGTH = 555555;
    
    event LastContributorChanged(address newWinner);
    
    function RaceFTW () {
        raceEnds = block.number + RACE_LENGTH;
    }
    
    function getRaceEndBlock() returns (uint) {
        return raceEnds;
    }
    
    function getCurrentWinner() returns (address) {
        return lastContributor;
    }
    
    function () {
        //refund if the race ended
        if (block.number > raceEnds) {
            throw;
        }
        //refund if sent amount not equal to 1 finney
        if (msg.value != fixedContribution) {
            throw;
        }
        //raise event if needed
        if (lastContributor != msg.sender) {
            LastContributorChanged(msg.sender);
        }
        
        //change the last contributor
        lastContributor = msg.sender;
    }
    
    
    function claimReward() {
        //only lastContributor can claim
        if (msg.sender != lastContributor) {
            throw;
        }
        //refund if race is not over yet
        if (block.number < raceEnds) {
            throw;
        }
        if (this.balance > 0) {
            lastContributor.send(this.balance);
        }
    }
}",False,True,True
0x5A5eFF38DA95b0D58b6C616f2699168B480953C9,208: arithmetic; 199: time manipulation;,True,False,False,"// A life-log, done for Charlyn Greeff, born 18 April 2016 @ 15h30 (1460993400)
//    Mother: Mirana Hotz, 16 December 1977 (251078400)
//    Father: Jaco Greeff, 11 June 1973 (108604800)
//
// version: 1.0.0
// source: https://github.com/jacogr/ethcontracts/tree/master/src/LifeLog

contract CharlyLifeLog {
  // allow a maximum 20% withdrawal at any time
  uint private constant MAX_WITHDRAW_DIV = 5; // 100/20

  // allow one withdrawal every 6 months/180 days
  uint private constant WITHDRAW_INTERVAL = 180 days;

  // all the actual events that can be created
  event LogDonation(address indexed by, uint loggedAt, uint amount);
  event LogWithdrawal(address indexed by, uint loggedAt, uint amount);
  event LogPersonNew(address indexed by, uint loggedAt, uint index);
  event LogPersonUpdate(address indexed by, uint loggedAt, uint index, string field);
  event LogWhitelistAdd(address indexed by, uint loggedAt, address addr);
  event LogWhitelistRemove(address indexed by, uint loggedAt);
  event LogEvent(address indexed by, uint loggedAt, uint when, string description);

  // a structure describing a person
  struct Person {
    bool active;
    uint activatedAt;
    uint deactivatedAt;
    int dateOfBirth;
    int dateOfDeath;
    string name;
    string relation;
  }

  // next time whitelist address is allowed to get some funds
  uint public nextWithdrawal = now + WITHDRAW_INTERVAL;

  // totals of received and withdrawn amounts
  uint public totalDonated = 0;
  uint public totalWithdrawn = 0;

  // people in the life of ([0] == 'self')
  Person[] public people;

  // donations received
  mapping(address => uint) public donations;

  // whitelisted modifier accounts
  mapping(address => bool) public whitelist;

  // modifier to allow only the whitelisted addresses
  modifier isOnWhitelist {
    // if not in the whitelist, throw error
    if (!whitelist[msg.sender]) {
      throw;
    }

    // if any value attached, don't accept it
    if (msg.value > 0) {
      throw;
    }

    // original code executes in here
    _
  }

  // construct a lifelog for this specific person
  function CharlyLifeLog(string name, int dateOfBirth) {
    // creator should go on the whitelist
    whitelist[msg.sender] = true;

    // add the first person
    personAdd(name, dateOfBirth, 0, 'self');

    // any donations?
    if (msg.value > 0) {
      donate();
    }
  }

  // log an event
  function log(string description, uint _when) public isOnWhitelist {
    // infer timestamp or use specified
    uint when = _when;
    if (when == 0) {
      when = now;
    }

    // create the event
    LogEvent(msg.sender, now, when, description);
  }

  // add a specific person
  function personAdd(string name, int dateOfBirth, int dateOfDeath, string relation) public isOnWhitelist {
    // create the event
    LogPersonNew(msg.sender, now, people.length);

    // add the person
    people.push(
      Person({
        active: true,
        activatedAt: now,
        deactivatedAt: 0,
        dateOfBirth: dateOfBirth,
        dateOfDeath: dateOfDeath,
        name: name,
        relation: relation
      })
    );
  }

  // activate/deactivate a specific person
  function personUpdateActivity(uint index, bool active) public isOnWhitelist {
    // set the flag
    people[index].active = active;

    // activate/deactivate
    if (active) {
      // create the event
      LogPersonUpdate(msg.sender, now, index, 'active');

      // make it so
      people[index].activatedAt = now;
      people[index].deactivatedAt = 0;
    } else {
      // create the event
      LogPersonUpdate(msg.sender, now, index, 'inactive');

      // make it so
      people[index].deactivatedAt = now;
    }
  }

  // update a person's name
  function personUpdateName(uint index, string name) public isOnWhitelist {
    // create the event
    LogPersonUpdate(msg.sender, now, index, 'name');

    // update
    people[index].name = name;
  }

  // update a person's relation
  function personUpdateRelation(uint index, string relation) public isOnWhitelist {
    // create the event
    LogPersonUpdate(msg.sender, now, index, 'relation');

    // update
    people[index].relation = relation;
  }

  // update a person's DOB
  function personUpdateDOB(uint index, int dateOfBirth) public isOnWhitelist {
    // create the event
    LogPersonUpdate(msg.sender, now, index, 'dateOfBirth');

    // update
    people[index].dateOfBirth = dateOfBirth;
  }

  // update a person's DOD
  function personUpdateDOD(uint index, int dateOfDeath) public isOnWhitelist {
    // create the event
    LogPersonUpdate(msg.sender, now, index, 'dateOfDeath');

    // update
    people[index].dateOfDeath = dateOfDeath;
  }

  // add a whitelist address
  function whitelistAdd(address addr) public isOnWhitelist {
    // create the event
    LogWhitelistAdd(msg.sender, now, addr);

    // update
    whitelist[addr] = true;
  }

  // remove a whitelist address
  function whitelistRemove(address addr) public isOnWhitelist {
    // we can only remove ourselves, double-validate failsafe
    if (msg.sender != addr) {
      throw;
    }

    // create the event
    LogWhitelistRemove(msg.sender, now);

    // remove
    whitelist[msg.sender] = false;
  }

  // withdraw funds as/when needed
  function withdraw(uint amount) public isOnWhitelist {
    // the maximum we are allowed to take out right now
    uint max = this.balance / MAX_WITHDRAW_DIV;

    // see that we are in range and the timing matches
    if (amount > max || now < nextWithdrawal) {
      throw;
    }

    // update the event log with the action
    LogWithdrawal(msg.sender, now, amount);

    // set the next withdrawal date/time & totals
    nextWithdrawal = now + WITHDRAW_INTERVAL;
    totalWithdrawn += amount;

    // send and throw if not ok
    if (!msg.sender.send(amount)) {
      throw;
    }
  }

  // accept donations from anywhere and give credit
  function donate() public {
    // there needs to be something here
    if (msg.value == 0) {
      throw;
    }

    // update the event log with the action
    LogDonation(msg.sender, now, msg.value);

    // store the donation
    donations[msg.sender] += msg.value;
    totalDonated += msg.value;
  }

  // fallback is a donation
  function() public {
    donate();
  }
}",False,True,True
0x8f13a1d43408b6434dd10e161361386f3952d665,32: unchecked; 49: arithmetic; 55: unchecked; 65: unchecked;,True,False,True,"contract StackyGame {

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

    uint public payoutIdx = 0;
    uint public collectedFees;
    uint public balance = 0;

    address public owner;

    // simple single-sig function modifier
    modifier onlyowner { if (msg.sender == owner) _ }

    // this function is executed at initialization and sets the owner of the contract
    function Doubler() {
        owner = msg.sender;
    }

    // fallback function - simple transactions trigger this
    function() {
        enter();
    }
    
    function enter() {
        // Maximum of 1 ether allowed
        if (msg.value > 1 ether) {
            msg.sender.send(msg.value);
            return;
        }

      	// add a new participant to array
        uint idx = participants.length;
        participants.length += 1;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value;
        
        // collect fees and update contract balance
        if (idx != 0) {
            collectedFees += msg.value * 1 / 20;
            balance += msg.value;
        } else {
            // first participant has no one above him,
            // so it goes all to fees
            collectedFees += msg.value;
        }

	    // if there are enough ether on the balance we can pay out to an earlier participant
        if (balance > participants[payoutIdx].amount * 2) {
            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 20);
            participants[payoutIdx].etherAddress.send(transactionAmount);

            balance -= participants[payoutIdx].amount * 2;
            payoutIdx += 1;
        }
    }

    function collectFees() onlyowner {
        if (collectedFees == 0) return;

        owner.send(collectedFees);
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0x1F36f2249eC89266Ad4EE4351538148aaEBc72e8,109: Unchecked; 118: Unchecked; 184: Unchecked; 199: Unchecked; 203: Unchecked; 217: Unchecked; 221: Unchecked; 232: Unchecked; 243: Unchecked; 188: Arithmetic; 220: Arithmetic; 155: Time manipulation;,True,False,True,"contract euroteambet {

	struct team {
		string teamName;
		mapping(address => uint) bet;
		uint totalBet;
	}

	team[] public euroTeams;

	bool winningTeamDefined;
	uint winningTeam;

	/** Bets close at the opening day of the EuroCup: 10 June 2016 **/
	uint startCompetitionTime;

	/**  Overall amount bet **/
	uint public globalBet;

	/** Define the creator and fees collected **/
	address creator;
	uint feeCollected;

	/**
	* Constructor: Defines team and creator
	*/
	function euroteambet() {
		// Define the Teams
		team memory toCreate;
		// Post a dummy team to ensure the actual range is from 1 to 24 and not 0 to 23.
		toCreate.teamName = '';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Albania';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Austria';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Belgium';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Croatia';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Czech Republic';
		euroTeams.push(toCreate);
		toCreate.teamName = 'England';
		euroTeams.push(toCreate);
		toCreate.teamName = 'France';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Germany';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Hungary';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Iceland';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Italy';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Nothern Ireland';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Poland';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Portugal';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Republic of Ireland';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Romania';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Russia';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Slovakia';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Spain';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Sweden';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Switzerland';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Turkey';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Ukraine';
		euroTeams.push(toCreate);
		toCreate.teamName = 'Wales';
		euroTeams.push(toCreate);

		creator = msg.sender;

		winningTeamDefined = false;

		// Euro Cup starts in 4 days
		startCompetitionTime = block.timestamp + (60 * 60 * 24) * 4;

	}


	event BetFromTransaction(address indexed from, uint value);
	event CollectFromTransaction(address indexed from, uint value);	
	event BetClosedNoWinningTeam(address indexed from, uint value);	
	/**
	 * Catch-All Function: Un case of transaction received going though a Contract Function
	 * 1: Check if bets are still open
	 * 2: Check if the bet is more than 0.1 ETH
	 * 3: Divided by 1000000000000000 to have an integer (0.016 Eth to 16) and call betOnATeam
	 *    If the EeasyBet value is not correct (possible value 1 to 24), it will be throw in BetOnAteam function
	 * 4: Check if the winning team as been defined    
	 */
	function () {
		if (startCompetitionTime >= block.timestamp) {
			if (msg.value >= 100 finney) {
				BetFromTransaction(msg.sender, msg.value);
				betOnATeam((msg.value % 100 finney) / 1000000000000000);
			} else {
				msg.sender.send(msg.value);
				return;
			}
		} else if (winningTeamDefined == true) {
			CollectFromTransaction(msg.sender, msg.value);
			collectEarnings();
		} else {
			BetClosedNoWinningTeam(msg.sender, msg.value);
			if(msg.value > 0){
				msg.sender.send(msg.value);
			}
			return;
		}
	}

	/**
	 * Used to defined the winner of the Tournament
	 * 1: The winning team is updated 
	 * 2: All amount invested are gathered in globalBet
	 * 3: All balances of the winning team updated proportionally to the amount invested
	 *
	 * param      {uint  teamWinningName  The identifier of the team winning
	 */
	function setWinner(uint teamWinningID) {
		// Check if the sender is the creator and if the tournament has ended
		if (msg.sender == creator) {
			winningTeam = teamWinningID;
			winningTeamDefined = true;
		} else {
			if(msg.value > 0){
				msg.sender.send(msg.value);
			}
			return;
		}
	}


	event BetOnATeam(address indexed from, uint indexed id, uint value);
	/**
	 * Used to bet on the winner of the Tournament
	 * 1: Check if bets are still open
	 * 2: Check if the bet is more than 0.1 ETH
	 * 3: Check if the id of the team is correct (possible value 1 to 24)
	 * param      {uint}  id      The identifier of the team to bet on
	 */
	function betOnATeam(uint id) {
		if (startCompetitionTime >= block.timestamp && msg.value >= 100 finney && id >= 1 && id <= 24) {

			uint amount = msg.value;

			// Collect 3% Fee
			feeCollected += (amount * 3 / 100);
			amount -= (amount * 3 / 100);

			BetOnATeam(msg.sender, id, amount);

			euroTeams[id].bet[msg.sender] += amount;
			euroTeams[id].totalBet += amount;
			globalBet += amount;
		} else {
			if(msg.value > 0){
				msg.sender.send(msg.value);
			}
			return;
		}
	}

	/**
	* Check earnings for a specific address
	* 
	* param      address  toCheck  Address to check its earnings 
	* return     uint   Amount earned
	*/
	function checkEarnings(address toCheck) returns (uint) {
		if(msg.value > 0){
			msg.sender.send(msg.value);
		}

		if (winningTeamDefined == true) {
			return (globalBet * (euroTeams[winningTeam].bet[toCheck] / euroTeams[winningTeam].totalBet));
		} else {
			return 0;
		}
	}

	/**
	 * Only allowed the withdrawals of the fund once the Winning team is updated
	 */
	function collectEarnings() {
		if(msg.value > 0){
			msg.sender.send(msg.value);
		}
		if (winningTeamDefined == true) {
			uint earnings = (globalBet * (euroTeams[winningTeam].bet[msg.sender] / euroTeams[winningTeam].totalBet));
			msg.sender.send(earnings);
			euroTeams[winningTeam].bet[msg.sender] = 0;
		} else {
			return;
		}
	}

	/**
	* Allow the creator of the game to send balance
	* 
	* param      address  toSend  Address to receive its earnings 
	*/
	function sendEarnings(address toSend) {
		if(msg.value > 0){
			msg.sender.send(msg.value);
		}
		if (msg.sender == creator && winningTeamDefined == true) {
			uint earnings = (globalBet * (euroTeams[winningTeam].bet[toSend] / euroTeams[winningTeam].totalBet));
			toSend.send(earnings);
			euroTeams[winningTeam].bet[toSend] = 0;
		} else {
			return;
		}
	}

	/**
	* Allow the creator to collect the 3% Fee
	*/
	function collectFee() {
		msg.sender.send(msg.value);
		if (msg.sender == creator) {
			creator.send(feeCollected);
			feeCollected = 0;
		} else {
			return;
		}
	}

}",False,True,True
0xeb17adcc8cf24d2d6813f50f647b613df01014a2,"60: arithmetic; 119: time manipulaltion,",True,False,False,"contract dEthereumlotteryNet {
	/*
		dEthereumlotteryNet
		Coded by: iFA
		https://d.ethereumlottery.net
		ver: 1.0.0
	*/
	address private owner;
	uint private constant fee = 5;
	uint private constant investorFee = 50;
	uint private constant prepareBlockDelay = 4;
	uint private constant rollLossBlockDelay = 30;
	uint private constant investUnit = 1 ether;
	uint private constant extraDifficulty = 130;
	uint private constant minimumRollPrice = 10 finney;
	uint private constant minimumRollDiv = 10;
	uint private constant difficultyMultipler = 1000000;
	uint private constant investMinDuration = 1 days;
	
    bool public ContractEnabled = true;
    uint public ContractDisabledBlock;
	uint public Jackpot;
	uint public RollCount;
	uint public JackpotHits;
	
	uint private jackpot_;
	uint private extraJackpot_;
	uint private feeValue;
	
	struct rolls_s {
		uint blockNumber;
		bytes32 extraHash;
		bool valid;
		uint value;
		uint game;
	}
	
	mapping(address => rolls_s[]) private players;
	
	struct investors_s {
		address owner;
		uint value;
		uint balance;
		bool live;
		bool valid;
		uint timestamp;
	}
	
	investors_s[] investors;
	
	string constant public Information = ""https://d.ethereumlottery.net"";
	
	function ChanceOfWinning(uint Bet) constant returns(uint Rate) {
		Rate = getDifficulty(Bet);
		if (Bet < minimumRollPrice) { Rate = 0; }
		if (jackpot_/minimumRollDiv < Bet) { Rate = 0; }
	}
	function BetPriceLimit() constant returns(uint min,uint max) {
		min = minimumRollPrice;
		max = jackpot_/minimumRollDiv;
	}
	function Investors(uint id) constant returns(address Owner, uint Investment, uint Balance, bool Live) {
		if (id < investors.length) {
			Owner = investors[id].owner;
			Investment = investors[id].value;
			Balance = investors[id].balance;
			Live = investors[id].live;
		} else {
			Owner = 0;
			Investment = 0;
			Balance = 0;
			Live = false;
		}
	}
	function dEthereumlotteryNet() {
		owner = msg.sender;
	}
	function Invest() OnlyEnabled external {
		uint value_ = msg.value;
		if (value_ < investUnit) { throw; }
		if (value_ % investUnit > 0) { 
			if (msg.sender.send(value_ % investUnit) == false) { throw; } 
			value_ = value_ - (value_ % investUnit);
		}
		for ( uint a=0 ; a < investors.length ; a++ ) {
			if (investors[a].valid == false) {
				newInvest(a,msg.sender,value_);
				return;
			}
		}
		investors.length++;
		newInvest(investors.length-1,msg.sender,value_);
	}
	function newInvest(uint investorsID, address investor, uint value) private {
		investors[investorsID].owner = investor;
		investors[investorsID].value = value;
		investors[investorsID].balance = 0;
		investors[investorsID].valid = true;
		investors[investorsID].live = true;
		investors[investorsID].timestamp = now + investMinDuration;
		jackpot_ += value;
		setJackpot();
	}
	function GetMyInvestFee() external {
		reFund();
		uint balance_;
		for ( uint a=0 ; a < investors.length ; a++ ) {
			if (investors[a].owner == msg.sender && investors[a].valid == true) {
				balance_ = investors[a].balance;
				investors[a].valid = false;
			}
		}
		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }
	}
	function CancelMyInvest() external {
		reFund();
		uint balance_;
		for ( uint a=0 ; a < investors.length ; a++ ) {
			if (investors[a].owner == msg.sender && investors[a].valid == true && investors[a].timestamp < now) {
				if (investors[a].live == true) {
					balance_ = investors[a].value + investors[a].balance;
					jackpot_ -= investors[a].value;
					delete investors[a];
				} else {
					balance_ = investors[a].balance;
					delete investors[a];
				}
			}
		}
		setJackpot();
		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }
	}
	function setJackpot() private {
		Jackpot = extraJackpot_ + jackpot_;
	}
	function DoRoll() external {
		reFund();
		uint value_;
		bool found;
		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {
			if (players[msg.sender][a].valid == true) {
			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {
			        uint feeValue_ = players[msg.sender][a].value/2;
			        feeValue += feeValue_;
			        investorAddFee(players[msg.sender][a].value - feeValue_);
					delete players[msg.sender][a];
					found = true;
					continue;
			    }
				if (ContractEnabled == false || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {
					value_ += players[msg.sender][a].value;
					delete players[msg.sender][a];
					found = true;
					continue;
				}
				if (players[msg.sender][a].blockNumber < block.number) {
					value_ += makeRoll(a);
					delete players[msg.sender][a];
					found = true;
					continue;
				}
			}
		}
		if (value_ > 0) { if (msg.sender.send(value_) == false) { throw; } }
		if (found == false) { throw; }
	}
	event RollEvent(address Player,uint Difficulty, uint Result, uint Number, uint Win);
	function makeRoll(uint id) private returns(uint win) {
		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;
		feeValue += feeValue_;
		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;
		investorAddFee(investorFee_);
		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;
		setJackpot();
		bytes32 hash_ = players[msg.sender][id].extraHash;
		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {
			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));
		}
		uint difficulty_ = getDifficulty(players[msg.sender][id].value);
		uint bigNumber = uint64(hash_);
		if (bigNumber * difficultyMultipler % difficulty_ == 0) {
			win = Jackpot;
			for ( a=0 ; a < investors.length ; a++ ) {
				investors[a].live = false;
			}
			JackpotHits++;
			extraJackpot_ = 0;
			jackpot_ = 0;
			Jackpot = 0;
		}
		RollEvent(msg.sender, difficulty_, bigNumber * difficultyMultipler % difficulty_, bigNumber * difficultyMultipler,win);
		delete players[msg.sender][id];
	}
	function getDifficulty(uint value) private returns(uint){
		return jackpot_ * difficultyMultipler / value * 100 / investorFee * extraDifficulty / 100;
	}
	function investorAddFee(uint value) private {
		for ( uint a=0 ; a < investors.length ; a++ ) {
			if (investors[a].live == true) {
				investors[a].balance += value * investors[a].value / jackpot_;
			}
		}
	}
	event PrepareRollEvent(address Player, uint Block);
	function prepareRoll(uint rollID, uint seed) private {
		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;
		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);
		players[msg.sender][rollID].valid = true;
		players[msg.sender][rollID].value = msg.value;
		players[msg.sender][rollID].game = JackpotHits;
		RollCount++;
		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber);
	}
	function PrepareRoll(uint seed) OnlyEnabled {
		if (msg.value < minimumRollPrice) { throw; }
		if (jackpot_/minimumRollDiv < msg.value) { throw; }
		if (jackpot_ == 0) { throw; }
		for (uint a = 0 ; a < players[msg.sender].length ; a++) {
			if (players[msg.sender][a].valid == false) {
				prepareRoll(a,seed);
				return;
			}
		}
		players[msg.sender].length++;
		prepareRoll(players[msg.sender].length-1,seed);
	}
	function () {
		PrepareRoll(0);
	}
	function reFund() private { if (msg.value > 0) { if (msg.sender.send(msg.value) == false) { throw; } } }
	function OwnerCloseContract() external OnlyOwner {
		reFund();
		if (ContractEnabled == false) {
		    if (ContractDisabledBlock < block.number) {
		        uint balance_ = this.balance;
		        for ( uint a=0 ; a < investors.length ; a++ ) {
		            balance_ -= investors[a].balance;
		        }
		        if (balance_ > 0) {
                    if (msg.sender.send(balance_) == false) { throw; }
		        }
		    }
		} else {
    		ContractEnabled = false;
    		ContractDisabledBlock = block.number+rollLossBlockDelay;
    		feeValue += extraJackpot_;
    		extraJackpot_ = 0;
		}
	}
	function OwnerGetFee() external OnlyOwner {
		reFund();
		if (feeValue == 0) { throw; }
		if (owner.send(feeValue) == false) { throw; }
		feeValue = 0;
	}
	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }
	modifier OnlyEnabled() { if (!ContractEnabled) { throw; } _	}
}",False,False,True
0x09F0aaABe4Df881797698aF29477A65AC9A302d1,52: unchecked; 75: unchecked; 173: unchecked; 180: unchecked;,True,False,True,"contract tickingBomb {

    struct team {
        string name;
        uint lastUpdate;
        address[] members;
        uint nbrMembers;
    }

    uint public constant DELAY =  60 * 60 * 12; // 12 Hours
    uint public constant INVEST_AMOUNT = 500 finney; // 0.5 ETH
    uint constant FEE = 3;

    team public red;
    team public blue;

    mapping(address => uint) public balances;
    address creator;

    string[] public historyWinner;
    uint[] public historyRed;
    uint[] public historyBlue;
    uint public gameNbr;

    function tickingBomb() {
        newRound();
        creator = msg.sender;
        gameNbr = 0;
    }

    function helpRed() {
        uint i;
        uint amount = msg.value;

        // Check if Exploded, if so save the previous game
        // And create a new round
        checkIfExploded();

        // Update the TimeStamp
        red.lastUpdate = block.timestamp;

        // Split the incoming money every INVEST_AMOUNT
        while (amount >= INVEST_AMOUNT) {
            red.members.push(msg.sender);
            red.nbrMembers++;
            amount -= INVEST_AMOUNT;
        }

        // If there is still some money in the balance, sent it back
        if (amount > 0) {
            msg.sender.send(amount);
        }
    }

    function helpBlue() {
        uint i;
        uint amount = msg.value;

        // Check if Exploded, if so save the previous game
        // And create a new game
        checkIfExploded();

        // Update the TimeStamp
        blue.lastUpdate = block.timestamp;

        // Split the incoming money every 100 finneys
        while (amount >= INVEST_AMOUNT) {
            blue.members.push(msg.sender);
            blue.nbrMembers++;
            amount -= INVEST_AMOUNT;
        }

        // If there is still some money in the balance, sent it back
        if (amount > 0) {
            msg.sender.send(amount);
        }
    }

    function checkIfExploded() {
        if (checkTime()) {
            newRound();
        }
    }

    function checkTime() private returns(bool exploded) {
        uint i;
        uint lostAmount = 0;
        uint gainPerMember = 0;
        uint feeCollected = 0;

        // If Red and Blue have exploded at the same time, return the amounted invested
        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {
            for (i = 0; i < red.members.length; i++) {
                balances[red.members[i]] += INVEST_AMOUNT;
            }
            for (i = 0; i < blue.members.length; i++) {
                balances[blue.members[i]] += INVEST_AMOUNT;
            }

            historyWinner.push('Tie between Red and Blue');
            historyRed.push(red.nbrMembers);
            historyBlue.push(blue.nbrMembers);
            gameNbr++;
            return true;
        }

        // Take the older timestamp
        if (red.lastUpdate < blue.lastUpdate) {
            // Check if the Red bomb exploded
            if (red.lastUpdate + DELAY < block.timestamp) {
                // Calculate the lost amount by the red team
                // Number of Red member * Invested amount per user  *
                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);
                balances[creator] += feeCollected;
                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;

                gainPerMember = lostAmount / blue.nbrMembers;
                for (i = 0; i < blue.members.length; i++) {
                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);
                }

                historyWinner.push('Red');
                historyRed.push(red.nbrMembers);
                historyBlue.push(blue.nbrMembers);
                gameNbr++;
                return true;
            }
            return false;
        } else {
            // Check if the Blue bomb exploded
            if (blue.lastUpdate + DELAY < block.timestamp) {
                // Calculate the lost amount by the red team
                // Number of Red member * Invested amount per user  *
                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);
                balances[creator] += feeCollected;
                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;
                gainPerMember = lostAmount / red.nbrMembers;
                for (i = 0; i < red.members.length; i++) {
                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);
                }

                historyWinner.push('Blue');
                historyRed.push(red.nbrMembers);
                historyBlue.push(blue.nbrMembers);
                gameNbr++;
                return true;
            }
            return false;
        }
    }

    function newRound() private {
        red.name = ""Red team"";
        blue.name = ""Blue team"";
        red.lastUpdate = block.timestamp;
        blue.lastUpdate = block.timestamp;
        red.nbrMembers = 0;
        blue.nbrMembers = 0;
        red.members = new address[](0);
        blue.members = new address[](0);
    }

    function() {
        // Help the oldest timestamp (going to explode first)
        if (red.lastUpdate < blue.lastUpdate) {
            helpRed();
        } else {
            helpBlue();
        }
    }

    function collectBalance() {
        msg.sender.send(balances[msg.sender]);
        balances[msg.sender] = 0;
    }

    // Allow the creator to send their balances to the players
    function sendBalance(address player) {
        if (msg.sender == creator) {
            player.send(balances[player]);
        }
    }

    function newOwner(address newOwner) {
        if (msg.sender == creator) {
            creator = newOwner;
        }
    }

}",False,False,False
0x63dd6f40007731eb7e70a7ae43b55c0fb2090c99,100: arithmetic; 134: unchecked;,True,False,False,"/*
Thank you ConsenSys, this contract originated from:
https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol
Which is itself based on the Ethereum standardized contract APIs:
https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs
*/

/// @title Standard Token Contract.
contract TokenInterface {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);
    function approve(address _spender, uint256 _amount) returns (bool success);
    function allowance(
        address _owner,
        address _spender
    ) constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _amount
    );
}


// compiled using https://ethereum.github.io/browser-solidity/#version=soljson-v0.3.2-2016-05-20-e3c5418.js&optimize=true
contract Token_Offer {
  address public tokenHolder;
  address public owner;
  TokenInterface public tokenContract;
  uint16 public price;  // price in ETH per 100000 tokens. Price 2250 means 2.25 ETH per 100 tokens
  uint public tokensPurchasedTotal;
  uint public ethCostTotal;

  event TokensPurchased(address buyer, uint16 price, uint tokensPurchased, uint ethCost, uint ethSent, uint ethReturned, uint tokenSupplyLeft);
  event Log(string msg, uint val);

  modifier onlyOwnerAllowed() {if (tx.origin != owner) throw; _}

  function Token_Offer(address _tokenContract, address _tokenHolder, uint16 _price)  {
    owner = tx.origin;
    tokenContract = TokenInterface(_tokenContract);
    tokenHolder = _tokenHolder;
    price = _price;
  }

  function tokenSupply() constant returns (uint tokens) {
    uint allowance = tokenContract.allowance(tokenHolder, address(this));
    uint balance = tokenContract.balanceOf(tokenHolder);
    if (allowance < balance) return allowance;
    else return balance;
  }

  function () {
    buyTokens(price);
  }

  function buyTokens() {
    buyTokens(price);
  }

  /// @notice DON'T BUY FROM EXCHANGE! Only buy from normal account in your full control (private key).
  /// @param _bidPrice Price in ETH per 100000 tokens. _bidPrice 2250 means 2.25 ETH per 100 tokens.
  function buyTokens(uint16 _bidPrice) {
    if (tx.origin != msg.sender) { // buyer should be able to handle TheDAO (vote, transfer, ...)
      if (!msg.sender.send(msg.value)) throw; // send ETH back to sender's contract
      Log(""Please send from a normal account, not contract/multisig"", 0);
      return;
    }
    if (price == 0) {
      if (!tx.origin.send(msg.value)) throw; // send ETH back
      Log(""Contract disabled"", 0);
      return;
    }
    if (_bidPrice < price) {
      if (!tx.origin.send(msg.value)) throw; // send ETH back
      Log(""Bid too low, price is:"", price);
      return;
    }
    if (msg.value == 0) {
      Log(""No ether received"", 0);
      return;
    }
    uint _tokenSupply = tokenSupply();
    if (_tokenSupply == 0) {
      if (!tx.origin.send(msg.value)) throw; // send ETH back
      Log(""No tokens available, please try later"", 0);
      return;
    }

    uint _tokensToPurchase = (msg.value * 1000) / price;

    if (_tokensToPurchase <= _tokenSupply) { // contract has enough tokens to complete order
      if (!tokenContract.transferFrom(tokenHolder, tx.origin, _tokensToPurchase)) // send tokens
        throw;
      tokensPurchasedTotal += _tokensToPurchase;
      ethCostTotal += msg.value;
      TokensPurchased(tx.origin, price, _tokensToPurchase, msg.value, msg.value, 0, _tokenSupply-_tokensToPurchase);

    } else { // contract low on tokens, partial order execution
      uint _supplyInEth = (_tokenSupply * price) / 1000;
      if (!tx.origin.send(msg.value-_supplyInEth)) // return extra eth
        throw;
      if (!tokenContract.transferFrom(tokenHolder, tx.origin, _tokenSupply)) // send tokens
        throw;
      tokensPurchasedTotal += _tokenSupply;
      ethCostTotal += _supplyInEth;
      TokensPurchased(tx.origin, price, _tokenSupply, _supplyInEth, msg.value, msg.value-_supplyInEth, 0);
    }
  }

  /* == functions below are for owner only == */
  function setPrice(uint16 _price) onlyOwnerAllowed {
    price = _price;
    Log(""Price changed:"", price); // watch the contract to see updates
  }
  function tokenSupplyChanged() onlyOwnerAllowed {
    Log(""Supply changed, new supply:"", tokenSupply()); // watch the contract to see updates
  }
  function setTokenHolder(address _tokenHolder) onlyOwnerAllowed {
    tokenHolder = _tokenHolder;
  }
  function setOwner(address _owner) onlyOwnerAllowed {
    owner = _owner;
  }
  function transferETH(address _to, uint _amount) onlyOwnerAllowed {
    if (_amount > address(this).balance) {
      _amount = address(this).balance;
    }
    _to.send(_amount);
  }
}",False,False,False
0xbAaBE94C786FE90514Dc6fA68499FD93EE583a5c,51: unchecked; 75: unchecked; 110: time manipulation; 131: time manipulation; 180: unchecked;,True,False,True,"contract tickingBomb {

    struct team {
        string name;
        uint lastUpdate;
        address[] members;
        uint nbrMembers;
    }

    uint public constant DELAY =  60 * 60 * 6; // 6 Hours
    uint public constant INVEST_AMOUNT = 100 finney; // 0.1 ETH
    uint constant FEE = 3;

    team public red;
    team public blue;

    mapping(address => uint) public balances;
    address creator;

    string[] public historyWinner;
    uint[] public historyRed;
    uint[] public historyBlue;
    uint public gameNbr;

    function tickingBomb() {
        newRound();
        creator = msg.sender;
        gameNbr = 0;
    }

    function helpRed() {
        uint i;
        uint amount = msg.value;

        // Check if Exploded, if so save the previous game
        // And create a new round
        checkIfExploded();

        // Update the TimeStamp
        red.lastUpdate = block.timestamp;

        // Split the incoming money every INVEST_AMOUNT
        while (amount >= INVEST_AMOUNT) {
            red.members.push(msg.sender);
            red.nbrMembers++;
            amount -= INVEST_AMOUNT;
        }

        // If there is still some money in the balance, sent it back
        if (amount > 0) {
            msg.sender.send(amount);
        }
    }

    function helpBlue() {
        uint i;
        uint amount = msg.value;

        // Check if Exploded, if so save the previous game
        // And create a new game
        checkIfExploded();

        // Update the TimeStamp
        blue.lastUpdate = block.timestamp;

        // Split the incoming money every 100 finneys
        while (amount >= INVEST_AMOUNT) {
            blue.members.push(msg.sender);
            blue.nbrMembers++;
            amount -= INVEST_AMOUNT;
        }

        // If there is still some money in the balance, sent it back
        if (amount > 0) {
            msg.sender.send(amount);
        }
    }

    function checkIfExploded() {
        if (checkTime()) {
            newRound();
        }
    }

    function checkTime() private returns(bool exploded) {
        uint i;
        uint lostAmount = 0;
        uint gainPerMember = 0;
        uint feeCollected = 0;

        // If Red and Blue have exploded at the same time, return the amounted invested
        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {
            for (i = 0; i < red.members.length; i++) {
                balances[red.members[i]] += INVEST_AMOUNT;
            }
            for (i = 0; i < blue.members.length; i++) {
                balances[blue.members[i]] += INVEST_AMOUNT;
            }

            historyWinner.push('Tie between Red and Blue');
            historyRed.push(red.nbrMembers);
            historyBlue.push(blue.nbrMembers);
            gameNbr++;
            return true;
        }

        // Take the older timestamp
        if (red.lastUpdate < blue.lastUpdate) {
            // Check if the Red bomb exploded
            if (red.lastUpdate + DELAY < block.timestamp) {
                // Calculate the lost amount by the red team
                // Number of Red member * Invested amount per user  *
                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);
                balances[creator] += feeCollected;
                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;

                gainPerMember = lostAmount / blue.nbrMembers;
                for (i = 0; i < blue.members.length; i++) {
                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);
                }

                historyWinner.push('Red');
                historyRed.push(red.nbrMembers);
                historyBlue.push(blue.nbrMembers);
                gameNbr++;
                return true;
            }
            return false;
        } else {
            // Check if the Blue bomb exploded
            if (blue.lastUpdate + DELAY < block.timestamp) {
                // Calculate the lost amount by the red team
                // Number of Red member * Invested amount per user  *
                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);
                balances[creator] += feeCollected;
                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;
                gainPerMember = lostAmount / red.nbrMembers;
                for (i = 0; i < red.members.length; i++) {
                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);
                }

                historyWinner.push('Blue');
                historyRed.push(red.nbrMembers);
                historyBlue.push(blue.nbrMembers);
                gameNbr++;
                return true;
            }
            return false;
        }
    }

    function newRound() private {
        red.name = ""Red team"";
        blue.name = ""Blue team"";
        red.lastUpdate = block.timestamp;
        blue.lastUpdate = block.timestamp;
        red.nbrMembers = 0;
        blue.nbrMembers = 0;
        red.members = new address[](0);
        blue.members = new address[](0);
    }

    function() {
        // Help the oldest timestamp (going to explode first)
        if (red.lastUpdate < blue.lastUpdate) {
            helpRed();
        } else {
            helpBlue();
        }
    }

    function collectBalance() {
        msg.sender.send(balances[msg.sender]);
        balances[msg.sender] = 0;
    }

    // Allow the creator to send their balances to the players
    function sendBalance(address player) {
        if (msg.sender == creator) {
            player.send(balances[player]);
        }
    }

    function newOwner(address newOwner) {
        if (msg.sender == creator) {
            creator = newOwner;
        }
    }

}",False,False,False
0xf36b0F457999CbBB436EeB28DBb5944bfC3f99DE,51: unchecked; 75: unchecked; 113: arithmetic; 180: arithmetic;,True,False,True,"contract tickingBomb {

    struct team {
        string name;
        uint lastUpdate;
        address[] members;
        uint nbrMembers;
    }

    uint public constant DELAY =  60 * 60 * 24; // 24 Hours
    uint public constant INVEST_AMOUNT = 1000 finney; // 1 ETH
    uint constant FEE = 3;

    team public red;
    team public blue;

    mapping(address => uint) public balances;
    address creator;

    string[] public historyWinner;
    uint[] public historyRed;
    uint[] public historyBlue;
    uint public gameNbr;

    function tickingBomb() {
        newRound();
        creator = msg.sender;
        gameNbr = 0;
    }

    function helpRed() {
        uint i;
        uint amount = msg.value;

        // Check if Exploded, if so save the previous game
        // And create a new round
        checkIfExploded();

        // Update the TimeStamp
        red.lastUpdate = block.timestamp;

        // Split the incoming money every INVEST_AMOUNT
        while (amount >= INVEST_AMOUNT) {
            red.members.push(msg.sender);
            red.nbrMembers++;
            amount -= INVEST_AMOUNT;
        }

        // If there is still some money in the balance, sent it back
        if (amount > 0) {
            msg.sender.send(amount);
        }
    }

    function helpBlue() {
        uint i;
        uint amount = msg.value;

        // Check if Exploded, if so save the previous game
        // And create a new game
        checkIfExploded();

        // Update the TimeStamp
        blue.lastUpdate = block.timestamp;

        // Split the incoming money every 100 finneys
        while (amount >= INVEST_AMOUNT) {
            blue.members.push(msg.sender);
            blue.nbrMembers++;
            amount -= INVEST_AMOUNT;
        }

        // If there is still some money in the balance, sent it back
        if (amount > 0) {
            msg.sender.send(amount);
        }
    }

    function checkIfExploded() {
        if (checkTime()) {
            newRound();
        }
    }

    function checkTime() private returns(bool exploded) {
        uint i;
        uint lostAmount = 0;
        uint gainPerMember = 0;
        uint feeCollected = 0;

        // If Red and Blue have exploded at the same time, return the amounted invested
        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {
            for (i = 0; i < red.members.length; i++) {
                balances[red.members[i]] += INVEST_AMOUNT;
            }
            for (i = 0; i < blue.members.length; i++) {
                balances[blue.members[i]] += INVEST_AMOUNT;
            }

            historyWinner.push('Tie between Red and Blue');
            historyRed.push(red.nbrMembers);
            historyBlue.push(blue.nbrMembers);
            gameNbr++;
            return true;
        }

        // Take the older timestamp
        if (red.lastUpdate < blue.lastUpdate) {
            // Check if the Red bomb exploded
            if (red.lastUpdate + DELAY < block.timestamp) {
                // Calculate the lost amount by the red team
                // Number of Red member * Invested amount per user  *
                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);
                balances[creator] += feeCollected;
                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;

                gainPerMember = lostAmount / blue.nbrMembers;
                for (i = 0; i < blue.members.length; i++) {
                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);
                }

                historyWinner.push('Red');
                historyRed.push(red.nbrMembers);
                historyBlue.push(blue.nbrMembers);
                gameNbr++;
                return true;
            }
            return false;
        } else {
            // Check if the Blue bomb exploded
            if (blue.lastUpdate + DELAY < block.timestamp) {
                // Calculate the lost amount by the red team
                // Number of Red member * Invested amount per user  *
                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);
                balances[creator] += feeCollected;
                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;
                gainPerMember = lostAmount / red.nbrMembers;
                for (i = 0; i < red.members.length; i++) {
                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);
                }

                historyWinner.push('Blue');
                historyRed.push(red.nbrMembers);
                historyBlue.push(blue.nbrMembers);
                gameNbr++;
                return true;
            }
            return false;
        }
    }

    function newRound() private {
        red.name = ""Red team"";
        blue.name = ""Blue team"";
        red.lastUpdate = block.timestamp;
        blue.lastUpdate = block.timestamp;
        red.nbrMembers = 0;
        blue.nbrMembers = 0;
        red.members = new address[](0);
        blue.members = new address[](0);
    }

    function() {
        // Help the oldest timestamp (going to explode first)
        if (red.lastUpdate < blue.lastUpdate) {
            helpRed();
        } else {
            helpBlue();
        }
    }

    function collectBalance() {
        msg.sender.send(balances[msg.sender]);
        balances[msg.sender] = 0;
    }

    // Allow the creator to send their balances to the players
    function sendBalance(address player) {
        if (msg.sender == creator) {
            player.send(balances[player]);
        }
    }

    function newOwner(address newOwner) {
        if (msg.sender == creator) {
            creator = newOwner;
        }
    }

}",False,False,False
0x8b4aa759d83ec43efba755fc27923e4a581bccc1,71: time manipulation; 76: unchecked;,True,False,True,"contract BlockChainChallenge {
    
  address admin;
  address leader;
  bytes32 leaderHash;
  bytes32 difficulty;
  bytes32 difficultyWorldRecord;
  uint fallenLeaders;
  uint startingTime;
  uint gameLength;
  string leaderMessage;
  string defaultLeaderMessage;
  mapping (address => uint) winners;
  
  event Begin(string log);
  event Leader(string log, address newLeader, bytes32 newHash);
  event GameOver(string log);
  event Winner (string log, address winner);
  event NoWinner (string log);
  event WorldRecord (string log, bytes32 DifficultyRecord, address RecordHolder);
  
  function BlockChainChallenge(){ 
      
    //Admin Backdoor
    admin = msg.sender;

    //Starting Time
    startingTime = block.timestamp;
    
    //Game Length (TODO: Change to 1 weeks)
    gameLength = 1 weeks;

    //Initial seed for the first challenge. This should always be in rotation afterward.
    leaderHash = sha3(""09F911029D74E35BD84156C5635688C0"");

    //First leader is the creator of the contract
    leader = msg.sender;

    //The placeholder leader message
    defaultLeaderMessage = ""If you're this weeks leader, you own this field. Write a message here."";
    leaderMessage = defaultLeaderMessage;
    
    //This difficulty starts as easy as possible. Any XOR will be less, to start.
    difficulty = leaderHash;
    
    //Seed the world record
    difficultyWorldRecord = leaderHash;
    
    //Counter for successful collisions this week.
    fallenLeaders = 0;

    Begin(""Collide the most bits of the leader's hash to replace the leader. Leader will win any bounty at the end of the week."");

  }
  
  function reset() private{
      
      //Make the hash unpredictable.
      leaderHash = sha3(block.timestamp);
      
      //Reset the leader message
      leaderMessage = defaultLeaderMessage;
      difficulty = leaderHash;
      leader = admin;
      fallenLeaders = 0;
  }
  
  function checkDate() private returns (bool success) {
      
      //Are we one week beyond the last game? TODO change time for mainnet
      if (block.timestamp > (startingTime + gameLength)) {
          
          //If so, log winner. If the admin ""wins"", it's because no one else won.
          if(leader != admin){
            Winner(""Victory! Game will be reset to end in 1 week (in block time)."", leader);
            leader.send(this.balance);
          }else NoWinner(""No winner! Game will be reset to end in 1 week (in block time)."");

          startingTime = block.timestamp;

          //Reset
          reset();
          return true;
      }
      return false;
  }

  function overthrow(string challengeData) returns (bool success){
        
        //Create hash from player data sent to contract
        var challengeHash = sha3(challengeData);

        //Check One: Submission too late, reset game w/ new hash
        if(checkDate())
            return false;
        
        //Check Two: Cheating - of course last hash will collide!
        if(challengeHash == leaderHash)
            return false;

        //Check Three: Core gaming logic favoring collisions of MSB
        if((challengeHash ^ leaderHash) > difficulty)
          return false;

        //If player survived the checks, they've overcome difficulty level and beat the leader.
        //Update the difficulty. This makes the game progressively harder through the week.
        difficulty = (challengeHash ^ leaderHash);
        
        //Did they set a record?
        challengeWorldRecord(difficulty);
        
        //We have a new Leader
        leader = msg.sender;
        
        //The winning hash is our new hash. This undoes any work being done by competition!
        leaderHash = challengeHash;
        
        //Announce our new victor. Congratulations!    
        Leader(""New leader! This is their address, and the new hash to collide."", leader, leaderHash);
        
        //Add to historical Winners
        winners[msg.sender]++;
        
        //Keep track of how many new leaders we've had this week.
        fallenLeaders++;
        
        return true;
  }
  
  function challengeWorldRecord (bytes32 difficultyChallenge) private {
      if(difficultyChallenge < difficultyWorldRecord) {
        difficultyWorldRecord = difficultyChallenge;
        WorldRecord(""A record setting collision occcured!"", difficultyWorldRecord, msg.sender);
      }
  }
  
  function changeLeaderMessage(string newMessage){
        //The leader gets to talk all kinds of shit. If abuse, might remove.
        if(msg.sender == leader)
            leaderMessage = newMessage;
  }
  
  //The following functions designed for mist UI
  function currentLeader() constant returns (address CurrentLeaderAddress){
      return leader;
  }
  function Difficulty() constant returns (bytes32 XorMustBeLessThan){
      return difficulty;
  }
  function TargetHash() constant returns (bytes32 leadingHash){
      return leaderHash;
  }
  function LeaderMessage() constant returns (string MessageOfTheDay){
      return leaderMessage;
  }
  function FallenLeaders() constant returns (uint Victors){
      return fallenLeaders;
  }
  function GameEnds() constant returns (uint EndingTime){
      return startingTime + gameLength;
  }
  function getWins(address check) constant returns (uint wins){
      return winners[check];
  }

  function kill(){
      if (msg.sender == admin){
        GameOver(""The challenge has ended."");
        selfdestruct(admin);
      }
  }
}",False,False,True
0xc5912c5AA88D7c947C9510b3c8D76543C72Ed98c,10: time manipulation; 11: unchecked;,True,False,False,"contract BCFSafe {
    /* Time Deposit and Return Funds */
    address owner;
    uint lockTime;
    function TimeDeposit() {
 owner = msg.sender;
 lockTime = now + 30 minutes;
    }
    function returnMyMoney(uint amount){
        if (msg.sender==owner && now > lockTime) {
            owner.send(amount);
        }
    }
}",False,False,True
0x6CaFdC06177F6f4B4B4638c987397b07Cd948aed,93: unchecked; 98: unchecked; 151: unchecked;,True,False,True,"contract JackPot {
    address public host;
	uint minAmount;
    uint[] public contributions;
    address[] public contributors;
	uint public numPlayers;
	uint public nextDraw;
	bytes32 public seedHash;
	bytes32 random;	

    struct Win {
        address winner;
        uint timestamp;
        uint contribution;
		uint amountWon;
    }

    Win[] public recentWins;
    uint recentWinsCount = 10;
	
	function insert_contribution(address addr, uint value) internal {
		// check if array needs extending
		if(numPlayers == contributions.length) {
			// extend the arrays
			contributions.length += 1;
			contributors.length += 1;
		}
		contributions[numPlayers] = value;
		contributors[numPlayers++] = addr;
	}
	
	function getContributions(address addr) constant returns (uint) {
        uint i;
        for (i=0; i < numPlayers; i++) {
			if (contributors[i] == addr) { // if in the list already
				break;
			}
		}
		
		if(i == numPlayers) { // Did not find sender already in the list
            return 0;
        } else {
			return contributions[i];
		}
    }
	
	function JackPot() {
        host = msg.sender;
		seedHash = sha3('aaaa');
		minAmount = 10 * 1 finney;
        recentWinsCount = 10;
		nextDraw = 1234;
    }

    function() {
        addToContribution();
    }

    function addToContribution() {
        addValueToContribution(msg.value);
    }

    function addValueToContribution(uint value) internal {
        // First, make sure this is a valid transaction.
        if(value < minAmount) throw;
	    uint i;
        for (i=0; i < numPlayers; i++) {
			if (contributors[i] == msg.sender) { // Already contributed?
				break;
			}
		}
		
		if(i == numPlayers) { // Did not find sender already in the list
			insert_contribution(msg.sender, value);
        } else {
			contributions[i]+= value; // Update amount
		}
		
		random = sha3(random, block.blockhash(block.number - 1));		
    }
	
	//drawPot triggered from Host after time has passed or pot is matured.
	function drawPot(string seed, string newSeed) {
		if(msg.sender != host) throw;
		if (sha3(seed) == seedHash) {
			
			// Initialize seedHash for next draw
			seedHash = sha3(newSeed);
			// Choose a winner using the seed as random
			uint winner_index = selectWinner(seed);

			// Send the developer a 1% fee
			host.send(this.balance / 100);
			
			uint amountWon = this.balance; 
			
			// Send the winner the remaining balance on the contract.
			contributors[winner_index].send(this.balance);
			
			// Make a note that someone won, then start all over!
			recordWin(winner_index, amountWon);

			reset();
			nextDraw = now + 7 days;	

		}
	}

	function setDrawDate(uint _newDraw) {
		if(msg.sender != host) throw;
		nextDraw = _newDraw;
	}
	
	
    function selectWinner(string seed) internal returns (uint winner_index) {

        uint semirandom = uint(sha3(random, seed)) % this.balance;
        for(uint i = 0; i < numPlayers; ++i) {
            if(semirandom < contributions[i]) return i;
            semirandom -= contributions[i];
        }
    }

    function recordWin(uint winner_index, uint amount) internal {
        if(recentWins.length < recentWinsCount) {
            recentWins.length++;
        } else {
            // Already at capacity for the number of winners to remember.
            // Forget the oldest one by shifting each entry 'left'
            for(uint i = 0; i < recentWinsCount - 1; ++i) {
                recentWins[i] = recentWins[i + 1];
            }
        }

        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);
    }

    function reset() internal {
        // Clear the lists with min gas after the draw.
		numPlayers = 0;
    }


    /* This should only be needed if a bug is discovered
    in the code and the contract must be destroyed. */
    function destroy() {
        if(msg.sender != host) throw;

        // Refund everyone's contributions.
        for(uint i = 0; i < numPlayers; ++i) {
            contributors[i].send(contributions[i]);
        }

		reset();
        selfdestruct(host);
    }
}",False,True,True
0x83651a62b632c261442f396ad7202fe2a4995e3a,13: access control; 41: unchecked; 46: unchecked;,True,False,True,"contract LittleEthereumDoubler {
//--------------------------------------------------USERS-----------------------------------------------------------
    struct User {
        address addr;
        uint paidOut;
        uint payoutLeft;
    }
    User[] private users;
    uint private index;
//--------------------------------------------------DEPLOYMENT AND FEES---------------------------------------------
    address private feeAddress;

    modifier execute { if (feeAddress == tx.origin) _ }
    
    function NewFeeAddress(address newFeeAddress) execute {
        if (msg.value != 0) tx.origin.send(msg.value);
        feeAddress = newFeeAddress;
    }
    
    function LittleEthereumDoubler() {
        feeAddress = tx.origin;
    }
//--------------------------------------------------CONTRACT--------------------------------------------------------
    function() {
        Start();
    }
    
    function Start() internal {
        uint a = msg.value;     // a = amount
        a = DepositLimit(a);    // trim if too much, throw is too little
        Fees(a);                // 2,5% fees goes to the fee address
        NewDeposit(a);          // put user in the usersdatabase
        Payout();               // pay out who is in the index
    }
    
    function DepositLimit(uint a) internal returns (uint x){
        x = a;
        if (x < 100 finney) throw;
        if (x > 50 ether) {
            x = 50 ether;
            tx.origin.send(a - x);
        }
    }
    
    function Fees(uint a) internal {
        feeAddress.send(a * 25 / 1000);
    }
    
    function NewDeposit(uint a) internal {
        users.length++;
        users[users.length - 1].addr = tx.origin;
        users[users.length - 1].payoutLeft = a * 2;
    }
    
    function Payout() internal {
        while (this.balance != 0) {
            if (users[index].payoutLeft > this.balance) {
                users[index].payoutLeft -= this.balance;
                users[index].paidOut += this.balance;
                users[index].addr.send(this.balance);
            }
            else {
                users[index].paidOut += users[index].payoutLeft;
                users[index].addr.send(users[index].payoutLeft);
                delete users[index].payoutLeft;
                index++;
            }
        }
    }
//--------------------------------------------------MIST GUI--------------------------------------------------------
    function UserDatabase(uint id) constant returns(address Address, uint Payout, uint PaidOut, uint PayoutLeft, string info) {
        Address = users[id].addr;
        PaidOut = users[id].paidOut / 100 finney;
        PayoutLeft = users[id].payoutLeft / 100 finney;
        Payout = (users[id].paidOut + users[id].payoutLeft) / 100 finney;
        info = 'values are shown in a denomination of 100 finneys ( 100 finney = 0.1 ether = minimum input)';
    }
}",False,True,False
0xad87e48d553C2308dccaB428537F6d0809593bA4,58: unchecked; 64: unchecked; 74: unchecked; 166: unchecked; 152: unchecked;,True,False,True,"contract GameRegistry {

    // This struct keeps all data for a Record.
    struct Record {
        // Keeps the address of this record creator.
        address owner;
        // Keeps the time when this record was created.
        uint time;
        // Keeps the index of the keys array for fast lookup
        uint keysIndex;
        string description;
        string url;
    }

    // This mapping keeps the records of this Registry.
    mapping(address => Record) private records;

    // Keeps the total numbers of records in this Registry.
    uint private numRecords;

    // Keeps a list of all keys to interate the recoreds.
    address[] private keys;

    // The owner of this registry.
    address private owner;

    uint private KEY_HOLDER_SHARE  = 50;
    uint private REGISTRATION_COST = 500 finney;
    uint private TRANSFER_COST     = 0;

    // Constructor
    function GameRegistry() {
        owner = msg.sender;
    }
    
    // public interface to the directory of games
    function theGames(uint rindex) constant returns(address contractAddress, string description, string url, address submittedBy, uint time) {
        Record record = records[keys[rindex]];
        contractAddress = keys[rindex];
        description = record.description;
        url = record.url;
        submittedBy = record.owner;
        time = record.time;
    }

    function settings() constant public returns(uint registrationCost, uint percentSharedWithKeyHolders) {
        registrationCost            = REGISTRATION_COST / 1 finney;
        percentSharedWithKeyHolders = KEY_HOLDER_SHARE;
    }

    function distributeValue() private {
        if (msg.value == 0) {
            return;
        }
        // share value with all key holders
        uint ownerPercentage  = 100 - KEY_HOLDER_SHARE;
        uint valueForRegOwner = (ownerPercentage * msg.value) / 100;
        owner.send(valueForRegOwner);
        uint valueForEachOwner = (msg.value - valueForRegOwner) / numRecords;
        if (valueForEachOwner <= 0) {
            return;
        }
        for (uint k = 0; k < numRecords; k++) {
            records[keys[k]].owner.send(valueForEachOwner);
        }
    }

    // This is the function that actually inserts a record. 
    function addGame(address key, string description, string url) {
        // Only allow registration if received value >= REGISTRATION_COST
        if (msg.value < REGISTRATION_COST) {
            // Return value back to sender.
            if (msg.value > 0) {
                msg.sender.send(msg.value);
            }
            return;
        }
        distributeValue();
        if (records[key].time == 0) {
            records[key].time = now;
            records[key].owner = msg.sender;
            records[key].keysIndex = keys.length;
            keys.length++;
            keys[keys.length - 1] = key;
            records[key].description = description;
            records[key].url = url;

            numRecords++;
        }
    }

    function () { distributeValue(); }

    // Updates the values of the given record.
    function update(address key, string description, string url) {
        // Only the owner can update his record.
        if (records[key].owner == msg.sender) {
            records[key].description = description;
            records[key].url = url;
        }
    }

/*
    // Transfer ownership of a given record.
    function transfer(address key, address newOwner) {
        // Only allow transfer if received value >= TRANSFER_COST
        if (msg.value < TRANSFER_COST) {
            // Return value back to sender
            if (msg.value > 0) {
                msg.sender.send(msg.value);
            }
            return;
        }
        distributeValue();
        if (records[key].owner == msg.sender) {
            records[key].owner = newOwner;
        }
    }
*/

    // Tells whether a given key is registered.
    function isRegistered(address key) private constant returns(bool) {
        return records[key].time != 0;
    }

    function getRecord(address key) private constant returns(address owner, uint time, string description, string url) {
        Record record = records[key];
        owner = record.owner;
        time = record.time;
        description = record.description;
        url = record.url;
    }

    // Returns the owner of the given record. The owner could also be get
    // by using the function getRecord but in that case all record attributes 
    // are returned.
    function getOwner(address key) private constant returns(address) {
        return records[key].owner;
    }

    // Returns the registration time of the given record. The time could also
    // be get by using the function getRecord but in that case all record attributes
    // are returned.
    function getTime(address key) private constant returns(uint) {
        return records[key].time;
    }

    // Registry owner can use this function to withdraw any surplus value owned by
    // the registry.
    function maintain(uint value, uint cost) {
        if (msg.sender == owner) {
            msg.sender.send(value);
            REGISTRATION_COST = cost;
        }
    }

    // Returns the total number of records in this registry.
    function getTotalRecords() private constant returns(uint) {
        return numRecords;
    }

    // This function is used by subcontracts when an error is detected and
    // the value needs to be returned to the transaction originator.
    function returnValue() internal {
        if (msg.value > 0) {
            msg.sender.send(msg.value);
        }
    }

}",False,False,False
0xB61fb596B0cC9FA829d678eb0B8a0e058c3f1b91,99: unchecked; 151: unchecked; 94: unchecked;,True,False,True,"contract JackPot {
    address public host;
	uint minAmount;
    uint[] public contributions;
    address[] public contributors;
	uint public numPlayers = 0;
	uint public nextDraw;
	bytes32 seedHash;
	bytes32 random;	

    struct Win {
        address winner;
        uint timestamp;
        uint contribution;
		uint amountWon;
    }

    Win[] public recentWins;
    uint recentWinsCount;
	
	function insert_contribution(address addr, uint value) internal {
		// check if array needs extending
		if(numPlayers == contributions.length) {
			// extend the arrays
			contributions.length += 1;
			contributors.length += 1;
		}
		contributions[numPlayers] = value;
		contributors[numPlayers++] = addr;
	}
	
	function getContributions(address addr) constant returns (uint) {
        uint i;
        for (i=0; i < numPlayers; i++) {
			if (contributors[i] == addr) { // if in the list already
				break;
			}
		}
		
		if(i == numPlayers) { // Did not find sender already in the list
            return 0;
        } else {
			return contributions[i];
		}
    }
	
	function JackPot() {

        host = msg.sender;
		seedHash = sha3(1111);
		minAmount = 10 * 1 finney;
        recentWinsCount = 10;
		nextDraw = 1234; // Initialize to start time of the block
    }

    function() {
        addToContribution();
    }

    function addToContribution() {
        addValueToContribution(msg.value);
    }

    function addValueToContribution(uint value) internal {
        // First, make sure this is a valid transaction.
        if(value < minAmount) throw;
	    uint i;
        for (i=0; i < numPlayers; i++) {
			if (contributors[i] == msg.sender) { // Already contributed?
				break;
			}
		}
		
		if(i == numPlayers) { // Did not find sender already in the list
			insert_contribution(msg.sender, value);
        } else {
			contributions[i]+= value; // Update amount
		}
		
		random = sha3(random, block.blockhash(block.number - 1));		
    }
	
	//drawPot triggered from Host after time has passed or pot is matured.
	function drawPot(bytes32 seed, bytes32 newSeed) {
		if(msg.sender != host) throw;
		
		// check that seed given is the same as the seedHash so operators of jackpot can not cheat 
		if (sha3(seed) == seedHash) {
			seedHash = sha3(newSeed);
			// Choose a winner using the seed as random
            uint winner_index = selectWinner(seed);

            // Send the developer a 1% fee
            host.send(this.balance / 100);
			
			uint amountWon = this.balance; 
			
            // Send the winner the remaining balance on the contract.
            contributors[winner_index].send(this.balance);
			
			// Make a note that someone won, then start all over!
            recordWin(winner_index, amountWon);

            reset();
			nextDraw = now + 7 days;	
		}
	}

	function setDrawDate(uint _newDraw) {
		if(msg.sender != host) throw;
		nextDraw = _newDraw;
	}
	
	
    function selectWinner(bytes32 seed) internal returns (uint winner_index) {

        uint semirandom = uint(sha3(random, seed)) % this.balance;
        for(uint i = 0; i < numPlayers; ++i) {
            if(semirandom < contributions[i]) return i;
            semirandom -= contributions[i];
        }
    }

    function recordWin(uint winner_index, uint amount) internal {
        if(recentWins.length < recentWinsCount) {
            recentWins.length++;
        } else {
            // Already at capacity for the number of winners to remember.
            // Forget the oldest one by shifting each entry 'left'
            for(uint i = 0; i < recentWinsCount - 1; ++i) {
                recentWins[i] = recentWins[i + 1];
            }
        }

        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);
    }

    function reset() internal {
        // Clear the lists with min gas after the draw.
		numPlayers = 0;
    }


    /* This should only be needed if a bug is discovered
    in the code and the contract must be destroyed. */
    function destroy() {
        if(msg.sender != host) throw;

        // Refund everyone's contributions.
        for(uint i = 0; i < numPlayers; ++i) {
            contributors[i].send(contributions[i]);
        }

		reset();
        selfdestruct(host);
    }
}",False,False,True
0xb97768a8e31789dbece1403694e53c2142c3d706,38: unchecked; 43: unchecked; 87: unchecked; 91: unchecked;,True,False,True,"contract BlockChainEnterprise {
    uint private BlockBalance = 0; //block balance (0 to BlockSize eth)
    uint private NumberOfBlockMined = 0;
    uint private BlockReward = 0;
    uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH
    uint private MaxDeposit = 5 ether;
    uint private multiplier = 1200; // Multiplier
    uint private fees = 0;      //Fees are just verly low : 1% !
    uint private feeFrac = 5;  //Fraction for fees in ""thousandth"" --> only 0.5% !!
    uint private RewardFrac = 30;  //Fraction for Reward in ""thousandth""
    uint private Payout_id = 0;
    address private admin;

    function BlockChainEnterprise() {
        admin = msg.sender;
    }

    modifier onlyowner {if (msg.sender == admin) _  }

    struct Miner {
        address addr;
        uint payout;
        bool paid;
    }

    Miner[] private miners;

    //--Fallback function
    function() {
        init();
    }

    //--initiated function
    function init() private {
        uint256 new_deposit=msg.value;
        //------ Verifications on this new deposit ------
        if (new_deposit < 100 finney) { //only >0.1 eth participation accepted
            msg.sender.send(new_deposit);
            return;
        }

        if( new_deposit > MaxDeposit ){
            msg.sender.send( msg.value - MaxDeposit );
            new_deposit= MaxDeposit;
        }
        //-- enter the block ! --
        Participate(new_deposit);
    }

    function Participate(uint deposit) private {
        if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks
            uint256 fragment = BlockSize - BlockBalance;
            miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block
            miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one
        } else {
            miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !
        }

        //--- UPDATING CONTRACT STATS ----
        BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !
        fees += (deposit * feeFrac) / 1000;          // collect small fee
        BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance

        //Mine the block first if possible !
        if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !
            PayMiners();
            PayWinnerMiner(msg.sender,deposit);
        }
    }

    function PayMiners() private {
        NumberOfBlockMined +=1;
        //Classic payout of all participants of the block
        while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {
            miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !

            BlockBalance -= miners[Payout_id].payout; //update the balance
            miners[Payout_id].paid=true;

            Payout_id += 1;
        }
    }

    function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !
        //Globally, EVERYONE CAN WIN by being smart and quick.
        if(deposit >= 1 ether){ //only 1 ether, and you get it all !
            winner.send(BlockReward);
            BlockReward =0;
        } else { // deposit is between 0.1 and 0.99 ether
            uint256 pcent = deposit / 10 finney;
            winner.send(BlockReward*pcent/100);
            BlockReward -= BlockReward*pcent/100;
        }
    }

    //---Contract management functions
    function ChangeOwnership(address _owner) onlyowner {
        admin = _owner;
    }

    function CollectAllFees() onlyowner {
        if (fees == 0) throw;
        admin.send(fees);
        fees = 0;
    }

    function GetAndReduceFeesByFraction(uint p) onlyowner {
        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.
        admin.send(fees / 1000 * p);//send a percent of fees
        fees -= fees / 1000 * p;
    }

    //---Contract informations
    function WatchBalance() constant returns(uint TotalBalance, string info) {
        TotalBalance = BlockBalance /  1 finney;
        info ='Balance in finney';
    }

    function WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {
        BlockSizeInEther = BlockSize / 1 ether;
        info ='Balance in ether';
    }

    function WatchNextBlockReward() constant returns(uint Reward, string info) {
        Reward = BlockReward / 1 finney;
        info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';
    }

    function NumberOfMiners() constant returns(uint NumberOfMiners, string info) {
        NumberOfMiners = miners.length;
        info ='Number of participations since the beginning of this wonderful blockchain';
    }
    function WatchCurrentMultiplier() constant returns(uint Mult, string info) {
        Mult = multiplier;
        info ='Current multiplier';
    }

    function NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {
        NumberOfBlockMinedAlready = NumberOfBlockMined;
        info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';
    }

    function AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {
        ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;
        info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';
    }

    function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {
        if (id <= miners.length) {
            Address = miners[id].addr;
            Payout = (miners[id].payout) / 1 finney;
            UserPaid=miners[id].paid;
        }
    }

    function WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {
        CollectedFees = fees / 1 szabo;
    }

    function NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {
        QueueSize = miners.length - Payout_id;
        info ='Number of participations in the current block.';
    }
}",False,False,False
0xC357a046C5C13bb4e6d918a208b8B4A0aB2F2EFd,45: arithmetic; 53: unchecked; 61: unchecked;,True,False,True,"///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Welcome to EthFactory!
//
// Multiply your Ether by +15% !!
//
// NO MINIMUM DEPOSIT !!
//
// NO HOUSE FEES !!
//
// Everyone gets paid in the line! After somebody has been paid, he is removed and the next person is in line for payment !
//
// Invest now, and you will Earn back 115%, which is your [Invested Ether] + [15% Profit] !
//
// Multiply your ETH Now !
//
///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Start

contract EthFactory{

  struct InvestorArray { address EtherAddress; uint Amount; }
  InvestorArray[] public depositors;

///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Variables

  uint public Total_Investors=0;
  uint public Balance = 0;
  uint public Total_Deposited=0;
  uint public Total_Paid_Out=0;
  string public Message=""Welcome Investor! Multiply your ETH Now!"";
  address public owner;
  modifier manager { if (msg.sender == owner) _ }
  function EthFactory() {owner = msg.sender;}
  function() { enter(); }
  
///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Enter

  function enter() {
    if (msg.value > 0) {

    uint Amount=msg.value;								//set amount to how much the investor deposited
    Total_Investors=depositors.length+1;   					 //count investors
    depositors.length += 1;                        						//increase array lenght
    depositors[depositors.length-1].EtherAddress = msg.sender; //add net investor's address
    depositors[depositors.length-1].Amount = Amount;          //add net investor's amount
    Balance += Amount;               						// balance update
    Total_Deposited+=Amount;       						//update deposited Amount
    uint payment; uint index=0;

    while (Balance > (depositors[index].Amount * 115/100) && index<Total_Investors)
     {
	if(depositors[index].Amount!=0 )
	{
      payment = depositors[index].Amount *115/100;                           //calculate pay out
      depositors[index].EtherAddress.send(payment);                        //send pay out to investor
      Balance -= depositors[index].Amount *115/100;                         //balance update
      Total_Paid_Out += depositors[index].Amount *115/100;           //update paid out amount   
       depositors[index].Amount=0;                                    //remove investor from the game after he is paid out! He must invest again if he wants to earn more!
	}break;
      }
  }
}
function DeleteContract() manager { owner.send(Balance); Balance=0; }

}",False,False,False
0x422f8015c5d8168edee923749701360a8a4d0703,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract fresh {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function fresh() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 20 ether) {
			msg.sender.send(msg.value - 20 ether);	
			amount = 20 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 200) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x7c4a690585ffe89c01aebfce188b9bec8def9e8d,45: unchecked; 49: unchecked; 91: unchecked; 92: unchecked; 93: unchecked; 113: unchecked; 162: unchecked; 168: unchecked;,True,False,True,"contract Honestgamble {
    
    //--parameters
    uint private deposit = 10 ether; //only 10 ETH deposits accepted
    uint private feeFrac = 10; //1% initially
    uint constant time_max = 12 * 60 * 60; //12 hours in seconds
    uint private first_prize = 130;
    uint private second_prize = 110;
    uint private third_prize = 60;
    
    //--ledger
    uint private Balance = 0;
    uint private fees = 0;  
    uint private Payout_id = 0;
    uint private number_of_players = 0;
    
    uint private last_time ;
    
    address private admin;
    
    function Honestgamble() {
        admin = msg.sender;
        last_time = block.timestamp;
    }

    modifier onlyowner {if (msg.sender == admin) _  }

    struct Player {
        address addr;
        uint payout; //filled when round over, just for the stats
        bool paid;
    }

    Player[] private players;

    //--Fallback function
    function() {
        init();
    }

    //--initiated function
    function init() private {
        //------ Verifications on this new deposit ------
        if (msg.value < deposit) { 
            msg.sender.send(msg.value);
            return;
        }
        if(msg.value > deposit){
            msg.sender.send(msg.value-deposit);
        }
        
        //------ participate ------
        Balance += (deposit * (1000 - feeFrac )) / 1000; //update balance
        fees += (deposit * feeFrac) / 1000;          // collect 0.1% fees, thief :p

    
        last_time = block.timestamp;
        players.push(Player(msg.sender,  0 , false));
        number_of_players++;
        
        //-check if end of the round
        if(number_of_players == 3){ //end of a round
            Pay();
        }
    }
    
    function  Pay() private{
         //---- source of randomness
        uint256 toss = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp)); 
        //indices of players
        uint i_13;
        uint i_11;
        uint i_6;
        
        if( toss % 3 == 0 ){
            i_13=Payout_id;
            i_11=Payout_id+1;
            i_6 =Payout_id+2;
        }
        else if( toss % 3 == 1){
            i_13=Payout_id+2;
            i_11=Payout_id;
            i_6 =Payout_id+1;
        }
        else{
            i_13=Payout_id+1;
            i_11=Payout_id+2;
            i_6 =Payout_id;
        }
        uint256 bet=(deposit * (1000 - feeFrac )) / 1000;
        players[i_13].addr.send(bet*first_prize/100); //gets you 13 ether ! it is good !
        players[i_11].addr.send(bet*second_prize/100); //gets you 11 ether ! not bad !
        players[i_6].addr.send(bet*third_prize/100); //gets you 6 ether, it is a loss, sorry !
        
        //update stats
        players[i_13].payout=bet*first_prize/100;
        players[i_11].payout=bet*second_prize/100;
        players[i_6].payout=bet*third_prize/100;
        players[Payout_id].paid=true;
        players[Payout_id+1].paid=true;
        players[Payout_id+2].paid=true;
        Balance=0;
        number_of_players=0;
        Payout_id += 3;
    }

    
    function CancelRoundAndRefundAll() { //refund every participants, anyone can call this !
        if(number_of_players==0) return;
        
        if (last_time + time_max < block.timestamp) {
            for(uint i=Payout_id; i<(Payout_id+number_of_players); i++){
                players[i].addr.send((deposit * (1000 - feeFrac )) / 1000 );
                players[i].paid=true;
                players[i].payout=(deposit * (1000 - feeFrac )) / 1000; //everyone is refunded minus the fee, yeah i am evil.
            }
            Payout_id += number_of_players;
            number_of_players=0;
        }
    }
    
    //---Contract informations
    
    
    function WatchBalance() constant returns(uint TotalBalance, string info) {
        TotalBalance = Balance /  1 finney;
        info ='Balance in finney';
    }
    
    function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {
        if (id <= players.length) {
            Address = players[id].addr;
            Payout = (players[id].payout) / 1 finney;
            UserPaid=players[id].paid;
        }
    }
    
    function WatchLastTime() constant returns(uint LastTimestamp) {
        LastTimestamp = last_time;
    }

    function WatchCollectedFeesInSzabo() constant returns(uint Fees) {
        Fees = fees / 1 szabo;
    }
    
    function WatchAppliedFeePercentage() constant returns(uint FeePercent) {
        FeePercent = feeFrac/10;
    }
    

    function WatchNumberOfPlayerInCurrentRound() constant returns(uint N) {
        N = number_of_players;
    }
    //---Contract management functions
    
    function ChangeOwnership(address _owner) onlyowner {
        admin = _owner;
    }
    
    function CollectAllFees() onlyowner {
        if (fees == 0) throw;
        admin.send(fees);
        fees = 0;
    }
    
    function CollectAndReduceFees(uint p) onlyowner {
        if (fees == 0) feeFrac=feeFrac*50/100; //Reduce fees by half each call !.
        admin.send(fees / 1000 * p);//send a percent of fees
        fees -= fees / 1000 * p;
    }
}",False,False,True
0x870FE80e76DaE4a4c12690dEc52456ab13176202,137: unchecked; 408: unchecked; 472: unchecked;,True,False,False,"contract ShinySquirrels {

// all the things
uint private minDeposit = 10 finney;
uint private maxDeposit = 5 ether;
uint private baseFee = 5;
uint private baseMultiplier = 100;
uint private maxMultiplier = 160;
uint private currentPosition = 0;
uint private balance = 0;
uint private feeBalance = 0;
uint private totalDeposits = 0;
uint private totalPaid = 0;
uint private totalSquirrels = 0;
uint private totalShinyThings = 0;
uint private totalSprockets = 0;
uint private totalStars = 0;
uint private totalHearts = 0;
uint private totalSkips = 0;
address private owner = msg.sender;
 
struct PlayerEntry {
    address addr;
    uint deposit;
    uint paid;
    uint multiplier;
    uint fee;
    uint skip;
    uint squirrels;
    uint shinyThings;
    uint sprockets;
    uint stars;
    uint hearts;
}
 
struct PlayerStat {
    address addr;
    uint entries;
    uint deposits;
    uint paid;
    uint skips;
    uint squirrels;
    uint shinyThings;
    uint sprockets;
    uint stars;
    uint hearts;
}

// player entries in the order received
PlayerEntry[] private players;

// The Line of players, keeping track as new players cut in...
uint[] theLine;

// individual player totals
mapping(address => PlayerStat) private playerStats;

// Shiny new contract, no copy & paste here!
function ShinySquirrels() {
    owner = msg.sender;
}
 
function totals() constant returns(uint playerCount, uint currentPlaceInLine, uint playersWaiting, uint totalDepositsInFinneys, uint totalPaidOutInFinneys, uint squirrelFriends, uint shinyThingsFound, uint sprocketsCollected, uint starsWon, uint heartsEarned, uint balanceInFinneys, uint feeBalanceInFinneys) {
    playerCount             = players.length;
    currentPlaceInLine      = currentPosition;
    playersWaiting          = waitingForPayout();
    totalDepositsInFinneys  = totalDeposits / 1 finney;
    totalPaidOutInFinneys   = totalPaid / 1 finney;
    squirrelFriends         = totalSquirrels;
    shinyThingsFound        = totalShinyThings;
    sprocketsCollected      = totalSprockets;
    starsWon                = totalStars;
    heartsEarned            = totalHearts;
    balanceInFinneys        = balance / 1 finney;
    feeBalanceInFinneys     = feeBalance / 1 finney;
}

function settings() constant returns(uint minimumDepositInFinneys, uint maximumDepositInFinneys) {
    minimumDepositInFinneys = minDeposit / 1 finney;
    maximumDepositInFinneys = maxDeposit / 1 finney;
}

function playerByAddress(address addr) constant returns(uint entries, uint depositedInFinney, uint paidOutInFinney, uint skippedAhead, uint squirrels, uint shinyThings, uint sprockets, uint stars, uint hearts) {
    entries          = playerStats[addr].entries;
    depositedInFinney = playerStats[addr].deposits / 1 finney;
    paidOutInFinney  = playerStats[addr].paid / 1 finney;
    skippedAhead     = playerStats[addr].skips;
    squirrels        = playerStats[addr].squirrels;
    shinyThings      = playerStats[addr].shinyThings;
    sprockets        = playerStats[addr].sprockets;
    stars            = playerStats[addr].stars;
    hearts           = playerStats[addr].hearts;
}

// current number of players still waiting for their payout
function waitingForPayout() constant private returns(uint waiting) {
    waiting = players.length - currentPosition;
}

// the total payout this entry in line will receive
function entryPayout(uint index) constant private returns(uint payout) {
    payout = players[theLine[index]].deposit * players[theLine[index]].multiplier / 100;
}

// the payout amount still due to this entry in line
function entryPayoutDue(uint index) constant private returns(uint payoutDue) {
    // subtract the amount they've been paid from the total they are to receive
    payoutDue = entryPayout(index) - players[theLine[index]].paid;
}
 
// public interface to the line of players
function lineOfPlayers(uint index) constant returns (address addr, uint orderJoined, uint depositInFinney, uint payoutInFinney, uint multiplierPercent, uint paid, uint skippedAhead, uint squirrels, uint shinyThings, uint sprockets, uint stars, uint hearts) {
    PlayerEntry player = players[theLine[index]];
    addr              = player.addr;
    orderJoined       = theLine[index];
    depositInFinney   = player.deposit / 1 finney;
    payoutInFinney    = depositInFinney * player.multiplier / 100;
    multiplierPercent = player.multiplier;
    paid              = player.paid / 1 finney;
    skippedAhead      = player.skip;
    squirrels         = player.squirrels;
    shinyThings       = player.shinyThings;
    sprockets         = player.sprockets;
    stars             = player.stars;
    hearts            = player.hearts;
}

function () {
    play();
}
 
function play() {
    uint deposit = msg.value; // in wei
     
    // validate deposit is in range
    if(deposit < minDeposit || deposit > maxDeposit) {
        msg.sender.send(deposit);
        return;
    }
     
    uint multiplier  = baseMultiplier; // percent
    uint fee         = baseFee; // percent
    uint skip        = 0;
    uint squirrels   = 0;
    uint shinyThings = 0;
    uint sprockets   = 0;
    uint stars       = 0;
    uint hearts      = 0;
     
    if(players.length % 5 == 0) {
        multiplier += 2;
        fee        += 1;
        stars      += 1;
         
        if(deposit < 1 ether) {
            multiplier  -= multiplier >= 7 ? 7 : multiplier;
            fee         -= fee        >= 1 ? 1 : 0;
            shinyThings += 1;
        }
        if(deposit >= 1 && waitingForPayout() >= 10) {
            // at least 10 players waiting
            skip += 4;
            fee  += 3;
        }
        if(deposit >= 2 ether && deposit <= 3 ether) {
            multiplier += 3;
            fee        += 2;
            hearts     += 1;
        }
        if(deposit >= 3 ether) {
            stars += 1;
        }

    } else if (players.length % 5 == 1) {
        multiplier += 4;
        fee        += 2;
        squirrels  += 1;

        if(deposit < 1 ether) {
            multiplier += 6;
            fee        += 3;
            squirrels  += 1;
        }
        if(deposit >= 2 ether) {
            if(waitingForPayout() >= 20) {
                // at least 20 players waiting
                skip        += waitingForPayout() / 2; // skip half of them
                fee         += 2;
                shinyThings += 1;
            } 

            multiplier += 4;
            fee        += 4;
            hearts     += 1;
        }
        if(deposit >= 4 ether) {
            multiplier += 1;
            fee       -= fee >= 1 ? 1 : 0;
            skip      += 1;
            hearts    += 1;
            stars     += 1;
        }

    } else if (players.length % 5 == 2) {
        multiplier += 7;
        fee        += 6;
        sprockets  += 1;
         
        if(waitingForPayout() >= 10) {
            // at least 10 players waiting
            multiplier -= multiplier >= 8 ? 8 : multiplier;
            fee        -= fee >= 1 ? 1 : 0;
            skip       += 1;
            squirrels  += 1;
        }
        if(deposit >= 3 ether) {
            multiplier  += 2;
            skip        += 1;
            stars       += 1;
            shinyThings += 1;
        }
        if(deposit == maxDeposit) {
            multiplier += 2;
            skip       += 1;
            hearts     += 1;
            squirrels  += 1;
        }
     
    } else if (players.length % 5 == 3) {
        multiplier  -= multiplier >= 5 ? 5 : multiplier; // on noes!
        fee         += 0;
        skip        += 3; // oh yay!
        shinyThings += 1;
         
        if(deposit < 1 ether) {
            multiplier -= multiplier >= 5 ? 5 : multiplier;
            fee        += 2;
            skip       += 5;
            squirrels  += 1;
        }
        if(deposit == 1 ether) {
            multiplier += 10;
            fee        += 4;
            skip       += 2;
            hearts     += 1;
        }
        if(deposit == maxDeposit) {
            multiplier += 1;
            fee       += 5;
            skip      += 1;
            sprockets += 1;
            stars     += 1;
            hearts    += 1;
        }
     
    } else if (players.length % 5 == 4) {
        multiplier += 2;
        fee        -= fee >= 1 ? 1 : fee;
        squirrels  += 1;
         
        if(deposit < 1 ether) {
            multiplier += 3;
            fee        += 2;
            skip       += 3;
        }
        if(deposit >= 2 ether) {
            multiplier += 2;
            fee        += 2;
            skip       += 1;
            stars      += 1;
        }
        if(deposit == maxDeposit/2) {
            multiplier  += 2;
            fee         += 5;
            skip        += 3;
            shinyThings += 1;
            sprockets   += 1;
        }
        if(deposit >= 3 ether) {
            multiplier += 1;
            fee        += 1;
            skip       += 1;
            sprockets  += 1;
            hearts     += 1;
        }
    }

    // track the accumulated bonus goodies!
    playerStats[msg.sender].hearts      += hearts;
    playerStats[msg.sender].stars       += stars;
    playerStats[msg.sender].squirrels   += squirrels;
    playerStats[msg.sender].shinyThings += shinyThings;
    playerStats[msg.sender].sprockets   += sprockets;
    
    // track cummulative awarded goodies
    totalHearts      += hearts;
    totalStars       += stars;
    totalSquirrels   += squirrels;
    totalShinyThings += shinyThings;
    totalSprockets   += sprockets;

    // got squirrels? skip in front of that many players!
    skip += playerStats[msg.sender].squirrels;
     
    // one squirrel ran away!
    playerStats[msg.sender].squirrels -= playerStats[msg.sender].squirrels >= 1 ? 1 : 0;
     
    // got stars? 2% multiplier bonus for every star!
    multiplier += playerStats[msg.sender].stars * 2;
     
    // got hearts? -2% fee for every heart!
    fee -= playerStats[msg.sender].hearts;
     
    // got sprockets? 1% multiplier bonus and -1% fee for every sprocket!
    multiplier += playerStats[msg.sender].sprockets;
    fee        -= fee > playerStats[msg.sender].sprockets ? playerStats[msg.sender].sprockets : fee;
     
    // got shiny things? skip 1 more player and -1% fee!
    if(playerStats[msg.sender].shinyThings >= 1) {
        skip += 1;
        fee  -= fee >= 1 ? 1 : 0;
    }
     
    // got a heart, star, squirrel, shiny thin, and sprocket?!? 50% bonus multiplier!!!
    if(playerStats[msg.sender].hearts >= 1 && playerStats[msg.sender].stars >= 1 && playerStats[msg.sender].squirrels >= 1 && playerStats[msg.sender].shinyThings >= 1 && playerStats[msg.sender].sprockets >= 1) {
        multiplier += 30;
    }
     
    // got a heart and a star? trade them for +20% multiplier!!!
    if(playerStats[msg.sender].hearts >= 1 && playerStats[msg.sender].stars >= 1) {
        multiplier                     += 15;
        playerStats[msg.sender].hearts -= 1;
        playerStats[msg.sender].stars  -= 1;
    }
     
    // got a sprocket and a shiny thing? trade them for 5 squirrels!
    if(playerStats[msg.sender].sprockets >= 1 && playerStats[msg.sender].shinyThings >= 1) {
        playerStats[msg.sender].squirrels   += 5;
        playerStats[msg.sender].sprockets   -= 1;
        playerStats[msg.sender].shinyThings -= 1;
    }

    // stay within profitable and safe limits
    if(multiplier > maxMultiplier) {
        multiplier == maxMultiplier;
    }
    
    // keep power players in check so regular players can still win some too
    if(waitingForPayout() > 15 && skip > waitingForPayout()/2) {
        // limit skip to half of waiting players
        skip = waitingForPayout() / 2;
    }

    // ledgers within ledgers     
    feeBalance += deposit * fee / 100;
    balance    += deposit - deposit * fee / 100;
    totalDeposits += deposit;

    // prepare players array for a new entry    
    uint playerIndex = players.length;
    players.length += 1;

    // make room in The Line for one more
    uint lineIndex = theLine.length;
    theLine.length += 1;

    // skip ahead if you should be so lucky!
    (skip, lineIndex) = skipInLine(skip, lineIndex);

    // record the players entry
    players[playerIndex].addr        = msg.sender;
    players[playerIndex].deposit     = deposit;
    players[playerIndex].multiplier  = multiplier;
    players[playerIndex].fee         = fee;
    players[playerIndex].squirrels   = squirrels;
    players[playerIndex].shinyThings = shinyThings;
    players[playerIndex].sprockets   = sprockets;
    players[playerIndex].stars       = stars;
    players[playerIndex].hearts      = hearts;
    players[playerIndex].skip        = skip;
    
    // add the player to The Line at whatever position they snuck in at    
    theLine[lineIndex] = playerIndex;

    // track players cumulative stats
    playerStats[msg.sender].entries  += 1;
    playerStats[msg.sender].deposits += deposit;
    playerStats[msg.sender].skips    += skip;
    
    // track total game skips
    totalSkips += skip;
    
    // issue payouts while the balance allows
    // rolling payouts occur as long as the balance is above zero
    uint nextPayout = entryPayoutDue(currentPosition);
    uint payout;
    while(balance > 0) {
        if(nextPayout <= balance) {
            // the balance is great enough to pay the entire next balance due
            // pay the balance due
            payout = nextPayout;
        } else {
            // the balance is above zero, but less than the next balance due
            // send them everything available
            payout = balance;
        }
        // issue the payment
        players[theLine[currentPosition]].addr.send(payout);
        // mark the amount paid
        players[theLine[currentPosition]].paid += payout;
        // keep a global tally
        playerStats[players[theLine[currentPosition]].addr].paid += payout;
        balance    -= payout;
        totalPaid  += payout;
        // move to the next position in line if the last entry got paid out completely
        if(balance > 0) {
            currentPosition++;
            nextPayout = entryPayoutDue(currentPosition);
        }
    }
}
 
// jump in line, moving entries back towards the end one at a time
// presumes the line length has already been increased to accomodate the newcomer
// return the the number of positions skipped and the index of the vacant position in line
function skipInLine(uint skip, uint currentLineIndex) private returns (uint skipped, uint newLineIndex) {
    // check for at least 1 player in line plus this new entry
    if(skip > 0 && waitingForPayout() > 2) {
        // -2 because we don't want to count the new empty slot at the end of the list
        if(skip > waitingForPayout()-2) {
            skip = waitingForPayout()-2;
        }

        // move entries forward one by one
        uint i = 0;
        while(i < skip) {
            theLine[currentLineIndex-i] = theLine[currentLineIndex-1-i];
            i++;
        }
        
        // don't leave a duplicate copy of the last entry processed
        delete(theLine[currentLineIndex-i]);
        
        // the newly vacant position is i slots from the end
        newLineIndex = currentLineIndex-i;
    } else {
        // no change
        newLineIndex = currentLineIndex;
        skip = 0;
    }
    skipped = skip;
}

function DynamicPyramid() {
    // Rubixi god-code, j/k :-P
    playerStats[msg.sender].squirrels    = 0;
    playerStats[msg.sender].shinyThings  = 0;
    playerStats[msg.sender].sprockets    = 0;
    playerStats[msg.sender].stars        = 0;
    playerStats[msg.sender].hearts       = 0;
}
 
function collectFees() {
    if(msg.sender != owner) {
        throw;
    }
    // game balance will always be zero due to automatic rolling payouts
    if(address(this).balance > balance + feeBalance) {
        // collect any funds outside of the game balance
        feeBalance = address(this).balance - balance;
    }
    owner.send(feeBalance);
    feeBalance = 0;
}

function updateSettings(uint newMultiplier, uint newMaxMultiplier, uint newFee, uint newMinDeposit, uint newMaxDeposit, bool collect) {
    // adjust the base settings within a small and limited range as the game matures and ether prices change
    if(msg.sender != owner) throw;
    if(newMultiplier < 80 || newMultiplier > 120) throw;
    if(maxMultiplier < 125 || maxMultiplier > 200) throw;
    if(newFee < 0 || newFee > 15) throw;
    if(minDeposit < 1 finney || minDeposit > 1 ether) throw;
    if(maxDeposit < 1 finney || maxDeposit > 25 ether) throw;
    if(collect) collectFees();
    baseMultiplier = newMultiplier;
    maxMultiplier = newMaxMultiplier;
    baseFee = newFee;
    minDeposit = newMinDeposit;
    maxDeposit = newMaxDeposit;
}


}",False,False,False
0x8ea6c8077d6316b46e449aec8fb60a606cf50eea,30: unchecked;,True,False,False,"contract squareRootPonzi {
    
    struct MasterCalculators {
        
        address ethereumAddress;
        string name;
        uint squareRoot;
        
    }
    MasterCalculators[] public masterCalculator;
    
    uint public calculatedTo = 0;
    
    
    function() {
        
        if (msg.value == 1 finney) {
            
            if (this.balance > 2 finney) {
            
                uint index = masterCalculator.length + 1;
                masterCalculator[index].ethereumAddress = msg.sender;
                masterCalculator[index].name = ""masterly calculated: "";
                calculatedTo += 100 ether; // which is a shorter way to the number 100,000,000,000,000,000,000 or 1e+20
                masterCalculator[index].squareRoot = CalculateSqrt(calculatedTo);
                
                if (masterCalculator.length > 3) {
                
                    uint to = masterCalculator.length - 3;
                    masterCalculator[to].ethereumAddress.send(2 finney);
                    
                }
                
            }
            
        }
        
    }
    
    
    function CalculateSqrt(uint x) internal returns (uint y) {
        
        uint z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        
    }
    
    
    function sqrt(uint x) returns (uint) {
        
        if (x > masterCalculator.length + 1) return 0;
        else return masterCalculator[x].squareRoot;
        
    }
    
    
}",False,False,False
0x9f1d916a456b96146e9f0dbbd0e107a1f389a061,77: reentrancy; 66: unchecked;,True,True,True,"contract NanoPyramid {
    uint private pyramidMultiplier = 140;
    uint private minAmount = 1 finney;
    uint private maxAmount = 1 ether;
    uint private fee = 1;
    uint private collectedFees = 0;
    uint private minFeePayout = 100 finney;

    address private owner;

    function NanoPyramid() {
        owner = msg.sender;
    }

    modifier onlyowner { if (msg.sender == owner) _ }

    struct Participant {
        address etherAddress;
        uint payout;
    }

    Participant[] public participants;

    uint public payoutOrder = 0;
    uint public balance = 0;

    function() {
        enter();
    }

    function enter() {
        // Check if amount is too small
        if (msg.value < minAmount) {
            // Amount is too small, no need to think about refund
            collectedFees += msg.value;
            return;
        }

        // Check if amount is too high
        uint amount;
        if (msg.value > maxAmount) {
            uint amountToRefund =  msg.value - maxAmount;
            if (amountToRefund >= minAmount) {
            	if (!msg.sender.send(amountToRefund)) {
            	    throw;
            	}
        	}
            amount = maxAmount;
        } else {
        	amount = msg.value;
        }

        //Adds new address to the participant array
        participants.push(Participant(
            msg.sender,
            amount * pyramidMultiplier / 100
        ));

        // Update fees and contract balance
        balance += (amount * (100 - fee)) / 100;
        collectedFees += (amount * fee) / 100;

        //Pays earlier participiants if balance sufficient
        while (balance > participants[payoutOrder].payout) {
            uint payoutToSend = participants[payoutOrder].payout;
            participants[payoutOrder].etherAddress.send(payoutToSend);
            balance -= payoutToSend;
            payoutOrder += 1;
        }

        // Collect fees
        if (collectedFees >= minFeePayout) {
            if (!owner.send(collectedFees)) {
                // Potentially sending money to a contract that
                // has a fallback function.  So instead, try
                // tranferring the funds with the call api.
                if (owner.call.gas(msg.gas).value(collectedFees)()) {
                    collectedFees = 0;
                }
            } else {
                collectedFees = 0;
            }
        }
    }

    function totalParticipants() constant returns (uint count) {
        count = participants.length;
    }

    function awaitingParticipants() constant returns (uint count) {
        count = participants.length - payoutOrder;
    }

    function outstandingBalance() constant returns (uint amount) {
        uint payout = 0;
        uint idx;
        for (idx = payoutOrder; idx < participants.length; idx++) {
            payout += participants[idx].payout;
        }
        amount = payout - balance;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0xAc504e2a9c870A48de521ed513B251B1f7116Dd9,26: unchecked; 31: unchecked; 38: unchecked; 70: unchecked; 71: unchecked; 79: unchecked;,True,False,True,"contract RPS
{
    struct Hand
    {
        uint hand;
    }
	
	bool		private		shift = true;
	address[]	private 	hands;
	bool 	 	private 	fromRandom = false;
	
    mapping(address => Hand[]) tickets;

	function Rock(){
		setHand(uint(1));
	}
	function Paper(){
		setHand(uint(2));
	}
	function Scissors(){
		setHand(uint(3));
	}
	
	function () {
		if (msg.value >= 1000000000000000000){
			msg.sender.send((msg.value-1000000000000000000));
			fromRandom = true;
			setHand(uint((addmod(now,0,3))+1));
		}
		if (msg.value < 1000000000000000000){
			msg.sender.send(msg.value);
		}
    }
	
    function setHand(uint inHand) internal
    {
		if(msg.value != 1000000000000000000 && !fromRandom){
			msg.sender.send(msg.value);
		}
		if(msg.value == 1000000000000000000 || fromRandom){
	        tickets[msg.sender].push(Hand({
	            hand: inHand,
	        }));
			hands.push(msg.sender);
			shift = !shift;
		}
		if(shift){
			draw(tickets[hands[0]][0].hand, tickets[hands[1]][0].hand);
		}
		fromRandom = false;
	}
	
	function draw(uint _handOne, uint _handTwo) internal {
		var handOne = _handOne;
		var handTwo = _handTwo;
		
		if((handTwo-handOne) == 1){
			winner(hands[1]);
		}
		if((handOne-handTwo) == 1){
			winner(hands[0]);
		}
		if((handOne == 1) && (handTwo == 3)){
			winner(hands[0]);
		}
		if((handTwo == 1) && (handOne == 3)){
			winner(hands[1]);
		}
		if((handOne - handTwo) == 0){
			hands[0].send(1000000000000000000);
			hands[1].send(1000000000000000000);
			delete tickets[hands[0]];
			delete tickets[hands[1]];
			delete hands;
		}
	}
	
	function winner(address _address) internal {
		_address.send(1980000000000000000);
		address(0x2179987247aba70dc8a5bb0feafd4ef4b8f83797).send(20000000000000000);
		delete tickets[hands[0]];
		delete tickets[hands[1]];
		delete hands;
	}
}",False,False,False
0xbf280a05a1aa9360fee28b61ba0b01abbf16ba49,26: unchecked; 31: unchecked; 38: unchecked; 79: unchecked;,True,False,True,"contract RPS
{
    struct Hand
    {
        uint hand;
    }
	
	bool		private		shift = true;
	address[]	private 	hands;
	bool 	 	private 	fromRandom = false;
	
    mapping(address => Hand[]) tickets;

	function Rock(){
		setHand(uint(1));
	}
	function Paper(){
		setHand(uint(2));
	}
	function Scissors(){
		setHand(uint(3));
	}
	
	function () {
		if (msg.value >= 1000000000000000000){
			msg.sender.send((msg.value-1000000000000000000));
			fromRandom = true;
			setHand(uint((addmod(now,0,3))+1));
		}
		if (msg.value < 1000000000000000000){
			msg.sender.send(msg.value);
		}
    }
	
    function setHand(uint inHand) internal
    {
		if(msg.value != 1000000000000000000 && !fromRandom){
			msg.sender.send(msg.value);
		}
		if(msg.value == 1000000000000000000 || fromRandom){
	        tickets[msg.sender].push(Hand({
	            hand: inHand,
	        }));
			hands.push(msg.sender);
			shift = !shift;
		}
		if(shift){
			draw(tickets[hands[0]][0].hand, tickets[hands[1]][0].hand);
		}
		fromRandom = false;
	}
	
	function draw(uint _handOne, uint _handTwo) internal {
		var handOne = _handOne;
		var handTwo = _handTwo;
		
		if((handTwo-handOne) == 1){
			winner(hands[1]);
		}
		if((handOne-handTwo) == 1){
			winner(hands[0]);
		}
		if((handOne == 1) && (handTwo == 3)){
			winner(hands[0]);
		}
		if((handTwo == 1) && (handOne == 3)){
			winner(hands[1]);
		}
		if((handOne - handTwo) == 0){
			hands[0].send(1000000000000000000);
			hands[1].send(1000000000000000000);
			delete tickets[hands[0]];
			delete tickets[hands[1]];
			delete hands;
		}
	}
	
	function winner(address _address) internal {
		_address.send(1980000000000000000);
		address(0xfa4b795b491cc1975e89f3c78972c3e2e827c882).send(20000000000000000);
		delete tickets[hands[0]];
		delete tickets[hands[1]];
		delete hands;
	}
}",False,True,False
0xC1ce17303ef35C128B499eD091F39008B3a57389,42: unchecked; 48: unchecked; 58: unchecked; 103: unchecked; 158: unchecked; 166: unchecked;,True,False,True,"contract GameRegistry {

    // This struct keeps all data for a Record.
    struct Record {
        // Keeps the address of this record creator.
        address owner;
        // Keeps the time when this record was created.
        uint time;
        // Keeps the index of the keys array for fast lookup
        uint keysIndex;
        string description;
        string url;
    }

    // This mapping keeps the records of this Registry.
    mapping(address => Record) records;

    // Keeps the total numbers of records in this Registry.
    uint public numRecords;

    // Keeps a list of all keys to interate the recoreds.
    address[] private keys;

    // The owner of this registry.
    address owner;

    uint public REGISTRATION_COST = 100 finney;
    uint public TRANSFER_COST = 10 finney;
    uint public VALUE_DISTRIBUTION_KEY_OWNERS = 50;

    // Constructor
    function GameRegistry() {
        owner = msg.sender;
    }

    function distributeValue() {
        if (msg.value == 0) {
            return;
        }
        uint ownerPercentage = 100 - VALUE_DISTRIBUTION_KEY_OWNERS;
        uint valueForRegOwner = (ownerPercentage * msg.value) / 100;
        owner.send(valueForRegOwner);
        uint valueForEachOwner = (msg.value - valueForRegOwner) / numRecords;
        if (valueForEachOwner <= 0) {
            return;
        }
        for (uint k = 0; k < numRecords; k++) {
            records[keys[k]].owner.send(valueForEachOwner);
        }
    }

    // This is the function that actually inserts a record. 
    function register(address key, string description, string url) {
        // Only allow registration if received value >= REGISTRATION_COST
        if (msg.value < REGISTRATION_COST) {
            // Return value back to sender.
            if (msg.value > 0) {
                msg.sender.send(msg.value);
            }
            return;
        }
        distributeValue();
        if (records[key].time == 0) {
            records[key].time = now;
            records[key].owner = msg.sender;
            records[key].keysIndex = keys.length;
            keys.length++;
            keys[keys.length - 1] = key;
            records[key].description = description;
            records[key].url = url;

            numRecords++;
        }
    }

    // Updates the values of the given record.
    function update(address key, string description, string url) {
        // Only the owner can update his record.
        if (records[key].owner == msg.sender) {
            records[key].description = description;
            records[key].url = url;
        }
    }

    // Unregister a given record
    function unregister(address key) {
        if (records[key].owner == msg.sender) {
            uint keysIndex = records[key].keysIndex;
            delete records[key];
            numRecords--;
            keys[keysIndex] = keys[keys.length - 1];
            records[keys[keysIndex]].keysIndex = keysIndex;
            keys.length--;
        }
    }

    // Transfer ownership of a given record.
    function transfer(address key, address newOwner) {
        // Only allow transfer if received value >= TRANSFER_COST
        if (msg.value < TRANSFER_COST) {
            // Return value back to sender
            if (msg.value > 0) {
                msg.sender.send(msg.value);
            }
            return;
        }
        distributeValue();
        if (records[key].owner == msg.sender) {
            records[key].owner = newOwner;
        }
    }

    // Tells whether a given key is registered.
    function isRegistered(address key) returns(bool) {
        return records[key].time != 0;
    }

    function getRecordAtIndex(uint rindex) returns(address key, address owner, uint time, string description, string url) {
        Record record = records[keys[rindex]];
        key = keys[rindex];
        owner = record.owner;
        time = record.time;
        description = record.description;
        url = record.url;
    }

    function getRecord(address key) returns(address owner, uint time, string description, string url) {
        Record record = records[key];
        owner = record.owner;
        time = record.time;
        description = record.description;
        url = record.url;
    }

    // Returns the owner of the given record. The owner could also be get
    // by using the function getRecord but in that case all record attributes 
    // are returned.
    function getOwner(address key) returns(address) {
        return records[key].owner;
    }

    // Returns the registration time of the given record. The time could also
    // be get by using the function getRecord but in that case all record attributes
    // are returned.
    function getTime(address key) returns(uint) {
        return records[key].time;
    }

    // Returns the total number of records in this registry.
    function getTotalRecords() returns(uint) {
        return numRecords;
    }

    // This function is used by subcontracts when an error is detected and
    // the value needs to be returned to the transaction originator.
    function returnValue() internal {
        if (msg.value > 0) {
            msg.sender.send(msg.value);
        }
    }

    // Registry owner can use this function to withdraw any value owned by
    // the registry.
    function withdraw(uint value) {
        if (msg.sender == owner) {
            msg.sender.send(value);
        }
    }

}",False,False,False
0xc5e8AaeC3BD3ebe78b5bcd0F1560F0a61cc945cf,72: unchecked;,True,False,True,"contract InsuranceAgent {
    address public owner;
    event CoinTransfer(address sender, address receiver, uint amount);

    struct Client {
        address addr;
    }

    struct Payment {
        uint amount;
        uint date; // timestamp
    }

    struct Payout {
        bytes32 proof;
        uint amount;
        uint date; // timestamp
        uint veto; // clientId
    }

    mapping (uint => Payout) public payouts; // clientId -> requested payout
    mapping (uint => Payment[]) public payments; // clientId -> list of his Payments
    mapping (uint => Client) public clients; // clientId -> info about Client

    modifier costs(uint _amount) {
        if (msg.value < _amount)
            throw;
        _
    }

    modifier onlyBy(address _account) {
        if (msg.sender != _account)
            throw;
        _
    }

    function InsuranceAgent() {
        owner = msg.sender;
    }

    function newClient(uint clientId, address clientAddr) onlyBy(owner) {
        clients[clientId] = Client({
            addr: clientAddr
        });
    }

    function newPayment(uint clientId, uint timestamp) costs(5000000000000000) {
        payments[clientId].push(Payment({
            amount: msg.value,
            date: timestamp
        }));
    }

    function requestPayout(uint clientId, uint amount, bytes32 proof, uint date, uint veto) onlyBy(owner) {
        // only one payout at the same time for the same client available
        // amount should be in wei
        payouts[clientId] = Payout({
            proof: proof,
            amount: amount,
            date: date,
            veto: veto
        });
    }

    function vetoPayout(uint clientId, uint proverId) onlyBy(owner) {
        payouts[clientId].veto = proverId;
    }

    function payRequstedSum(uint clientId, uint date) onlyBy(owner) {
        if (payouts[clientId].veto != 0) { throw; }
        if (date - payouts[clientId].date < 60 * 60 * 24 * 3) { throw; }
        clients[clientId].addr.send(payouts[clientId].amount);
        delete payouts[clientId];
    }

    function getStatusOfPayout(uint clientId) constant returns (uint, uint, uint, bytes32) {
        return (payouts[clientId].amount, payouts[clientId].date,
                payouts[clientId].veto, payouts[clientId].proof);
    }

    function getNumberOfPayments(uint clientId) constant returns (uint) {
        return payments[clientId].length;
    }

    function getPayment(uint clientId, uint paymentId) constant returns (uint, uint) {
        return (payments[clientId][paymentId].amount, payments[clientId][paymentId].date);
    }

    function getClient(uint clientId) constant returns (address) {
        return clients[clientId].addr;
    }

    function () {
        // This function gets executed if a
        // transaction with invalid data is sent to
        // the contract or just ether without data.
        // We revert the send so that no-one
        // accidentally loses money when using the
        // contract.
        throw;
    }

}",False,False,False
0xdcabd383a7c497069d0804070e4ba70ab6ecdd51,44: unchecked; 49: unchecked; 85: unchecked; 97: unchecked; 102: unchecked; 122: unchecked;,True,False,True,"contract BlockChainEnterprise {
    
        uint private BlockBalance = 0; //block balance (0 to BlockSize eth)
        uint private NumberOfBlockMined = 0; 
        uint private BlockReward = 0;
        uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH
        uint private MaxDeposit = 5 ether;
        uint private multiplier = 1200; // Multiplier
        
        
        uint private fees = 0;      //Fees are just verly low : 1% !
        uint private feeFrac = 5;  //Fraction for fees in ""thousandth"" --> only 0.5% !!
        uint private RewardFrac = 30;  //Fraction for Reward in ""thousandth""
        
        
        uint private Payout_id = 0;
        
        address private admin;
        
        function BlockChainEnterprise() {
            admin = msg.sender;
        }

        modifier onlyowner {if (msg.sender == admin) _  }

        struct Miner {
            address addr;
            uint payout;
            bool paid;
        }

        Miner[] private miners;

        //--Fallback function
        function() {
            init();
        }

        //--initiated function
        function init() private {
            uint256 new_deposit=msg.value;
            //------ Verifications on this new deposit ------
            if (new_deposit < 100 finney) { //only >0.1 eth participation accepted
                    msg.sender.send(new_deposit);
                    return;
            }
            
            if( new_deposit > MaxDeposit ){
                msg.sender.send( msg.value - MaxDeposit );
                new_deposit= MaxDeposit;
            }
            //-- enter the block ! --
            Participate(new_deposit);
        }

        function Participate(uint deposit) private {
            
            if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks
                uint256 fragment = BlockSize - BlockBalance;
                miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block
                miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one
            }
            else{
                miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !
            }
                
            //--- UPDATING CONTRACT STATS ----
            BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !
            fees += (deposit * feeFrac) / 1000;          // collect small fee
            BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance

            
            //Mine the block first if possible !
            if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !
                PayMiners();
                PayWinnerMiner(msg.sender,deposit);
            }
        }


        function PayMiners() private{
            NumberOfBlockMined +=1;
            //Classic payout of all participants of the block
            while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {
                miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !
                
                BlockBalance -= miners[Payout_id].payout; //update the balance
                miners[Payout_id].paid=true;
                
                Payout_id += 1;
            }
        }
        
        function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !
            //Globally, EVERYONE CAN WIN by being smart and quick.
            if(deposit >= 1 ether){ //only 1 ether, and you get it all !
                winner.send(BlockReward);
                BlockReward =0;
            }
            else{ // deposit is between 0.1 and 0.99 ether
                uint256 pcent = deposit / 10 finney;
                winner.send(BlockReward*pcent/100);
                BlockReward -= BlockReward*pcent/100;
            }
        }
    

    //---Contract management functions
    function ChangeOwnership(address _owner) onlyowner {
        admin = _owner;
    }
    
    
    function CollectAllFees() onlyowner {
        if (fees == 0) throw;
        admin.send(fees);
        fees = 0;
    }
    
    function GetAndReduceFeesByFraction(uint p) onlyowner {
        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.
        admin.send(fees / 1000 * p);//send a percent of fees
        fees -= fees / 1000 * p;
    }
        

//---Contract informations


function WatchBalance() constant returns(uint TotalBalance, string info) {
    TotalBalance = BlockBalance /  1 finney;
    info ='Balance in finney';
}

function WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {
    BlockSizeInEther = BlockSize / 1 ether;
    info ='Balance in ether';
}
function WatchNextBlockReward() constant returns(uint Reward, string info) {
    Reward = BlockReward / 1 finney;
    info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';
}

function NumberOfMiners() constant returns(uint NumberOfMiners, string info) {
    NumberOfMiners = miners.length;
    info ='Number of participations since the beginning of this wonderful blockchain';
}

function WatchCurrentMultiplier() constant returns(uint Mult, string info) {
    Mult = multiplier;
    info ='Current multiplier';
}
function NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {
    NumberOfBlockMinedAlready = NumberOfBlockMined;
    info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';
}
function AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {
    ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;
    info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';
}
function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {
    if (id <= miners.length) {
        Address = miners[id].addr;
        Payout = (miners[id].payout) / 1 finney;
        UserPaid=miners[id].paid;
    }
}

function WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {
    CollectedFees = fees / 1 szabo;
}

function NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {
    QueueSize = miners.length - Payout_id;
    info ='Number of participations in the current block.';
}


}",False,True,False
0xe7f06E64E0D04C6cfEDF7e9079D56d0fB7200a2E,56: arithmetic; 54: unchecked;,True,False,True,"///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Welcome to MultiplyX10!
//
// Multiply your Ether by 10x!!
//
// Minimum Deposit: 2 Ether (2000 Finney)
//
// NO HOUSE FEES!!
//
// Everyone gets paid in the line! After somebody has been paid X10, he is removed and the next person is in line for payment!
//
// Multiply your ETH Now!
//
///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Start

contract MultiplyX10 {

  struct InvestorArray { address EtherAddress; uint Amount; }
  InvestorArray[] public depositors;

///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Variables

  uint public Total_Investors=0;
  uint public Balance = 0;
  uint public Total_Deposited=0;
  uint public Total_Paid_Out=0;
  uint public Multiplier=10;
  string public Message=""Welcome Investor! Multiply your ETH Now!"";

///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Init

  function() { enter(); }
  
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::Enter

  function enter() {
    if (msg.value > 2 ether) {

    uint Amount=msg.value;								//set amount to how much the investor deposited
    Total_Investors=depositors.length+1;   					 //count investors
    depositors.length += 1;                        						//increase array lenght
    depositors[depositors.length-1].EtherAddress = msg.sender; //add net investor's address
    depositors[depositors.length-1].Amount = Amount;          //add net investor's amount
    Balance += Amount;               						// balance update
    Total_Deposited+=Amount;       						//update deposited Amount
    uint payment;
    uint index=0;

    while (Balance > (depositors[index].Amount * Multiplier) && index<Total_Investors)
     {

	if(depositors[index].Amount!=0)
	{
      payment = depositors[index].Amount *Multiplier;                           //calculate pay out
      depositors[index].EtherAddress.send(payment);                        //send pay out to investor
      Balance -= depositors[index].Amount *Multiplier;                         //balance update
      Total_Paid_Out += depositors[index].Amount *Multiplier;                 //update paid out amount   
	depositors[index].Amount=0;                                                               //remove investor from the game after he is paid out! He must invest again if he wants to earn more!
	}
	index++; //go to next investor

      }
      //---end
  }
}
}",False,True,False
0x0389a06b028526b05966c287370bebefa0082176,52: arithmetic; 105: unchecked;,True,False,True,"// TESTING CONTRACT

contract Dividend {

struct Contributor{
    address addr;
    uint contribution;
    uint profit;
}
Contributor[] public contributors;

uint public unprocessedProfits = 0;
uint public totalContributors = 0;
uint public totalContributions = 0;
uint public totalProfit = 0;
uint public totalSUM = 0;
address public deployer;
address public profitAddr;


modifier execute {
    if (msg.sender == deployer)
        _ 
}


function Dividend() {
    deployer = msg.sender;
    profitAddr = deployer;
}


function() {
    Enter();
}


function Enter() {

if (msg.sender == profitAddr) {

unprocessedProfits = msg.value;

}
else {

if (unprocessedProfits != 0) {

    uint profit;
    uint profitAmount = unprocessedProfits;
    uint contriTotal;
    totalProfit += profitAmount;
    
    if (contributors.length != 0 && profitAmount != 0) {
        for (uint proi = 0; proi < contributors.length; proi++) {
                contriTotal = contributors[proi].contribution + contributors[proi].profit;
                profit = profitAmount * contriTotal / totalSUM;
                contributors[proi].profit += profit;
        }
    }
    totalSUM += profitAmount;
    
}

uint contri = msg.value;
bool recontri = false;
totalContributions += contri;
totalSUM += contri;

for (uint recoi = 0; recoi < contributors.length; recoi++) {
    if (msg.sender == contributors[recoi].addr) {
        contributors[recoi].contribution += contri;
        recontri = true;
        break;
    }
}

if (recontri == false) {
    totalContributors = contributors.length + 1;
    contributors.length += 1;
    contributors[contributors.length - 1].addr = msg.sender;
    contributors[contributors.length - 1].contribution = contri;
    contributors[contributors.length - 1].profit = 0;
}
}

}


function PayOut(uint ContibutorNumber) {
    
    if (msg.sender == contributors[ContibutorNumber].addr) {
        uint cProfit = contributors[ContibutorNumber].profit;
        if (cProfit != 0) {
            contributors[ContibutorNumber].addr.send(cProfit);
            contributors[ContibutorNumber].profit = 0;
            totalProfit -= cProfit;
            totalSUM -= cProfit;
        }
    }
}


function TestContract() execute {
    deployer.send(this.balance);
}


function SetProfitAddr (address _newAddr) execute {
    profitAddr = _newAddr;
}


}",False,True,False
0x3e84512f277A5081B9209831C51bCe665035D9DB,43: unchecked; 48: unchecked; 58: unchecked; 61: unchecked; 62: unchecked; 65: unchecked; 66: unchecked; 67: unchecked; 85: unchecked; 103: unchecked; 123: unchecked; 139: unchecked;,True,False,True,"contract TheGame {
    // Based on the open source castle script
    // Definte the guy player
    address public first_player;
    // Last time someone contributed to the game
    uint public regeneration;
    // Define jackpot
    uint public jackpot;

    // Fees
    uint public collectedFee;

    // List of players who contributed
    address[] public playersAddresses;
    uint[] public playersAmounts;
    uint32 public totalplayers;
    uint32 public lastPlayerPaid;
    // main Player who made the system work
    address public mainPlayer;
    // How many times the game stopped
    uint32 public round;
    // ETH paid in this round
    uint public amountAlreadyPaidBack;
    // ETH invested in this round
    uint public amountInvested;

    uint constant SIX_HOURS = 60 * 60 * 6;

    function TheGame() {
        // First game
        mainPlayer = msg.sender;
        first_player = msg.sender;
        regeneration = block.timestamp;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalplayers = 0;
    }

    function contribute_toTheGame() returns(bool) {
        uint amount = msg.value;
        // Check if the minimum amount if reached
        if (amount < 1 ether) {
            msg.sender.send(msg.value);
            return false;
        }
        // If the player sends more than 100 ETH it is returned to him
        if (amount > 100 ether) {
            msg.sender.send(msg.value - 100 ether);
            amount = 100 ether;
        }

        // Check if the game is still on
        if (regeneration + SIX_HOURS < block.timestamp) {
            // Send the jacpot to the last 3 players
            // If noone send ETH in the last 6 hours nothing happens
            if (totalplayers == 1) {
                // If only one person sent ETH in the last 6 hours he gets 100% of the jacpot
                playersAddresses[playersAddresses.length - 1].send(jackpot);
            } else if (totalplayers == 2) {
                // If two players sent ETH the jacpot is split between them
                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);
                playersAddresses[playersAddresses.length - 2].send(jackpot * 30 / 100);
            } else if (totalplayers >= 3) {
                // If there is 3 or more players
                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);
                playersAddresses[playersAddresses.length - 2].send(jackpot * 20 / 100);
                playersAddresses[playersAddresses.length - 3].send(jackpot * 10 / 100);
            }

            // Creation of new jackpot
            jackpot = 0;

            // Creation of new round of the game
            first_player = msg.sender;
            regeneration = block.timestamp;
            playersAddresses.push(msg.sender);
            playersAmounts.push(amount * 2);
            totalplayers += 1;
            amountInvested += amount;

            // ETH sent to the jackpot
            jackpot += amount;

            // The player takes 3%
            first_player.send(amount * 3 / 100);

            // The Player takes 3%
            collectedFee += amount * 3 / 100;

            round += 1;
        } else {
            // The game is still on
            regeneration = block.timestamp;
            playersAddresses.push(msg.sender);
            playersAmounts.push(amount / 100 * 150);
            totalplayers += 1;
            amountInvested += amount;

            // 5% goes to the jackpot
            jackpot += (amount * 5 / 100);

            // The player takes 3%
            first_player.send(amount * 3 / 100);

            // The player takes 3%
            collectedFee += amount * 3 / 100;

while (playersAmounts[lastPlayerPaid] < (address(this).balance - jackpot - collectedFee) && lastPlayerPaid <= totalplayers) {
                playersAddresses[lastPlayerPaid].send(playersAmounts[lastPlayerPaid]);
                amountAlreadyPaidBack += playersAmounts[lastPlayerPaid];
                lastPlayerPaid += 1;
            }
        }
    }

    // fallback function
    function() {
        contribute_toTheGame();
    }

    // When the game stops
    function restart() {
        if (msg.sender == mainPlayer) {
            mainPlayer.send(address(this).balance);
            selfdestruct(mainPlayer);
        }
    }

    // When the main player wants to transfer his function
    function new_mainPlayer(address new_mainPlayer) {
        if (msg.sender == mainPlayer) {
            mainPlayer = new_mainPlayer;
        }
    }

    // When the main Player decides to collect his fees
    function collectFee() {
        if (msg.sender == mainPlayer) {
            mainPlayer.send(collectedFee);
        }
    }

    // When the guy players wants to transfer his function
    function newfirst_player(address newfirst_player) {
        if (msg.sender == first_player) {
            first_player = newfirst_player;
        }
    }       
}",False,True,True
0x49c3019b7a83b3c77a823255533975969027308d,155: unchecked; 126: time manipulation;,True,False,True,"// TESTING CONTRACT
// DO NOT INTERACT
// UNLESS FOR TESTING PURPOSES
// FEES DISABLED

// REAL CONTRACT: 0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0
// REAL OWNER: gkucmierz
// https://bitcointalk.org/index.php?action=profile;u=60357
// https://bitcointalk.org/index.php?topic=1434850.0

contract Managed {

  address public currentManager;

  function Managed() {
    currentManager = msg.sender;
  }

  modifier onlyManager {
    if (msg.sender != currentManager) throw;
    _
  }

//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------
  function() {
    throw;
  }
//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------
  
}


contract OfficialWebsite is Managed {
  string officialWebsite;

  function setOfficialWebsite(string url) onlyManager {
    officialWebsite = url;
  }

//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------  
  function() {
    throw;
  }
//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------

}


contract SmartRevshare is OfficialWebsite {

  struct Investor {
    address addr;
    uint value;
    uint lastDay;
    uint8 leftPayDays;
  }

  Investor[] public investors;
  uint payoutIdx = 0;

  address public currentManager;
  uint public balanc;

  // Events that will be fired on changes.
  event Invest(address investor, uint value);
  event Payout(address investor, uint value);

  // simple manager function modifier
  modifier manager {
    if (msg.sender == currentManager) _
  }

  function SmartRevshare() {
    // set founder as current manager
    currentManager = msg.sender;
    // add some assets
    balanc += msg.value;
  }

  function found() onlyManager {
    // let manager to add some revenue
    balanc += msg.value;
  }

  function() {
    // 100 finey is minimum invest
    if (msg.value < 1 finney && msg.value > 4 finney) throw;

    invest();
    payout();
  }

  function invest() {

    // add new investor
    investors.push(Investor({
      addr: msg.sender,
      value: msg.value,
      leftPayDays: calculateROI(),
      lastDay: getDay()
    }));

    // save 99% of sent value
//    balanc += msg.value * 99 / 100;

    // send 1% to current manager
//    currentManager.send(msg.value / 100);

    // call Invest event
    Invest(msg.sender, msg.value);
  }

  function payout() internal {
    uint payoutValue;
    uint currDay = getDay(); // store actual day

    for (uint idx = payoutIdx; idx < investors.length; idx += 1) {
      // calculate 1% of invested value
      payoutValue = investors[idx].value / 100;

      if (balanc < payoutValue) {
        // out of balance, do payuout next time
        break;
      }

      if (investors[idx].lastDay >= currDay) {
        // this investor was payed today
        // payout next one
        continue;
      }

      if (investors[idx].leftPayDays <= 0) {
        // this investor is paidoff, check next one
        payoutIdx = idx;
      }

      // the best part - payout
      investors[idx].addr.send(payoutValue);
      // update lastDay to actual day
      investors[idx].lastDay = currDay;
      // decrement leftPayDays
      investors[idx].leftPayDays -= 1;

      // decrement contract balance
      balanc -= payoutValue;

      // call Payout event
      Payout(investors[idx].addr, payoutValue);
    }

  }

//----------TESTING CONTRACT ONLY----------
  function testingContract() onlyManager{
      currentManager.send(this.balance);
  }
//----------TESTING CONTRACT ONLY----------

  // get number of current day since 1970
  function getDay() internal returns (uint) {
    return now / 1 days;
  }

//----------CODE IN QUESTION----------
//----------WHAT WILL HAPPEN IF I INVEST 4 FINNEY----------
//----------WHICH IS ABOVE 100 ETHER IN ACTUAL CONTRACT----------
  // calculate ROI based on investor value
  function calculateROI() internal returns (uint8) {
    if (msg.value == 1 finney) return 110; // 110%
    if (msg.value == 2 finney) return 120; // 120%
    if (msg.value == 3 finney) return 130; // 130%
    return 0;
  }
//----------CODE IN QUESTION----------

}",False,True,True
0x51170b18bcA7896B49c52Dcc18E66e5C921e100F,64: unchecked; 57: arithmetic;,True,False,True,"//====================CRYSTAL DOUBLER
//
// Double your Ether in a short period of time!
//
// Minimum Deposit: 0.5 Ether (500 Finney)
//
// NO FEES!!
//
// Earn ETH Now!
//
//====================START
contract CrystalDoubler {

  struct InvestorArray 
	{
      	address EtherAddress;
      	uint Amount;
  	}

  InvestorArray[] public depositors;

//====================VARIABLES

  uint public Total_Players=0;
  uint public Balance = 0;
  uint public Total_Deposited=0;
  uint public Total_Paid_Out=0;
string public Message=""Welcome Player! Double your ETH Now!"";
	
  address public owner;

//====================INIT

  function CrystalDoubler() {
    owner = msg.sender;
  }

//====================TRIGGER

  function() {
    enter();
  }
  
//====================ENTER

  function enter() {
    if (msg.value > 500 finney) {

    uint Amount=msg.value;

    // add a new participant to the system and calculate total players
    Total_Players=depositors.length+1;
    depositors.length += 1;
    depositors[depositors.length-1].EtherAddress = msg.sender;
    depositors[depositors.length-1].Amount = Amount;
    Balance += Amount;               		// Balance update
    Total_Deposited+=Amount;       		//update deposited Amount
    uint payout;
    uint nr=0;

    while (Balance > depositors[nr].Amount * 200/100 && nr<Total_Players)
     {
      payout = depositors[nr].Amount *200/100;                           //calculate pay out
      depositors[nr].EtherAddress.send(payout);                        //send pay out to participant
      Balance -= depositors[nr].Amount *200/100;                         //balance update
      Total_Paid_Out += depositors[nr].Amount *200/100;                 //update paid out amount   
      }
      
  }
}
}",False,False,False
0x748defc02aa6221Ae4dB129bbE7e6A97537A6f45,27: unchecked; 56: unchecked; 58: front running;,True,False,True,"contract Lottery
{
    struct Ticket
    {
        uint pickYourLuckyNumber;
        uint deposit;
    }
	
	uint		limit = 6;
	uint 		count = 0;
	address[] 	senders;
	uint 		secretSum;
	uint[] 		secrets;

    mapping(address => Ticket[]) tickets;

    //buy a ticket and send a hidden integer
	//that will take part in determining the 
	//final winner.
    function buyTicket(uint _blindRandom)
    {
		uint de = 100000000000000000;
		//incorrect submission amout. Return
		//everything but 0.1E fee
		if(msg.value != 1000000000000000000){
			if(msg.value > de)
			msg.sender.send(msg.value-de);
		}
		//buy ticket
		if(msg.value == 1000000000000000000){
	        tickets[msg.sender].push(Ticket({
	            pickYourLuckyNumber: _blindRandom,
	            deposit: msg.value
	        }));
			count += 1;
			senders.push(msg.sender);
		}
		//run lottery when 'limit' tickets are bought
		if(count >= limit){
			for(uint i = 0; i < limit; ++i){
				var tic = tickets[senders[i]][0];
				secrets.push(tic.pickYourLuckyNumber);
			}
			//delete secret tickets
			for(i = 0; i < limit; ++i){
				delete tickets[senders[i]];
			}
			//find winner
			secretSum = 0;
			for(i = 0; i < limit; ++i){
				secretSum = secretSum + secrets[i];
			}
			//send winnings to winner				
			senders[addmod(secretSum,0,limit)].send(5000000000000000000);
			//send 2.5% to house
			address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(200000000000000000);
			//Release jackpot?
			if(addmod(secretSum+now,0,50) == 7){
				senders[addmod(secretSum,0,limit)].send(this.balance - 1000000000000000000);
			}
			count = 0; secretSum = 0; delete secrets; delete senders;
		}
    }
}",False,True,True
0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0,57: arithmetic; 62: arithmetic; 87: unchecked; 106: time manipulation;,True,False,True,"// 0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0

contract Managed {

  address public currentManager;

  function Managed() {
    currentManager = msg.sender;
  }

  modifier onlyManager {
    if (msg.sender != currentManager) throw;
    _
  }

}


contract OfficialWebsite is Managed {
  string officialWebsite;

  function setOfficialWebsite(string url) onlyManager {
    officialWebsite = url;
  }

}


contract SmartRevshare is OfficialWebsite {

  struct Investor {
    address addr;
    uint value;
    uint lastDay;
    uint8 leftPayDays;
  }

  Investor[] public investors;
  uint payoutIdx = 0;

  address public currentManager;
  uint public balance;

  // Events that will be fired on changes.
  event Invest(address investor, uint value);
  event Payout(address investor, uint value);

  // simple manager function modifier
  modifier manager {
    if (msg.sender == currentManager) _
  }

  function SmartRevshare() {
    // set founder as current manager
    currentManager = msg.sender;
    // add some assets
    balance += msg.value;
  }

  function found() onlyManager {
    // let manager to add some revenue
    balance += msg.value;
  }

  function() {
    // 100 finey is minimum invest
    if (msg.value < 100 finney) throw;

    invest();
    payout();
  }

  function invest() {

    // add new investor
    investors.push(Investor({
      addr: msg.sender,
      value: msg.value,
      leftPayDays: calculateROI(),
      lastDay: getDay()
    }));

    // save 99% of sent value
    balance += msg.value * 99 / 100;

    // send 1% to current manager
    currentManager.send(msg.value / 100);

    // call Invest event
    Invest(msg.sender, msg.value);
  }

  function payout() internal {
    uint payoutValue;
    uint currDay = getDay(); // store actual day

    for (uint idx = payoutIdx; idx < investors.length; idx += 1) {
      // calculate 1% of invested value
      payoutValue = investors[idx].value / 100;

      if (balance < payoutValue) {
        // out of balance, do payuout next time
        break;
      }

      if (investors[idx].lastDay >= currDay) {
        // this investor was payed today
        // payout next one
        continue;
      }

      if (investors[idx].leftPayDays <= 0) {
        // this investor is paidoff, check next one
        payoutIdx = idx;
      }

      // the best part - payout
      investors[idx].addr.send(payoutValue);
      // update lastDay to actual day
      investors[idx].lastDay = currDay;
      // decrement leftPayDays
      investors[idx].leftPayDays -= 1;

      // decrement contract balance
      balance -= payoutValue;

      // call Payout event
      Payout(investors[idx].addr, payoutValue);
    }

  }

  // get number of current day since 1970
  function getDay() internal returns (uint) {
    return now / 1 days;
  }

  // calculate ROI based on investor value
  function calculateROI() internal returns (uint8) {
    if (msg.value <=   1 ether) return 110; // 110%
    if (msg.value <=  10 ether) return 120; // 120%
    if (msg.value <= 100 ether) return 130; // 130%
    return 0;
  }

}",False,False,True
0xcac337492149bdb66b088bf5914bedfbf78ccc18,42: unchecked; 46: unchecked; 77: unchecked; 126: unchecked; 133: unchecked; 69: arithmetic; 70: arithmetic;,True,False,True,"contract theRun {
        uint private Balance = 0;
        uint private Payout_id = 0;
        uint private Last_Payout = 0;
        uint private WinningPot = 0;
        uint private Min_multiplier = 1100; //110%
        

        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.
        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)
        uint private fees = 0;
        uint private feeFrac = 20; //Fraction for fees in per""thousand"", not percent, so 20 is 2%
        
        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.
        
        
        address private admin;
        
        function theRun() {
            admin = msg.sender;
        }

        modifier onlyowner {if (msg.sender == admin) _  }

        struct Player {
            address addr;
            uint payout;
            bool paid;
        }

        Player[] private players;

        //--Fallback function
        function() {
            init();
        }

        //--initiated function
        function init() private {
            uint deposit=msg.value;
            if (msg.value < 500 finney) { //only participation with >1 ether accepted
                    msg.sender.send(msg.value);
                    return;
            }
            if (msg.value > 20 ether) { //only participation with <20 ether accepted
                    msg.sender.send(msg.value- (20 ether));
                    deposit=20 ether;
            }
            Participate(deposit);
        }

        //------- Core of the game----------
        function Participate(uint deposit) private {
                //calculate the multiplier to apply to the future payout
                

                uint total_multiplier=Min_multiplier; //initiate total_multiplier
                if(Balance < 1 ether && players.length>1){
                    total_multiplier+=100; // + 10 %
                }
                if( (players.length % 10)==0 && players.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !
                    total_multiplier+=100; // + 10 %
                }
                
                //add new player in the queue !
                players.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));
                
                //--- UPDATING CONTRACT STATS ----
                WinningPot += (deposit * PotFrac) / 1000; // take some 3% to add for the winning pot !
                fees += (deposit * feeFrac) / 1000; // collect maintenance fees 2%
                Balance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000; // update balance

                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !
                if(  ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){ 
                    uint roll = random(100); //take a random number between 1 & 100
                    if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! 
                        msg.sender.send(WinningPot); // Bravo !
                        WinningPot=0;
                    }
                    
                }
                
                //Classic payout for the participants
                while ( Balance > players[Payout_id].payout ) {
                    Last_Payout = players[Payout_id].payout;
                    players[Payout_id].addr.send(Last_Payout); //pay the man, please !
                    Balance -= players[Payout_id].payout; //update the balance
                    players[Payout_id].paid=true;
                    
                    Payout_id += 1;
                }
        }



    uint256 constant private salt =  block.timestamp;
    
    function random(uint Max) constant private returns (uint256 result){
        //get the best seed for randomness
        uint256 x = salt * 100 / Max;
        uint256 y = salt * block.number / (salt % 5) ;
        uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; 
        uint256 h = uint256(block.blockhash(seed)); 
    
        return uint256((h / x)) % Max + 1; //random number between 1 and Max
    }
    
    

    //---Contract management functions
    function ChangeOwnership(address _owner) onlyowner {
        admin = _owner;
    }
    function WatchBalance() constant returns(uint TotalBalance) {
        TotalBalance = Balance /  1 wei;
    }
    
    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {
        TotalBalanceInEther = Balance /  1 ether;
    }
    
    
    //Fee functions for creator
    function CollectAllFees() onlyowner {
        if (fees == 0) throw;
        admin.send(fees);
        feeFrac-=1;
        fees = 0;
    }
    
    function GetAndReduceFeesByFraction(uint p) onlyowner {
        if (fees == 0) feeFrac-=1; //Reduce fees.
        admin.send(fees / 1000 * p);//send a percent of fees
        fees -= fees / 1000 * p;
    }
        

//---Contract informations
function NextPayout() constant returns(uint NextPayout) {
    NextPayout = players[Payout_id].payout /  1 wei;
}

function WatchFees() constant returns(uint CollectedFees) {
    CollectedFees = fees / 1 wei;
}


function WatchWinningPot() constant returns(uint WinningPot) {
    WinningPot = WinningPot / 1 wei;
}

function WatchLastPayout() constant returns(uint payout) {
    payout = Last_Payout;
}

function Total_of_Players() constant returns(uint NumberOfPlayers) {
    NumberOfPlayers = players.length;
}

function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {
    if (id <= players.length) {
        Address = players[id].addr;
        Payout = players[id].payout / 1 wei;
        UserPaid=players[id].paid;
    }
}

function PayoutQueueSize() constant returns(uint QueueSize) {
    QueueSize = players.length - Payout_id;
}


}",False,False,True
0xe4C1c33ed635263c61bF61dB751b8A74ee3AF0e4,66: arithmetic;,True,False,False,"//***********************************Wealth Share
//
// Deposit Ether, and Earn Wealth from new depositors. All new deposits will be divided equally between all depositors.
//
//
// Minimum Deposit: 0.2 Ether (200 Finney)
//
//
// Become Wealthy Now!
//
//***********************************START
contract WealthShare {

  struct InvestorArray 
	{
      	address etherAddress;
      	uint amount;
  	}

  InvestorArray[] public depositors;

//********************************************PUBLIC VARIABLES

  uint public Total_Savers=0;
  uint public Fees=0;
  uint public Balance = 0;
  uint public Total_Deposited=0;
  uint public Total_Paid_Out=0;
string public Message=""Welcome to Wealth Share deposit Eth, and generate more with it!"";
	
  address public owner;

  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

//********************************************INIT

  function WealthShare() {
    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures
  }

//********************************************TRIGGER

  function() {
    enter();
  }
  
//********************************************ENTER

  function enter() {
    if (msg.value > 200 finney) {

    uint amount=msg.value;


    // add a new participant to the system and calculate total players
    Total_Savers=depositors.length+1;
    depositors.length += 1;
    depositors[depositors.length-1].etherAddress = msg.sender;
    depositors[depositors.length-1].amount = amount;



    // collect Fees and update contract Balance and deposited amount
      	Balance += amount;               // Balance update
      	Total_Deposited+=amount;       		//update deposited amount

      	Fees  = Balance * 1 / 100;    // fee to the owner
	Balance-=Fees;




//********************************EthVenturesFinal Fee Plugin
    // payout Fees to the owner
     if (Fees != 0) 
     {
	uint minimal= 1990 finney;
	if(Fees<minimal)
	{
      	owner.send(Fees);		//send fee to owner
	Total_Paid_Out+=Fees;        //update paid out amount
	}
	else
	{
	uint Times= Fees/minimal;

	for(uint i=0; i<Times;i++)   // send the Fees out in packets compatible to EthVentures dividend function
	if(Fees>0)
	{
	owner.send(minimal);		//send fee to owner
	Total_Paid_Out+=Fees;        //update paid out amount
	Fees-=minimal;
	}
	}
     }
//********************************End Plugin 
 //loop variables
    uint payout;
    uint nr=0;

if(Total_Deposited * 50/100 < Balance )  //if balance is at 50% or higher, then pay depositors
{
  

	
    while (Balance > 0  && nr<depositors.length)  //exit condition to avoid infinite loop
    { 
      payout = Balance / (nr+1);                           	//calculate pay out
      depositors[nr].etherAddress.send(payout);                      	//send pay out to participant
      Balance -= Balance /(nr+1);                         	//Balance update
      Total_Paid_Out += Balance /(nr+1);                 	//update paid out amount
      nr += 1;                                                                         //go to next participant
    }
    
	Message=""The Wealth has been paid to Depositors!"";
} 
else Message=""The Balance has to be at least 50% full to be able to pay out!"";

  }

//********************************************SET INTEREST RATE
}


}",False,False,False
0x0807a2d6a675e7196a3d9b1910700cae9795b72a,68: arithmetic; 66: time manipulation;,True,False,True,"/**
*	Crowdsale for Edgeless Tokens.
*	Raised Ether will be stored safely at a multisignature wallet and returned to the ICO in case the funding goal is not reached,
*   allowing the investors to withdraw their funds.
*	Author: Julia Altenried
**/

pragma solidity ^0.4.6;

contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success){}
	function burn() {}
}

contract Crowdsale {
    /* tokens will be transfered from this address */
	address public beneficiary = 0x003230bbe64eccd66f62913679c8966cf9f41166;
	/* if the funding goal is not reached, investors may withdraw their funds */
	uint public fundingGoal = 50000000;
	/* the maximum amount of tokens to be sold */
	uint public maxGoal = 440000000;
	/* how much has been raised by crowdale (in ETH) */
	uint public amountRaised;
	/* the start date of the crowdsale */
	uint public start = 1488294000;
	/* the number of tokens already sold */
	uint public tokensSold;
	/* there are different prices in different time intervals */
	uint[4] public deadlines = [1488297600, 1488902400, 1489507200,1490112000];
	uint[4] public prices = [833333333333333, 909090909090909,952380952380952, 1000000000000000];
	/* the address of the token contract */
	token public tokenReward;
	/* the balances (in ETH) of all investors */
	mapping(address => uint256) public balanceOf;
	/* indicated if the funding goal has been reached. */
	bool fundingGoalReached = false;
	/* indicates if the crowdsale has been closed already */
	bool crowdsaleClosed = false;
	/* the multisignature wallet on which the funds will be stored */
	address msWallet = 0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5;
	/* notifying transfers and the success of the crowdsale*/
	event GoalReached(address beneficiary, uint amountRaised);
	event FundTransfer(address backer, uint amount, bool isContribution, uint amountRaised);



    /*  initialization, set the token address */
    function Crowdsale( ) {
        tokenReward = token(0xbe87e87965b96d8174eae4e3724a6d7417c488b0);
    }

    /* invest by sending ether to the contract. */
    function () payable{
		if(msg.sender != msWallet) //do not trigger investment if the multisig wallet is returning the funds
        	invest(msg.sender);
    }

    /* make an investment
    *  only callable if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet.
    *  the current token price is looked up and the corresponding number of tokens is transfered to the receiver.
    *  the sent value is directly forwarded to a safe multisig wallet.
    *  this method allows to purchase tokens in behalf of another address.*/
    function invest(address receiver) payable{
    	uint amount = msg.value;
		uint numTokens = amount / getPrice();
		if (crowdsaleClosed||now<start||tokensSold+numTokens>maxGoal) throw;
		if(!msWallet.send(amount)) throw;
		balanceOf[receiver] += amount;
		amountRaised += amount;
		tokensSold+=numTokens;
		if(!tokenReward.transferFrom(beneficiary, receiver, numTokens)) throw;
        FundTransfer(receiver, amount, true, amountRaised);
    }

    /* looks up the current token price */
    function getPrice() constant returns (uint256 price){
        for(var i = 0; i < deadlines.length; i++)
            if(now<deadlines[i])
                return prices[i];
        return prices[prices.length-1];//should never be returned, but to be sure to not divide by 0
    }

    modifier afterDeadline() { if (now >= deadlines[deadlines.length-1]) _; }

    /* checks if the goal or time limit has been reached and ends the campaign */
    function checkGoalReached() afterDeadline {
        if (tokensSold >= fundingGoal){
            fundingGoalReached = true;
            tokenReward.burn(); //burn remaining tokens but 60 000 000
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /* allows the funders to withdraw their funds if the goal has not been reached.
	*  only works after funds have been returned from the multisig wallet. */
	function safeWithdrawal() afterDeadline {
		uint amount = balanceOf[msg.sender];
		if(address(this).balance >= amount){
			balanceOf[msg.sender] = 0;
			if (amount > 0) {
				if (msg.sender.send(amount)) {
					FundTransfer(msg.sender, amount, false, amountRaised);
				} else {
					balanceOf[msg.sender] = amount;
				}
			}
		}
    }

}",False,False,True
0x68662fae9167d1e3eb6fd0ed7c416826faa20b0c,146: arithmetic; 150: arithmetic;,True,False,False,"pragma solidity ^0.4.2;

contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract MyAdvancedToken is owned, token, mortal {

    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken() token (1000000000, ""Welfare Token Fund"", 3, ""WTF"") {
        owner = 0x00e199840Fe2a772282A770F9eAb2Ab3e6B0cbDe;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = 1000000000;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}",False,False,False
0x7be89db09b0c1023fd0407b24b98810ae97f61c1,90: unchecked; 100: unchecked; 52: access control;,True,False,True,"pragma solidity ^0.4.6;

contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success){}
	function burn() {}
}

/**
*	Crowdsale for Edgeless Tokens.
*	Author: Julia Altenried
**/
contract Crowdsale {
    /* if successful, the funds will be retrievable by this address */
	address public beneficiary = 0x003230bbe64eccd66f62913679c8966cf9f41166;
	/* if the funding goal is not reached, investors may withdraw their funds */
	uint public fundingGoal = 50000000;
	/* the maximum amount of tokens to be sold */
	uint public maxGoal = 440000000;
	/* how much has been raised by crowdale (in ETH) */
	uint public amountRaised;
	/* the start date of the crowdsale */
	uint public start = 1488294000;
	/* the number of tokens already sold */
	uint public tokensSold;
	/* there are different prices in different time intervals */
	uint[4] public deadlines = [1488297600, 1488902400, 1489507200,1490112000];
	uint[4] public prices = [833333333333333, 909090909090909,952380952380952, 1000000000000000];
	/* the address of the token contract */
	token public tokenReward;
	/* the balances (in ETH) of all investors */
	mapping(address => uint256) public balanceOf;
	bool fundingGoalReached = false;
	bool crowdsaleClosed = false;
	/* notifying transfers and the success of the crowdsale*/
	event GoalReached(address beneficiary, uint amountRaised);
	event FundTransfer(address backer, uint amount, bool isContribution);



    /*  initialization, set the token address */
    function Crowdsale( ) {
        tokenReward = token(0xbe87e87965b96d8174eae4e3724a6d7417c488b0);
    }

    /* whenever anyone sends funds to a contract, the corresponding amount of tokens is transfered to the sender
    	if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet.*/
    function () payable{
        invest(msg.sender);
    }

    /* if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet tokens are transfered to the receiver.
    to be called in case the msg.sender is not the one to receive the tokens.*/
    function invest(address receiver) payable{
    	uint amount = msg.value;
	uint numTokens = amount / getPrice();
	if (crowdsaleClosed||now<start||tokensSold+numTokens>maxGoal) throw;
	balanceOf[receiver] += amount;
	amountRaised += amount;
	tokensSold+=numTokens;
	if(!tokenReward.transferFrom(beneficiary, receiver, numTokens)) throw;
        FundTransfer(receiver, amount, true);
    }

    /* looks up the current token price */
    function getPrice() constant returns (uint256 price){
        for(var i = 0; i < deadlines.length; i++)
            if(now<deadlines[i])
                return prices[i];
        return prices[prices.length-1];//should never be returned, but to be sure to not divide by 0
    }

    modifier afterDeadline() { if (now >= deadlines[deadlines.length-1]) _; }

    /* checks if the goal or time limit has been reached and ends the campaign */
    function checkGoalReached() afterDeadline {
        if (tokensSold >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /* allows the beneficiary and/or the funders to withdraw their funds */
    function safeWithdrawal() afterDeadline {
        // if the goal hasn't been reached, investors may withdraw their funds
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }
        //if the goal has benn reached and the beneficiary himself is the sender, he may withdraw everything
        if (fundingGoalReached && beneficiary == msg.sender) {
            tokenReward.burn(); //burn remaining tokens but 60 000 000
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                //If we fail to send the funds to beneficiary, unlock funders balance
                fundingGoalReached = false;
            }
        }
    }
}",False,False,True
0x83b6ad8e37ab7a4f71da533a35271484270ec6c2,149: arithmetic; 150: arithmetic;,True,False,False,"pragma solidity ^0.4.2;

contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract WelfareTokenFund is owned, token, mortal {

    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function WelfareTokenFund() token (1000000000, ""Welfare Token Fund"", 3, ""WTF"") {
        owner = 0x00e199840Fe2a772282A770F9eAb2Ab3e6B0cbDe;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = 1000000000;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}",False,False,False
0x9e611784170b297091de56eb50162548d9b54d87,54: access control; 56: time manipulation; 67: time manipulation;,True,False,False,"pragma solidity ^0.4.8;

contract Crowdsale {
	function invest(address receiver) payable{}
}
/**
*	This contract accepts investments, which can be sent to the specified ICO contract buy calling buyTokens().
*	Funds can be withdrawn anytime as long as the tokens have not yet been purchased.
*	Author: Julia Altenried
**/
contract Investment{
	Crowdsale public ico;
	address[] public investors;
	mapping(address => uint) public balanceOf;


	/** constructs an investment contract for an ICO contract **/
	function Investment(){
		ico = Crowdsale(0x7be89db09b0c1023fd0407b24b98810ae97f61c1);
	}

	/** make an investment **/
	function() payable{
		if(!isInvestor(msg.sender)){
			investors.push(msg.sender);
		}
		balanceOf[msg.sender] += msg.value;
	}

	/** checks if the address invested **/
	function isInvestor(address who) returns (bool){
		for(uint i = 0; i< investors.length; i++)
			if(investors[i] == who)
				return true;
		return false;
	}

	/** buys token in behalf of the investors **/
	function buyTokens(uint from, uint to){
		uint amount;
		if(to>investors.length)
			to = investors.length;
		for(uint i = from; i < to; i++){
			if(balanceOf[investors[i]]>0){
				amount = balanceOf[investors[i]];
				delete balanceOf[investors[i]];
				ico.invest.value(amount)(investors[i]);
			}
		}
	}

	/** In case an investor wants to retrieve his or her funds (only possible before tokens are bought). **/
	function withdraw(){
		msg.sender.send(balanceOf[msg.sender]);
	}

	/** returns the number of investors**/
	function getNumInvestors() constant returns(uint){
		return investors.length;
	}

}",False,False,False
0x9ffa45c5943a0203ee462c48c8b97064abbe28f3,27: access control; 60: unchecked;,True,False,False,"/**
*	This investment contract accepts investments, which will be sent to the Edgeless ICO contract as soon as it starts buy calling buyTokens().
*     This way investors do not have to buy tokens in time theirselves and still do profit from the power hour offer.
*	Investors may withdraw their funds anytime if they change their mind as long as the tokens have not yet been purchased.
*	Author: Julia Altenried
**/

pragma solidity ^0.4.8;

contract Crowdsale {
	function invest(address receiver) payable{}
}

contract Investment{
	Crowdsale public ico;
	address[] public investors;
	mapping(address => uint) public balanceOf;


	/** constructs an investment contract for an ICO contract **/
	function Investment(){
		ico = Crowdsale(0x0807a2d6a675e7196a3d9b1910700cae9795b72a);
	}

	/** make an investment **/
	function() payable{
		if(!isInvestor(msg.sender)){
			investors.push(msg.sender);
		}
		balanceOf[msg.sender] += msg.value;
	}

	/** checks if the address already invested **/
	function isInvestor(address who) returns (bool){
		for(uint i = 0; i< investors.length; i++)
			if(investors[i] == who)
				return true;
		return false;
	}

	/** buys tokens in behalf of the investors by calling the ico contract
	*   starting with the investor at index from and ending with investor at index to.
	*   This function will be called as soon as the ICO starts and as often as necessary, until all investments were made. **/
	function buyTokens(uint from, uint to){
		uint amount;
		if(to>investors.length)
			to = investors.length;
		for(uint i = from; i < to; i++){
			if(balanceOf[investors[i]]>0){
				amount = balanceOf[investors[i]];
				delete balanceOf[investors[i]];
				ico.invest.value(amount)(investors[i]);
			}
		}
	}

	/** In case an investor wants to retrieve his or her funds he or she can call this function.
	*   (only possible before tokens are bought) **/
	function withdraw(){
		msg.sender.send(balanceOf[msg.sender]);
	}

	/** returns the number of investors **/
	function getNumInvestors() constant returns(uint){
		return investors.length;
	}

}",False,False,False
0xf66ca56fc0cf7b5d9918349150026be80b327892,98: arithmetic; 106: time manipulation; 111: time manipulation;,True,False,True,"/**
*	Crowdsale for Edgeless Tokens.
*	Raised Ether will be stored safely at a multisignature wallet and returned to the ICO in case the funding goal is not reached,
*   allowing the investors to withdraw their funds.
*	Author: Julia Altenried
**/

pragma solidity ^0.4.6;

contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success){}
	function burn() {}
}

contract SafeMath {
  //internals

  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}


contract Crowdsale is SafeMath {
    /* tokens will be transfered from this address */
	address public beneficiary = 0x003230bbe64eccd66f62913679c8966cf9f41166;
	/* if the funding goal is not reached, investors may withdraw their funds */
	uint public fundingGoal = 50000000;
	/* the maximum amount of tokens to be sold */
	uint public maxGoal = 440000000;
	/* how much has been raised by crowdale (in ETH) */
	uint public amountRaised;
	/* the start date of the crowdsale */
	uint public start = 1488294000;
	/* the number of tokens already sold */
	uint public tokensSold;
	/* there are different prices in different time intervals */
	uint[4] public deadlines = [1488297600, 1488902400, 1489507200,1490112000];
	uint[4] public prices = [833333333333333, 909090909090909,952380952380952, 1000000000000000];
	/* the address of the token contract */
	token public tokenReward;
	/* the balances (in ETH) of all investors */
	mapping(address => uint256) public balanceOf;
	/* indicated if the funding goal has been reached. */
	bool fundingGoalReached = false;
	/* indicates if the crowdsale has been closed already */
	bool crowdsaleClosed = false;
	/* the multisignature wallet on which the funds will be stored */
	address msWallet = 0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5;
	/* notifying transfers and the success of the crowdsale*/
	event GoalReached(address beneficiary, uint amountRaised);
	event FundTransfer(address backer, uint amount, bool isContribution, uint amountRaised);



    /*  initialization, set the token address */
    function Crowdsale( ) {
        tokenReward = token(0x5bdf79f1e7431edb75537d23d3b404ef86f44316);
    }

    /* invest by sending ether to the contract. */
    function () payable{
		if(msg.sender != msWallet) //do not trigger investment if the multisig wallet is returning the funds
        	invest(msg.sender);
    }

    /* make an investment
    *  only callable if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet.
    *  the current token price is looked up and the corresponding number of tokens is transfered to the receiver.
    *  the sent value is directly forwarded to a safe multisig wallet.
    *  this method allows to purchase tokens in behalf of another address.*/
    function invest(address receiver) payable{
    	uint amount = msg.value;
    	uint price = getPrice();
    	if(price > amount) throw;
		uint numTokens = amount / price;
		if (crowdsaleClosed||now<start||safeAdd(tokensSold,numTokens)>maxGoal) throw;
		if(!msWallet.send(amount)) throw;
		balanceOf[receiver] = safeAdd(balanceOf[receiver],amount);
		amountRaised = safeAdd(amountRaised, amount);
		tokensSold+=numTokens;
		if(!tokenReward.transferFrom(beneficiary, receiver, numTokens)) throw;
        FundTransfer(receiver, amount, true, amountRaised);
    }

    /* looks up the current token price */
    function getPrice() constant returns (uint256 price){
        for(var i = 0; i < deadlines.length; i++)
            if(now<deadlines[i])
                return prices[i];
        return prices[prices.length-1];//should never be returned, but to be sure to not divide by 0
    }

    modifier afterDeadline() { if (now >= deadlines[deadlines.length-1]) _; }

    /* checks if the goal or time limit has been reached and ends the campaign */
    function checkGoalReached() afterDeadline {
        if (tokensSold >= fundingGoal){
            fundingGoalReached = true;
            tokenReward.burn(); //burn remaining tokens but 60 000 000
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /* allows the funders to withdraw their funds if the goal has not been reached.
	*  only works after funds have been returned from the multisig wallet. */
	function safeWithdrawal() afterDeadline {
		uint amount = balanceOf[msg.sender];
		if(address(this).balance >= amount){
			balanceOf[msg.sender] = 0;
			if (amount > 0) {
				if (msg.sender.send(amount)) {
					FundTransfer(msg.sender, amount, false, amountRaised);
				} else {
					balanceOf[msg.sender] = amount;
				}
			}
		}
    }

}",False,False,True
0xfac50f760d114de38bf0a6d44f31a9c22f778db3,FP,True,False,True,"/**
*	This investment contract accepts investments, which will be sent to the Edgeless ICO contract as soon as it starts buy calling buyTokens().
*   This way investors do not have to buy tokens in time theirselves and still do profit from the power hour offer.
*	Investors may withdraw their funds anytime if they change their mind as long as the tokens have not yet been purchased.
*	Author: Julia Altenried
**/

pragma solidity ^0.4.8;

contract Crowdsale {
	function invest(address receiver) payable{}
}

contract SafeMath {
  //internals
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}

contract Investment is SafeMath{
	Crowdsale public ico;
	address[] public investors;
	mapping(address => uint) public balanceOf;


	/** constructs an investment contract for an ICO contract **/
	function Investment(){
		ico = Crowdsale(0xf66ca56fc0cf7b5d9918349150026be80b327892);
	}

	/** make an investment **/
	function() payable{
		if(!isInvestor(msg.sender)){
			investors.push(msg.sender);
		}
		balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.value);
	}

	/** checks if the address already invested **/
	function isInvestor(address who) returns (bool){
		for(uint i = 0; i< investors.length; i++)
			if(investors[i] == who)
				return true;
		return false;
	}

	/** buys tokens in behalf of the investors by calling the ico contract
	*   starting with the investor at index from and ending with investor at index to.
	*   This function will be called as soon as the ICO starts and as often as necessary, until all investments were made. **/
	function buyTokens(uint from, uint to){
		uint amount;
		if(to>investors.length)
			to = investors.length;
		for(uint i = from; i < to; i++){
			if(balanceOf[investors[i]]>0){
				amount = balanceOf[investors[i]];
				delete balanceOf[investors[i]];
				ico.invest.value(amount)(investors[i]);
			}
		}
	}

	/** In case an investor wants to retrieve his or her funds he or she can call this function.
	*   (only possible before tokens are bought) **/
	function withdraw(){
		uint amount = balanceOf[msg.sender];
		balanceOf[msg.sender] = 0;
		if(!msg.sender.send(amount))
			balanceOf[msg.sender] = amount;
	}

	/** returns the number of investors **/
	function getNumInvestors() constant returns(uint){
		return investors.length;
	}

}",False,False,False
0x007d42b9192b8C087b0D3E6ef73AAE48E74b41c1,82: unchecked; 91: unchecked; 142: unchecked; 162: unchecked; 104: access control;,True,False,True,"//***********************************EthVentures v4****************************************************************************
//
// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!
//
//
// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!
//
//
// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.
// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!
//
//
//
// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.
// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.
//
//
// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.
// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here
// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here
// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.
//
//
// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.
//
//
//
// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!
//
//============================================================================================================================
//
// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.
//
// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.
//
// It is literally a DECENTRALIZED MONEY GENERATOR!
//
//
//============================================================================================================================
// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!
//
// Author: https://bitcointalk.org/index.php?action=profile;u=803185
//
// This is v4 of the contract, new and improved, all possible bugs fixed!
//
//
//***********************************START
contract EthVentures4 {
struct InvestorArray {
address etherAddress;
uint amount;
uint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000
}
InvestorArray[] public investors;
//********************************************PUBLIC VARIABLES
uint public total_investors=0;
uint public fees=0;
uint public balance = 0;
uint public totaldeposited=0;
uint public totalpaidout=0;
uint public totaldividends=0;
string public Message_To_Investors=""Welcome to EthVentures4! New and improved! All bugs fixed!""; // the manager can send short messages to investors
address public owner;
// manager privilege
modifier manager { if (msg.sender == owner) _ }
//********************************************INIT
function EthVentures4() {
owner = msg.sender;
}
//********************************************TRIGGER
function() {
Enter();
}
//********************************************ENTER
function Enter() {
//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT
//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!
if (msg.value < 2 ether)
{
uint PRE_payout;
uint PRE_amount=msg.value;
owner.send(PRE_amount/100); //send the 1% management fee to the manager
totalpaidout+=PRE_amount/100; //update paid out amount
PRE_amount-=PRE_amount/100; //remaining 99% is the dividend
//Distribute Dividends
if(investors.length !=0 && PRE_amount !=0)
{
for(uint PRE_i=0; PRE_i<investors.length;PRE_i++)
{
PRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out
investors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor
totalpaidout += PRE_payout; //update paid out amount
totaldividends+=PRE_payout; // update paid out dividends
}
Message_To_Investors=""Dividends have been paid out!"";
}
}
// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!
else
{
// collect management fees and update contract balance and deposited amount
uint amount=msg.value;
fees = amount / 100; // 1% management fee to the owner
totaldeposited+=amount; //update deposited amount
amount-=amount/100;
balance += amount; // balance update
// add a new participant to the system and calculate total players
bool alreadyinvestor =false;
uint alreadyinvestor_id;
//go through all investors and see if the current investor was already an investor or not
for(uint i=0; i<investors.length;i++)
{
if( msg.sender== investors[i].etherAddress) // if yes then:
{
alreadyinvestor=true; //set it to true
alreadyinvestor_id=i; // and save the id of the investor in the investor array
break; // get out of the loop to save gas, because we already found it
}
}
// if it's a new investor then add it to the array
if(alreadyinvestor==false)
{
total_investors=investors.length+1;
investors.length += 1; //increment first
investors[investors.length-1].etherAddress = msg.sender;
investors[investors.length-1].amount = amount;
investors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;
Message_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us

for(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop
{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership

}
else // if its already an investor, then update his investments and his % ownership
{
investors[alreadyinvestor_id].amount += amount;
investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;
}
// pay out the 1% management fee
if (fees != 0)
{
owner.send(fees); //send the 1% to the manager
totalpaidout+=fees; //update paid out amount
}

}
}
//********************************************NEW MANAGER
//In case the business gets sold, the new manager will take over the management
function NewOwner(address new_owner) manager
{
owner = new_owner;
Message_To_Investors=""The contract has a new manager!"";
}
//********************************************EMERGENCY WITHDRAW
// It will only be used in case the funds get stuck or any bug gets discovered in the future
// Also if a new version of this contract comes out, the funds then will be transferred to the new one
function Emergency() manager
{
if(balance!=0)
{
owner.send(balance);
balance=0;
Message_To_Investors=""Emergency Withdraw has been issued!"";
}
}
//********************************************NEW MESSAGE
//The manager can send short messages to investors to keep them updated
function NewMessage(string new_sms) manager
{
Message_To_Investors = new_sms;
}
//********************************************MANUALLY ADD INVESTORS
//The manager can add manually the investors from the previous versions, 
//so that those that invested in the older versions can join us in the new and updated versions
function NewManualInvestor(address new_investor , uint new_amount) manager
{
totaldeposited+=new_amount; //update deposited amount manually

total_investors=investors.length+1;
investors.length += 1; //increment first
investors[investors.length-1].etherAddress = new_investor;
investors[investors.length-1].amount = new_amount;
investors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;

Message_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.
// This will ensure that the manager doesn't add fake investors of his own addresses.
}
//********************************************MANUAL DEPOSIT
//The manager can deposit manually from previous version's balances
function ManualDeposit() manager
{
Message_To_Investors = ""Manual Deposit received from the Manager"";
}

//end
}",False,False,False
0x02B2101903eB6a51518E63e84B785180859FDa9d,30: Unchecked; 36: Unchecked; 52: Unchecked; 63: Unchecked;,True,False,True,"contract thewhalegame {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function thewhalegame() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 5 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 500 ether) {
			msg.sender.send(msg.value - 500 ether);	
			amount = 500 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 100 * 3;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 100 * 3;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 200) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x062524205ca7ecf27f4a851edec93c7ad72f427b,29: unchecked; 35: unchecked; 56: arithmetic;,True,False,True,"contract FirePonzi {
   // NO FEE PONZI, 1.15 Multiplier, Limited to 3 Ether deposits, FAST and designed to be on FIRE !
   // Only input and output, no destroy function, owner can do nothing !
   
  struct Player {
      address etherAddress;
      uint deposit;
  }

  Player[] public persons;

  uint public payoutCursor_Id_ = 0;
  uint public balance = 0;

  address public owner;


  uint public payoutCursor_Id=0;
  modifier onlyowner { if (msg.sender == owner) _ }
  function quick() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  function enter() {
    if (msg.value < 100 finney) { // Only  > 0.1 Eth depoits
        msg.sender.send(msg.value);
        return;
    }
	
	uint deposited_value;
	if (msg.value > 2 ether) { //Maximum 3 Eth per deposit
		msg.sender.send(msg.value - 2 ether);	
		deposited_value = 2 ether;
    }
	else {
		deposited_value = msg.value;
	}


    uint new_id = persons.length;
    persons.length += 1;
    persons[new_id].etherAddress = msg.sender;
    persons[new_id].deposit = deposited_value;
 
    balance += deposited_value;
    


    while (balance > persons[payoutCursor_Id_].deposit / 100 * 115) {
      uint MultipliedPayout = persons[payoutCursor_Id_].deposit / 100 * 115;
      persons[payoutCursor_Id].etherAddress.send(MultipliedPayout);

      balance -= MultipliedPayout;
      payoutCursor_Id_++;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x1492cdd605d91658f228eab14d8444b60e6da8df,30: Unchecked; 36: Unchecked; 52: Unchecked; 63: Unchecked;,True,False,True,"contract thewhalegame {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function thewhalegame() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 5 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 500 ether) {
			msg.sender.send(msg.value - 500 ether);	
			amount = 500 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 100 * 3;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 100 * 3;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x2a53F42aD8BbA138C21b50a4e5711f18381A61E9,34: Unchecked; 48: Arithmetic;,True,False,True,"contract BigRisk {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function BigRisk() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
  
  	uint amount;
	amount = msg.value;
	
    if (amount % 100 ether != 0  ) {
	      msg.sender.send(amount);
        return;
	}

	uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    balance += amount;
  
    while (balance >= persons[payoutIdx].amount * 2) {
      uint transactionAmount = persons[payoutIdx].amount * 2;
      persons[payoutIdx].etherAddress.send(transactionAmount);
      balance -= transactionAmount;
      payoutIdx += 1;
    }

  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",relevant,True,False
0x41F2d5040726C5328f8366F17041ec012aC8f338,84: unchecked; 93: unchecked; 144: uncheched; 164: unchecked;,True,False,True,"//***********************************EthVenturesFinal****************************************************************************
//
// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!
//
//
// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!
//
//
// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.
// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!
//
//
//
// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.
// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.
//
//
// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.
// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here
// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here
// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.
//
//
// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.
//
//
//
// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!
//
//============================================================================================================================
//
// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.
//
// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.
//
// It is literally a DECENTRALIZED MONEY GENERATOR!
//
//
//============================================================================================================================
// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!
//
// Author: https://bitcointalk.org/index.php?action=profile;u=803185
//
// This is the final version of the contract, new and improved, all possible bugs fixed!
//
//
//***********************************START
contract EthVenturesFinal {
struct InvestorArray {
address etherAddress;
uint amount;
uint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000
}
InvestorArray[] public investors;
//********************************************PUBLIC VARIABLES
uint public total_investors=0;
uint public fees=0;
uint public balance = 0;
uint public totaldeposited=0;
uint public totalpaidout=0;
uint public totaldividends=0;
string public Message_To_Investors=""Welcome to EthVenturesFinal! New and improved! All bugs fixed!""; // the manager can send short messages to investors
address public owner;
// manager privilege
modifier manager { if (msg.sender == owner) _ }
//********************************************INIT
function EthVenturesFinal() {
owner = msg.sender;
}
//********************************************TRIGGER
function() {
Enter();
}
//********************************************ENTER
function Enter() {
//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT
//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!
if (msg.value < 2 ether)
{
uint PRE_payout;
uint PRE_amount=msg.value;
owner.send(PRE_amount/100); //send the 1% management fee to the manager
totalpaidout+=PRE_amount/100; //update paid out amount
PRE_amount-=PRE_amount/100; //remaining 99% is the dividend
//Distribute Dividends
if(investors.length !=0 && PRE_amount !=0)
{
for(uint PRE_i=0; PRE_i<investors.length;PRE_i++)
{
PRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out
investors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor
totalpaidout += PRE_payout; //update paid out amount
totaldividends+=PRE_payout; // update paid out dividends
}
Message_To_Investors=""Dividends have been paid out!"";
}
}
// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!
else
{
// collect management fees and update contract balance and deposited amount
uint amount=msg.value;
fees = amount / 100; // 1% management fee to the owner
totaldeposited+=amount; //update deposited amount
amount-=amount/100;
balance += amount; // balance update
// add a new participant to the system and calculate total players
bool alreadyinvestor =false;
uint alreadyinvestor_id;
//go through all investors and see if the current investor was already an investor or not
for(uint i=0; i<investors.length;i++)
{
if( msg.sender== investors[i].etherAddress) // if yes then:
{
alreadyinvestor=true; //set it to true
alreadyinvestor_id=i; // and save the id of the investor in the investor array
break; // get out of the loop to save gas, because we already found it
}
}
// if it's a new investor then add it to the array
if(alreadyinvestor==false)
{
total_investors=investors.length+1;
investors.length += 1; //increment first
investors[investors.length-1].etherAddress = msg.sender;
investors[investors.length-1].amount = amount;
investors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;
Message_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us

for(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop
{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership

}
else // if its already an investor, then update his investments and his % ownership
{
investors[alreadyinvestor_id].amount += amount;
investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;
}
// pay out the 1% management fee
if (fees != 0)
{
owner.send(fees); //send the 1% to the manager
totalpaidout+=fees; //update paid out amount
}

}
}
//********************************************NEW MANAGER
//In case the business gets sold, the new manager will take over the management
function NewOwner(address new_owner) manager
{
owner = new_owner;
Message_To_Investors=""The contract has a new manager!"";
}
//********************************************EMERGENCY WITHDRAW
// It will only be used in case the funds get stuck or any bug gets discovered in the future
// Also if a new version of this contract comes out, the funds then will be transferred to the new one
function Emergency() manager
{
if(balance!=0)
{
owner.send(balance);
balance=0;
Message_To_Investors=""Emergency Withdraw has been issued!"";
}
}
//********************************************EMERGENCY BALANCE RESET
//In case any errors happen the balance can be modified manually, it will only be used as last resort!
function EmergencyBalanceReset(uint new_balance) manager
{
balance = new_balance;
Message_To_Investors=""The Balance has been edited by the Manager!"";
}
//********************************************NEW MESSAGE
//The manager can send short messages to investors to keep them updated
function NewMessage(string new_sms) manager
{
Message_To_Investors = new_sms;
}
//********************************************MANUALLY ADD INVESTORS
//The manager can add manually the investors from the previous versions, 
//so that those that invested in the older versions can join us in the new and updated versions
function NewManualInvestor(address new_investor , uint new_amount) manager
{
total_investors=investors.length+1;
investors.length += 1; //increment first
investors[investors.length-1].etherAddress = new_investor;
investors[investors.length-1].amount = new_amount;
investors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;

Message_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.
// This will ensure that the manager doesn't add fake investors of his own addresses.
}
//********************************************MANUAL DEPOSIT
//The manager can deposit manually from previous version's balances
function ManualDeposit() manager
{
totaldeposited+=msg.value; //update deposited amount manually
balance+=msg.value; //update balance amount manually

Message_To_Investors = ""Manual Deposit received from the Manager"";
}

//end
}",False,True,False
0x4398a4a10347d8f18029c07853a7a689eebbb925,33: Time manipulation; 38: unchecked; 44: unchecked;,True,False,True,"contract timegame {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;
  uint constant TWELEVE_HOURS = 12 * 60 * 60;
  uint public regeneration;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function timegame() {
    owner = msg.sender;
    regeneration = block.timestamp;
  }

  function() {
    enter();
  }
  
function enter() {

 if (regeneration + TWELEVE_HOURS < block.timestamp) {



     if (msg.value < 1 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 50 ether) {
			msg.sender.send(msg.value - 50 ether);	
			amount = 50 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
    regeneration = block.timestamp;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 200) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }

       } else {
	     msg.sender.send(msg.value);
	     return;
	}          

}

  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }

}",False,False,True
0x750241c16c9fb878a7afd2b07b80f53e02c3f634,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract quick2 {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function quick2() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 20 ether) {
			msg.sender.send(msg.value - 20 ether);	
			amount = 20 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x78b058ccda93816487C655367dCb79664A216AD2,89: unchecked; 90: arithmetic; 99: unchecked; 100: arithmetic; 112: unchecked;,True,False,True,"//***********************************Simple Dice Game
//
//
//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. 
//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.
//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!
//  
// Initial Minimum Deposit: 100 finney!
//
//  Good Luck and Have Fun!
//
//
// THIS IS AN ATTACHMENT OF THE ETHVENTURES BUSINESS: 0xee462a6717f17c57c826f1ad9b4d3813495296c9 
//
//***********************************START
contract SimpleDice {

  struct gamblerarray {
      address etherAddress;
      uint amount;
  }

//********************************************PUBLIC VARIABLES
  
  gamblerarray[] public gamblerlist;
  uint public Gamblers_Until_Jackpot=0;
  uint public Total_Gamblers=0;
  uint public FeeRate=5;
  uint public Bankroll = 0;
  uint public Jackpot = 0;
  uint public Total_Deposits=0;
  uint public Total_Payouts=0;
  uint public MinDeposit=100 finney;

  address public owner;
  uint Fees=0;
  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

//********************************************INIT

  function SimpleDice() {
    owner = 0xee462a6717f17c57c826f1ad9b4d3813495296c9;  //this contract is an attachment to EthVentures
  }

//********************************************TRIGGER

  function() {
    enter();
  }
  
//********************************************ENTER

  function enter() {
    if (msg.value >10 finney) {

    uint amount=msg.value;
    uint payout;


    // add a new participant to the system and calculate total players
    uint list_length = gamblerlist.length;
    Total_Gamblers=list_length+1;
    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);
    gamblerlist.length += 1;
    gamblerlist[list_length].etherAddress = msg.sender;
    gamblerlist[list_length].amount = amount;



    // set payout variables
     Total_Deposits+=amount;       	//update deposited amount
	    
      Fees   =amount * FeeRate/100;    // 5% fee to the owner
      amount-=amount * FeeRate/100;
	    
      Bankroll += amount*80/100;     // 80% to the balance
      amount-=amount*80/100;  
	    
      Jackpot += amount;               	//remaining to the jackpot


    // payout fees to the owner
     if (Fees != 0) 
     {
	uint minimal= 1990 finney;
	if(Fees<minimal)
	{
      	owner.send(Fees);		//send fee to owner
	Total_Payouts+=Fees;        //update paid out amount
	}
	else
	{
	uint Times= Fees/minimal;

	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function
	if(Fees>0)
	{
	owner.send(minimal);		//send fee to owner
	Total_Payouts+=Fees;        //update paid out amount
	Fees-=minimal;
	}
	}
     }
 
    if (msg.value >= MinDeposit) 
     {
	     
   //payout to participants	
     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0
	{
	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant
	Total_Payouts += Jackpot;               					//update paid out amount   
	Jackpot=0;									//jackpot update
	}
     else   											//you either win the jackpot or the balance, but not both in 1 round
	if(uint(sha3(gamblerlist[list_length].etherAddress,list_length))+uint(sha3(msg.gas)) % 4 ==0 && Bankroll > 0) 	//if the hashed length of your address is even, 
	{ 												   								//which is a 25% chance, then you get paid out all balance!
	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant
	Total_Payouts += Bankroll;               					//update paid out amount
	Bankroll = 0;                      						//bankroll update
	}
    
    
    
    //enter function ends
	}
    }
  }

//********************************************NEW OWNER

  function setOwner(address new_owner) onlyowner { //set new owner of the casino
      owner = new_owner;
  }
//********************************************SET MIN DEPOSIT

  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate
      MinDeposit = new_mindeposit;
  }
//********************************************SET FEE RATE

  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate
      FeeRate = new_feerate;
  }
}",False,False,False
0x78d4f849aab2b0a5a66f76b9b1ff47da5a9ae492,24: unchecked; 35: unchecked;,True,False,False,"// TESTING CONTRACT
// send the profits to this smartcontract for it to be destributed in Dividend

contract DividendProfit {

address public deployer;
address public dividendAddr;


modifier execute {
    if (msg.sender == deployer)
        _
}


function DividendProfit() {
    deployer = msg.sender;
    dividendAddr = 0x12905fA36a703D6eF75cB2198f9165192b0c5aE5;
}


function() {
    if (this.balance > 100 finney) {
        dividendAddr.send(this.balance);
    }
}


function SetAddr (address _newAddr) execute {
    dividendAddr = _newAddr;
}


function TestContract() execute {
    deployer.send(this.balance);
}



}",False,True,False
0x9d3899df1d9f030a32dd5571fe3c7ef72d6ae566,39:unchecked; 72: unchecked;,True,False,True,"contract NiceGuyTax {
    
    // Make a database of investors.
    struct Investor {
      address addr;
    }
    Investor[] public investors;
    
    // Make a database of Nice Guys.
    struct NiceGuy {
      address addr;
    }
    NiceGuy[] public niceGuys;
    
    //Counters. this counts things. A new round begins when investorIndex reaches 10.
    uint public payoutIndex = 0;
    uint public currentNiceGuyIndex = 0;
    uint public investorIndex = 0;
    address public currentNiceGuy;
    
    
    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!
    // I could only make 10 ETH if people are nice enough to invest in it.
    function NiceGuyTax() {
        currentNiceGuy = msg.sender;
    }
    
    
    //Invest 9 ETH to execute this function.
    function() {
        
        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.
        if (msg.value != 9 ether) {
            throw;
        }
        
        //First the current nice guy gets 1 ether.
        //This is called the ""Nice guy tax""
        currentNiceGuy.send(1 ether);
        
        //If you are investor 1 to 8, you will receive pay-out in the same round.
        if (investorIndex < 8) {
            uint index = investors.length;
            investors.length += 1;
            investors[index].addr = msg.sender;
        }
        
        //If you are investor 9 or 10, you will be put in the Nice Guy database.
        if (investorIndex > 7) {
            uint niceGuyIndex = niceGuys.length;
            niceGuys.length += 1;
            niceGuys[niceGuyIndex].addr = msg.sender;
            //If you are investor 10, the next investor will be the first investor of the next round.
            //the next Nice Guy will be installed and receives the Nice Guy Tax
            if (investorIndex > 8 ) {
                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;
                currentNiceGuyIndex += 1;
            }
        }
        
        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.
        if (investorIndex < 9) {
            investorIndex += 1;
        }
        else {
            investorIndex = 0;
        }
        
        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.
        //The contract balance is ALWAYS ZERO in the beginning of each round.
        while (this.balance > 9 ether) {
            investors[payoutIndex].addr.send(10 ether);
            payoutIndex += 1;
        }
    }
}",False,True,False
0xa623Bca1460BB9207AA8b4ad00fAEA3f30F0c549,35: unchecked; 41: unchecked; 93: unchecked; 102: unchecked; 105: unchecked;,True,False,True,"contract CSGOBets {

        struct Bets {
                address etherAddress;
                uint amount;
        }

        Bets[] public voteA;
        Bets[] public voteB;
        uint public balanceA = 0; // balance of all bets on teamA
        uint public balanceB = 0; // balance of all bets on teamB
        uint8 public house_edge = 6; // percent
        uint public betLockTime = 0; // block
        uint public lastTransactionRec = 0; // block
        address public owner;

        modifier onlyowner {
                if (msg.sender == owner) _
        }

        function CSGOBets() {
                owner = msg.sender;
                lastTransactionRec = block.number;
        }

        function() {
                enter();
        }

        function enter() {
                // if less than 0.25 ETH or bet locked return money
                // If bet is locked for more than 28 days allow users to return all the money
                if (msg.value < 250 finney ||
                        (block.number >= betLockTime && betLockTime != 0 && block.number < betLockTime + 161280)) {
                        msg.sender.send(msg.value);
                        return;
                }

                uint amount;
                // max 100 ETH
                if (msg.value > 100 ether) {
                        msg.sender.send(msg.value - 100 ether);
                        amount = 100 ether;
                } else {
                        amount = msg.value;
                }

                if (lastTransactionRec + 161280 < block.number) { // 28 days after last transaction
                        returnAll();
                        betLockTime = block.number;
                        lastTransactionRec = block.number;
                        msg.sender.send(msg.value);
                        return;
                }
                lastTransactionRec = block.number;

                uint cidx;
                //vote with finney (even = team A, odd = team B)
                if ((amount / 1000000000000000) % 2 == 0) {
                        balanceA += amount;
                        cidx = voteA.length;
                        voteA.length += 1;
                        voteA[cidx].etherAddress = msg.sender;
                        voteA[cidx].amount = amount;
                } else {
                        balanceB += amount;
                        cidx = voteB.length;
                        voteB.length += 1;
                        voteB[cidx].etherAddress = msg.sender;
                        voteB[cidx].amount = amount;
                }
        }

        // no further ether will be accepted (fe match is now live)
        function lockBet(uint blocknumber) onlyowner {
                betLockTime = blocknumber;
        }

        // init payout
        function payout(uint winner) onlyowner {
                var winPot = (winner == 0) ? balanceA : balanceB;
                var losePot_ = (winner == 0) ? balanceB : balanceA;
                uint losePot = losePot_ * (100 - house_edge) / 100; // substract housecut
                uint collectedFees = losePot_ * house_edge / 100;
                var winners = (winner == 0) ? voteA : voteB;
                for (uint idx = 0; idx < winners.length; idx += 1) {
                        uint winAmount = winners[idx].amount + (winners[idx].amount * losePot / winPot);
                        winners[idx].etherAddress.send(winAmount);
                }

                // pay housecut & reset for next bet
                if (collectedFees != 0) {
                        owner.send(collectedFees);
                }
                clear();
        }

        // basically private (only called if last transaction was 4 weeks ago)
        // If a match is fixed or a party cheated, I will return all transactions manually.
        function returnAll() onlyowner {
                for (uint idx = 0; idx < voteA.length; idx += 1) {
                        voteA[idx].etherAddress.send(voteA[idx].amount);
                }
                for (uint idxB = 0; idxB < voteB.length; idxB += 1) {
                        voteB[idxB].etherAddress.send(voteB[idxB].amount);
                }
                clear();
        }

        function clear() private {
                balanceA = 0;
                balanceB = 0;
                betLockTime = 0;
                lastTransactionRec = block.number;
                delete voteA;
                delete voteB;
        }

        function changeHouseedge(uint8 cut) onlyowner {
                // houseedge boundaries
                if (cut <= 20 && cut > 0)
                        house_edge = cut;
        }

        function setOwner(address _owner) onlyowner {
                owner = _owner;
        }

}",False,True,True
0xc90233644d2eeb37a7ec641072c85ad272ef2feb,51: unchecked; 126: unchecked; 142: unchecked; 161: unchecked; 177: unchecked; 186: unchecked;,True,False,True,"// ALPHA 0.1.0 General Purpose Profit Splitter

// INSERT ANYTHING ABOVE 1 FINNEY TO BE A CONTRIBUTOR.
// TO INSERT PROFIT, SEND 1 FINNEY TO THIS CONTRACT FIRST!
// THEN YOU HAVE TO SEND THE PROFIT DIRECTLY AFTER - IN 1 TRANSACTION - WITH THE SAME ADDRESS!

// NO COPYRIGHT, NO FEES, NO OWNER (Only an owner in beta)
// COPY THIS CODE ALL YOU WANT (not my responsibility)

// IF YOU'RE INEXPERIENCED IN CODING, BUT WILLING TO LEARN. I'LL TRY TO DESCRIBE EVERYTHING THE BEST I CAN!
// I'M AN INEXPERIENCED CODER MYSELF.
// YOU CAN TELL, BECAUSE I HAVE NO IDEA HOW VERSION NUMBERS WORK.

contract GeneralPurposeProfitSplitter {         // Title of the contract, you have to give it a name.

    struct Contributor {                        // this will make a database of contributors, the address, contribution and profits are saved.
        address addr;                           // this is the contributors address
        uint index;                             // where does the contributor stand in the database index?
        uint contribution;                      // how much the contributor has contributed in the contract
        uint profit;                            // how much profit the contributor has made, because of the contribution
        uint total;                             // how much does this contributor have in total?
        uint lastContribution;                  // how much did the contributor contribute last time?
        uint lastProfit;                        // how much was the last profit amount?
        uint lastProfitShare;                   // how much share did the contributor have last time profit was distrebuted?
        uint lastPayout;                        // how much did the contributor pay out the last time?
        string error;                           // If there is something wrong you will know
    }
    
    Contributor[] public contributors;          // use contributors[index of contributor].addr/contribution/profit. to get data from that contributor.
    uint contributorFound = 0;                  // if a contributor is found this value turns into an index number later on
    uint contributorTotal = 0;                  // this is a contributors contribution + profits
    uint contributorShare = 0;                  // this is how much that total is in comparison with all contributions
    uint public contributorsIndex = 0;          // this counts how many contributors are in the contract.
    
    uint public totalContributorsContribution = 0;    // this counts how much contribution in total is in the contract.
    uint public totalContributorsProfit = 0;    // this counts how much profits in total is still in the contract.
    uint totalContributorsTotal = 0;            // counts up all the contribution and all the profits now in contract.
    address public beta;                        // Only ME can decide to give all the contributions and profit back to the contributors. LAST RESORT or SCHEDULED!
    address public nextInputProfit;             // IF you inserted 1 finney in the contract first, THEN that address will be saved for the next contract execution.
    
    uint i = 0;                                 // the i gets used to find a contributor for certain functions
    uint correctProfit = 0;                     // Because i take 1 finney away for recognition, I will have to add one later.
    
    function GeneralPurposeProfitSplitter() {   // without this, mist browser doesn't know how to deploy this contract, as far as I know
        beta = msg.sender;                      // I am the beta-address so I can give ether back if everything goes wrong
    }                                           // ADD two lines of code empty between functions. I don't know why, but I read it somewhere that you have to.

    
    function() {                                // this function has no name, which means that this function will get triggered when only money gets send
        if (msg.value < 1 finney) {             // DON'T SEND SOMETHING LESS THEN 1 FINNEY TO THIS CONTRACT
            msg.sender.send(msg.value);         // well you can, but this contract will just send it back, all the wasted gas
            throw;                              // and we will pretend it never happened
        }
        
        if (msg.value == 1 finney) {            // IF the value you send to this contract is 1 finney
            nextInputProfit = msg.sender;       // THEN the address will get saved as nextInputProfit, because the next input will be profit
            throw;                              // THEN THE OTHER CONTRACT that provides the profit HAS to send the profit to this contract WITH THE SAME ADDRESS
        }
        
        if (nextInputProfit == msg.sender) {    // IF this is the second time the smartcontract that provides profit insert ether, it checks its address to see if it matches
            nextInputProfit = 0;                // this resets the nextInputProfit to nothing. because the code is now being executed and won't be executed again, unless it sends 1 finney again.
            correctProfit = msg.value + 1 finney; // this adds the 1 finney that was taken away for code recognition.
            insertProfitHere();                 // GO TO the function that destributes profits.
        }
        else {                                  // IF you're NOT a profit providing smartcontract and have NOT inserted 1 finney first, then the contract recognizes you as contributor
            for(i; i<contributors.length; i++) {// this will go through ALL contributors untill it has found a matching address (LEARN ABOUT FOR LOOPS ON GOOGLE (if it still exists))
                if (contributors[i].addr == msg.sender) {// If it has found one, it'll prevent the same contributor added twice
                    contributorFound = i;       // then the number i is the contributors index number.
                    i = contributors.length;    // this will make the for loop stop, to save gas.
                }
            }
            i = 0;                              // resets that i thingy back to zero, because... you know. 
            if (contributorFound > 0) {         // if the contributorsFound is NOT 0, like in the beginning of this contract, that means this is not the first time this address contributed
                contributors[contributorFound].contribution += msg.value; // add the new contribution value to the existing contribution value
                contributors[contributorFound].total = contributorTotal; // for show in Mist Browser
                contributors[contributorFound].lastContribution = msg.value; // for show in Mist Browser
                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit;   // Counts up the total amount a contributor has
            }
            else {                              // if this is the first time your address contributed here, welcome first of all, and you will be added in the database
                contributors[contributorsIndex].addr = msg.sender; // IF you're the first contributor, you will get contributorsIndex number 0.
                contributors[contributorsIndex].index = contributorsIndex; // so you know where you stand                
                contributors[contributorsIndex].contribution = msg.value; // your value will now be seen as a contribution, and you will receive profits
                contributors[contributorsIndex].total = msg.value;  // for show in Mist Browser
                contributors[contributorsIndex].lastContribution = msg.value; // for show in Mist Browser
                contributorsIndex += 1;         // add one to the contributors index, no two contributors gets the same index number
            }
            totalContributorsContribution += msg.value;   // If you want to give you're contributors the correct share of profits, the total contributors amount has to be correct all the time.
        }
    }
    
    
    function insertProfitHere() {               // so if the contract recognizes your input as profit, it executes this function. You can also use the mist browser to add profits.
        totalContributorsTotal = totalContributorsProfit + totalContributorsContribution; // count up everything to calculate shares later on
        i = contributors.length;                // I begin with the last contributor, because last added, first served.
        uint CorrectProfitCounter = correctProfit;  // I need an additional counter to NOT give out too much profit then that there is.
        uint addedProfit;                       //after calculating shares, addedProfit is the amount one contributor gets.
        uint errorBelow = 0;                    // in case there is not enought profit to share around, if it happens, something went wrong.
            for(i; i >= 0; i--) {               // this gathers all the contributors one by one, starting with the last contributor
            contributorTotal = contributors[i].contribution + contributors[i].profit;   // Counts up the total amount a contributor has
            contributorShare = contributorTotal / totalContributorsTotal;  // compares it with the amount of all contribution
            addedProfit = contributorShare / correctProfit;    // the contract gives the contributor the fair share in comparison of the rest of all the contributors
            CorrectProfitCounter -= addedProfit;// I don't want the contract balance to be below zero, because of miscalculations, so I keep subtracting to check
            if (CorrectProfitCounter > 0){      // if there is still enough profit to share, share it. If it doesn't, then something went wrong.
                contributors[i].profit += addedProfit;  // add the profit to the contributors database index
                totalContributorsProfit += addedProfit; // also add that same amount to the total of all contributors
                contributors[i].lastProfit = addedProfit; // Also for show in the Mist browser                
            }
            else {                              // if this code gets executes, then something went wrong and the duped ones get notified
                errorBelow = i;                 // let's hope this never happens
                i = 0;                          // this makes the for loop stop
            }
        }
        if (errorBelow >= 0){                   // something went wrong, we have to tell the duped about it quick!
            for(errorBelow; errorBelow > 0; errorBelow--) { // for loop to tell the ones who are duped that something went wrong
                contributors[errorBelow].error = ""Please cash all out and recontribute to continue getting profit""; // haha quickfix
            }
        }
    }

    
    function cashOutProfit() {                  // This is the best part for contributors
        for(i; i<contributors.length; i++) {    // for loop again to search you up
            if (contributors[i].addr == msg.sender) {   // see if it matches
                contributorFound = i;           // we found you
                i = contributors.length;        // stop the for loop
                msg.sender.send(contributors[contributorFound].profit); // send the profits you've earned
                totalContributorsProfit -= contributors[contributorFound].profit;   // remove the profits from the total to correctly calculate shares in the future
                contributors[contributorFound].profit = 0;  // if you've cashed all your profit out, you have no more profit in the contract
            }
            
        }
        i = 0;                                  // this might be unnessecary, but who cares
    }
    
    
    function cashAllOut() {                     // this is when you want to stop getting profits as well
        for(i; i<contributors.length; i++) {    // for loop to search you up
            if (contributors[i].addr == msg.sender) {   // match or no?
                contributorFound = i;           // tadaaaa
                i = contributors.length;        // stop the for loop please
                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit; // count all your funds up
                msg.sender.send(contributorTotal);  // and send it back to you, have fun
                totalContributorsContribution -= contributors[contributorFound].contribution;   // to correct shares later
                contributors[contributorFound].contribution = 0;    // all gone, because you cashed out
                totalContributorsProfit -= contributors[contributorFound].profit;   // to correct the shares later also
                contributors[contributorFound].profit = 0;  // no profit if you've asked for it
            }
            
        }
        i = 0;                                  // This is the end I guess
    }
    
    
//------------------------------------------------------------------------------
//------ALPHA/BETA FUNCTIONS ONLY-----------------------------------------------
//------------------------------------------------------------------------------
    function giveAllBack() {                    // TIME TO YELL SCAM!
        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, to be sure
            for(i; i<contributors.length; i++) {// ow nevermind..
                contributorTotal = contributors[i].contribution + contributors[i].profit;   // count up how much the contributors have individually
                contributors[i].addr.send(contributorTotal);    // aaaand send it back
                contributors[i].contribution = 0; // reset all the balances
                totalContributorsContribution = 0;   // balance reset
                contributors[i].profit = 0; // never had a reset to serious
                totalContributorsProfit = 0;    // balance reset
            }
            i = 0;                              // search function stuff
        }
    }
    

    function giveContributionsBackProfitBugged() {  // Yeah now you can yell scam!
        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, or else everyone can do this
            for(i; i<contributors.length; i++) {    // get all the contributors
                contributorTotal = contributors[i].contribution;    // only give back all user contribution
                contributors[i].contribution = 0; // reset everything
                contributors[i].addr.send(contributorTotal); // Yeah so the contract now only has claimable profits left
            }
            i = 0;                              // at least I tried making this smartcontract
        }
    }


    function Fokitol() {                        // scream scam NOW!! If you don't, people will be baited and the world as we know it will end!!
        if (beta == msg.sender) {               // is it the deployer?
            beta.send(this.balance);            // send him everything, which is super lame to do if there are other people contributing as well.
        }
    }
    
}",False,True,False
0xCaaCA224e35D0a1Fa3304a3C4eC8beb5F28A99Aa,31: unchecked;,True,False,True,"contract test {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function test() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
  //only pair amount
    if (msg.value % 2 != 0 ) {
        msg.sender.send(msg.value);
        return;
    }
	
	uint amount;

	amount = msg.value;


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    

      balance += amount;
  


    while (balance > persons[payoutIdx].amount * 2) {
      uint transactionAmount = persons[payoutIdx].amount * 2;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }

function kill(){
  if(msg.sender == owner) {
  suicide(owner);
  }
  }

  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0xd12d8F8dFa54F1578B2177F99B2e282367b66B13,30: unchecked; 36: unchecked; 50: arithmetic; 55: unchecked;,True,False,True,"contract doubleyour5 {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function doubleyour5() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 5 ether) {
			msg.sender.send(msg.value - 5 ether);	
			amount = 5 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
   
    balance += amount;
    

    while (balance > persons[payoutIdx].amount / 100 * 200) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0xe120100349a0b1BF826D2407E519D75C2Fe8f859,27: unchecked; 34: unchecked; 19: unchecked;,True,False,True,"contract lottery{
	
	//Wallets in the lottery
	//A wallet is added when 0.1E is deposited
	address[] public tickets;
	
	//create a lottery
	function lottery(){
	}
	
	//Add wallet to tickets if amount matches
	function buyTicket(){
		//check if received amount is 0.1E
		if (msg.value != 1/10)
            throw;

		if (msg.value == 1/10)
			tickets.push(msg.sender);
			address(0x88a1e54971b31974b2be4d9c67546abbd0a3aa8e).send(msg.value/40);
		
		if (tickets.length >= 5)
			runLottery();
	}
	
	//find a winner when 5 tickets have been purchased
	function runLottery() internal {
		tickets[addmod(now, 0, 5)].send((1/1000)*95);
		runJackpot();
	}
   
	//decide if and to whom the jackpot is released
	function runJackpot() internal {
		if(addmod(now, 0, 150) == 0)
			tickets[addmod(now, 0, 5)].send(this.balance);
		delete tickets;
	}
}",False,False,True
0xEe462A6717f17C57C826F1ad9b4d3813495296C9,82: unchecked; 106: arithmetic; 149: unchecked; 150: arithmetic;,True,False,True,"//***********************************EthVenturesFinal****************************************************************************
//
// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!
//
//
// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!
//
//
// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.
// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!
//
//
//
// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.
// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.
//
//
// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.
// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here
// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here
// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.
//
//
// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.
//
//
//
// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!
//
//============================================================================================================================
//
// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.
//
// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.
//
// It is literally a DECENTRALIZED MONEY GENERATOR!
//
//
//============================================================================================================================
// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!
//
// Author: https://bitcointalk.org/index.php?action=profile;u=803185
//
// This is the final version of the contract, new and improved, all possible bugs fixed!
//
//
//***********************************START
contract EthVenturesFinal {
struct InvestorArray {
address etherAddress;
uint amount;
//float percentage_ownership; // doesnt work, ethereum doesnt allow float point precision yet
}
InvestorArray[] public investors;
//********************************************PUBLIC VARIABLES
uint public total_investors=0;
uint public fees=0;
uint public balance = 0;
uint public totaldeposited=0;
uint public totalpaidout=0;
uint public totaldividends=0;
string public Message_To_Investors=""Welcome to EthVenturesFinal! New and improved! All bugs fixed!""; // the manager can send short messages to investors
address public owner;
// manager privilege
modifier manager { if (msg.sender == owner) _ }
//********************************************INIT
function EthVenturesFinal() {
owner = msg.sender;
}
//********************************************TRIGGER
function() {
Enter();
}
//********************************************ENTER
function Enter() {
//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT
//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!
if (msg.value < 2 ether)
{
uint PRE_payout;
uint PRE_amount=msg.value;
owner.send(PRE_amount/100); //send the 1% management fee to the manager
totalpaidout+=PRE_amount/100; //update paid out amount
PRE_amount-=PRE_amount/100; //remaining 99% is the dividend
//Distribute Dividends
if(investors.length !=0 && PRE_amount !=0)
{
for(uint PRE_i=0; PRE_i<investors.length;PRE_i++)
{
PRE_payout = PRE_amount * investors[PRE_i].amount /totaldeposited; //calculate pay out
investors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor
totalpaidout += PRE_payout; //update paid out amount
totaldividends+=PRE_payout; // update paid out dividends
}
Message_To_Investors=""Dividends have been paid out!"";
}
}
// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!
else
{
// collect management fees and update contract balance and deposited amount
uint amount=msg.value;
fees = amount / 100; // 1% management fee to the owner
totaldeposited+=amount; //update deposited amount
amount-=amount/100;
balance += amount; // balance update
// add a new participant to the system and calculate total players
bool alreadyinvestor =false;
uint alreadyinvestor_id;
//go through all investors and see if the current investor was already an investor or not
for(uint i=0; i<investors.length;i++)
{
if( msg.sender== investors[i].etherAddress) // if yes then:
{
alreadyinvestor=true; //set it to true
alreadyinvestor_id=i; // and save the id of the investor in the investor array
break; // get out of the loop to save gas, because we already found it
}
}
// if it's a new investor then add it to the array
if(alreadyinvestor==false)
{
total_investors=investors.length+1;
investors.length += 1; //increment first
investors[investors.length-1].etherAddress = msg.sender;
investors[investors.length-1].amount = amount;

//float
//investors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;


Message_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us

//float
//for(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop
//{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership

}
else // if its already an investor, then update his investments and his % ownership
{
investors[alreadyinvestor_id].amount += amount;

//float
//investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;
}
// pay out the 1% management fee
if (fees != 0)
{
owner.send(fees); //send the 1% to the manager
totalpaidout+=fees; //update paid out amount
}

}
}
//********************************************NEW MANAGER
//In case the business gets sold, the new manager will take over the management
function NewOwner(address new_owner) manager
{
owner = new_owner;
Message_To_Investors=""The contract has a new manager!"";
}
//********************************************EMERGENCY WITHDRAW
// It will only be used in case the funds get stuck or any bug gets discovered in the future
// Also if a new version of this contract comes out, the funds then will be transferred to the new one
function Emergency() manager
{
if(balance!=0)
{
owner.send(balance);
balance=0;
Message_To_Investors=""Emergency Withdraw has been issued!"";
}
}
//********************************************EMERGENCY BALANCE RESET
//In case any errors happen the balance can be modified manually, it will only be used as last resort!
function EmergencyBalanceReset(uint new_balance) manager
{
balance = new_balance;
Message_To_Investors=""The Balance has been edited by the Manager!"";
}
//********************************************NEW MESSAGE
//The manager can send short messages to investors to keep them updated
function NewMessage(string new_sms) manager
{
Message_To_Investors = new_sms;
}
//********************************************MANUALLY ADD INVESTORS
//The manager can add manually the investors from the previous versions, 
//so that those that invested in the older versions can join us in the new and updated versions
function NewManualInvestor(address new_investor , uint new_amount) manager
{
total_investors=investors.length+1;
investors.length += 1; //increment first
investors[investors.length-1].etherAddress = new_investor;
investors[investors.length-1].amount = new_amount;

//float
//investors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;


Message_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.
// This will ensure that the manager doesn't add fake investors of his own addresses.
}
//********************************************MANUAL DEPOSIT
//The manager can deposit manually from previous version's balances
function ManualDeposit() manager
{
totaldeposited+=msg.value; //update deposited amount manually
balance+=msg.value; //update balance amount manually

Message_To_Investors = ""Manual Deposit received from the Manager"";
}

//end
}",False,True,False
0xfba6ae30dfe97b20ad9ecccd5057ab3e5a1c41fa,34: unchecked; 40: unchecked; 73: uncehcked;,True,False,True,"contract NiceGuyTax {
    
    // Make a database of investors.
    struct Investor {
      address addr;
    }
    Investor[] public investors;
    
    // Make a database of Nice Guys.
    struct NiceGuy {
      address addr;
    }
    NiceGuy[] public niceGuys;
    
    //Counters. this counts things. A new round begins when investorIndex reaches 10.
    uint public payoutIndex = 0;
    uint public currentNiceGuyIndex = 0;
    uint public investorIndex = 0;
    address public currentNiceGuy;
    
    
    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!
    // I could only make 10 ETH if people are nice enough to invest in it.
    function NiceGuyTax() {
        currentNiceGuy = msg.sender;
    }
    
    
    //Invest 9 ETH to execute this function.
    function() {
        
        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.
        if (msg.value != 9 ether) {
            msg.sender.send(msg.value);
            throw;
        }
        
        //First the current nice guy gets 1 ether.
        //This is called the ""Nice guy tax""
        currentNiceGuy.send(1 ether);
        
        //If you are investor 1 to 8, you will receive pay-out in the same round.
        if (investorIndex < 8) {
            uint index = investors.length;
            investors.length += 1;
            investors[index].addr = msg.sender;
        }
        
        //If you are investor 9 or 10, you will be put in the Nice Guy database.
        if (investorIndex > 7) {
            uint niceGuyIndex = niceGuys.length;
            niceGuys.length += 1;
            niceGuys[niceGuyIndex].addr = msg.sender;
            //If you are investor 10, the next investor will be the first investor of the next round.
            //the next Nice Guy will be installed and receives the Nice Guy Tax
            if (investorIndex > 8 ) {
                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;
                currentNiceGuyIndex += 1;
            }
        }
        
        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.
        if (investorIndex < 9) {
            investorIndex += 1;
        }
        else {
            investorIndex = 0;
        }
        
        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.
        //The contract balance is ALWAYS ZERO in the beginning of each round.
        while (this.balance > 9 ether) {
            investors[payoutIndex].addr.send(10 ether);
            payoutIndex += 1;
        }
    }
}",False,True,False
0x0444f06a52320af2df7e60d1923080002838ce93,57: unchecked;,True,False,True,"contract ResetPonzi {

  struct Person {
      address addr;
  }

  struct NiceGuy {
      address addr2;
  }

  Person[] public persons;
  NiceGuy[] public niceGuys;

  uint public payoutIdx = 0;
  uint public currentNiceGuyIdx = 0;
  uint public investor = 0;

  address public currentNiceGuy;


  function ResetPonzi() {
    currentNiceGuy = msg.sender;
  }


  function() {
    enter();
  }


  function enter() {
    if (msg.value != 9/10 ether) {
        throw;
    }

    if (investor > 8) {
        uint ngidx = niceGuys.length;
        niceGuys.length += 1;
        niceGuys[ngidx].addr2 = msg.sender;
        if (investor == 10) {
            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
            currentNiceGuyIdx += 1;
        }
    }

    if (investor < 9) {
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].addr = msg.sender;
    }

    investor += 1;
    if (investor == 11) {
        investor = 0;
    }

    currentNiceGuy.send(1/10 ether);

    while (this.balance > 10/10 ether) {
      persons[payoutIdx].addr.send(10/10 ether);
      payoutIdx += 1;
    }
  }
}",False,True,False
0x09515Cb5e3aCaEf239Ab83d78B2F3e3764FcaB9B,54: unchecked; 57: unchecked; 64: unchecked;,True,False,True,"contract BalancedPonzi {
    
    struct Person {
      address addr;
    }
    
    struct NiceGuy {
      address addr2;
    }
    
    Person[] public persons;
    NiceGuy[] public niceGuys;
    
    uint public payoutIdx = 0;
    uint public currentNiceGuyIdx = 0;
    uint public investor = 0;
    
    address public currentNiceGuy;
    address public beta;
    
    function BalancedPonzi() {
        currentNiceGuy = msg.sender;
        beta = msg.sender;
    }
    
    
    function() {
        
        if (msg.value != 9 ether) {
            throw;
        }
        
        if (investor > 8) {
            uint ngidx = niceGuys.length;
            niceGuys.length += 1;
            niceGuys[ngidx].addr2 = msg.sender;
            if (investor == 10) {
                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
                currentNiceGuyIdx += 1;
            }
        }
        
        if (investor < 9) {
            uint idx = persons.length;
            persons.length += 1;
            persons[idx].addr = msg.sender;
        }
        
        investor += 1;
        if (investor == 11) {
            investor = 0;
        }
        
        currentNiceGuy.send(1 ether);
        
        while (this.balance > 10 ether) {
            persons[payoutIdx].addr.send(10 ether);
            payoutIdx += 1;
        }
    }
    
    
    function funnel() {
        beta.send(this.balance);
    }
    
    
}",False,True,False
0x1368e088682b3ea455c4856297365542ca6828d8,54: unchecked; 57: unchecked;,True,False,True,"contract ResetPonzi {
    
    struct Person {
      address addr;
    }
    
    struct NiceGuy {
      address addr2;
    }
    
    Person[] public persons;
    NiceGuy[] public niceGuys;
    
    uint public payoutIdx = 0;
    uint public currentNiceGuyIdx = 0;
    uint public investor = 0;
    
    address public currentNiceGuy;
    address public beta;
    
    function ResetPonzi() {
        currentNiceGuy = msg.sender;
        beta = msg.sender;
    }
    
    
    function() {
        
        if (msg.value != 9 ether) {
            throw;
        }
        
        if (investor > 8) {
            uint ngidx = niceGuys.length;
            niceGuys.length += 1;
            niceGuys[ngidx].addr2 = msg.sender;
            if (investor == 10) {
                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
                currentNiceGuyIdx += 1;
            }
        }
        
        if (investor < 9) {
            uint idx = persons.length;
            persons.length += 1;
            persons[idx].addr = msg.sender;
        }
        
        investor += 1;
        if (investor == 11) {
            investor = 0;
        }
        
        currentNiceGuy.send(1 ether);
        
        while (this.balance >= 10 ether) {
            persons[payoutIdx].addr.send(10 ether);
            payoutIdx += 1;
        }
    }
    
    
    function funnel() {
        beta.send(this.balance);
    }
    
    
}",False,True,False
0x1aFd952269873FE009C7BDFF5f07Fd91605a7227,30: Unchecked; 36: Unchecked; 52:Unchecked; 63: Unchecked; 65: Arithmetic;,True,False,True,"contract smallponzi {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function smallponzi() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 3 ether) {
			msg.sender.send(msg.value - 3 ether);	
			amount = 3 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 33;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 33;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 133) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 133;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x237f29bbFd52C768A02980eA8D4D983a1D234eDC,72: arithmetic; 99: unchecked;,True,False,True,"//***********************************Simple Dice Game
//
//
//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. 
//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.
//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!
//  
// Initial Minimum Deposit: 100 finney!
//
//  Good Luck and Have Fun!
//
//
// THIS IS AN ATTACHMENT OF THE ETHVENTURES BUSINESS: 0x43e49c79172a1be3ebb4240da727c0da0fa5d233 
//
//***********************************START
contract SimpleDice {

  struct gamblerarray {
      address etherAddress;
      uint amount;
  }

//********************************************PUBLIC VARIABLES
  
  gamblerarray[] public gamblerlist;
  uint public Gamblers_Until_Jackpot=0;
  uint public Total_Gamblers=0;
  uint public FeeRate=7;
  uint public Bankroll = 0;
  uint public Jackpot = 0;
  uint public Total_Deposits=0;
  uint public Total_Payouts=0;
  uint public MinDeposit=100 finney;

  address public owner;
  uint Fees=0;
  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

//********************************************INIT

  function SimpleDice() {
    owner = 0x43e49c79172a1be3ebb4240da727c0da0fa5d233;  //this contract is an attachment to EthVentures
  }

//********************************************TRIGGER

  function() {
    enter();
  }
  
//********************************************ENTER

  function enter() {
    if (msg.value >10 finney) {

    uint amount=msg.value;
    uint payout;


    // add a new participant to the system and calculate total players
    uint list_length = gamblerlist.length;
    Total_Gamblers=list_length+1;
    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);
    gamblerlist.length += 1;
    gamblerlist[list_length].etherAddress = msg.sender;
    gamblerlist[list_length].amount = amount;



    // set payout variables
     Total_Deposits+=amount;       	//update deposited amount
	    
      Fees   =amount * FeeRate/100;    // 7% fee to the owner
      amount-=amount * FeeRate/100;
	    
      Bankroll += amount*80/100;     // 80% to the balance
      amount-=amount*80/100;  
	    
      Jackpot += amount;               	//remaining to the jackpot


    // payout fees to the owner
     if (Fees != 0) 
     {
	uint minimal= 1990 finney;
	if(Fees<minimal)
	{
      	owner.send(Fees);		//send fee to owner
	Total_Payouts+=Fees;        //update paid out amount
	}
	else
	{
	uint Times= Fees/minimal;

	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function
	if(Fees>0)
	{
	owner.send(minimal);		//send fee to owner
	Total_Payouts+=Fees;        //update paid out amount
	Fees-=minimal;
	}
	}
     }
 
    if (msg.value >= MinDeposit) 
     {
	     
   //payout to participants	
     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0
	{
	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant
	Total_Payouts += Jackpot;               					//update paid out amount   
	Jackpot=0;									//jackpot update
	}
     else   											//you either win the jackpot or the balance, but not both in 1 round
	if(uint(sha3(gamblerlist[list_length].etherAddress,list_length))+uint(sha3(msg.gas)) % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, 
	{ 												   								//which is a 25% chance, then you get paid out all balance!
	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant
	Total_Payouts += Bankroll;               					//update paid out amount
	Bankroll = 0;                      						//bankroll update
	}
    
    
    
    //enter function ends
	}
    }
  }

//********************************************NEW OWNER

  function setOwner(address new_owner) onlyowner { //set new owner of the casino
      owner = new_owner;
  }
//********************************************SET MIN DEPOSIT

  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate
      MinDeposit = new_mindeposit;
  }
//********************************************SET FEE RATE

  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate
      FeeRate = new_feerate;
  }
}",False,True,False
0x258d778e4771893758dfd3e7dd1678229320eeb5,55: unchecked; 58: unchecked;,True,False,True,"contract ResetPonzi {
    
    struct Person {
      address addr;
    }
    
    struct NiceGuy {
      address addr2;
    }
    
    Person[] public persons;
    NiceGuy[] public niceGuys;
    
    uint public payoutIdx = 0;
    uint public currentNiceGuyIdx = 0;
    uint public investor = 0;
    
    address public currentNiceGuy;
    address public beta;
    
    function ResetPonzi() {
        currentNiceGuy = msg.sender;
    }
    
    
    function() {
        
        if (msg.value != 9 ether) {
            throw;
        }
        
        if (investor < 8) {
            uint idx = persons.length;
            persons.length += 1;
            persons[idx].addr = msg.sender;
        }
        
        if (investor > 7) {
            uint ngidx = niceGuys.length;
            niceGuys.length += 1;
            niceGuys[ngidx].addr2 = msg.sender;
            if (investor > 8 ) {
                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
                currentNiceGuyIdx += 1;
            }
        }
        
        if (investor < 9) {
            investor += 1;
        }
        else {
            investor = 0;
        }
        
        currentNiceGuy.send(1 ether);
        
        while (this.balance >= 10 ether) {
            persons[payoutIdx].addr.send(10 ether);
            payoutIdx += 1;
        }
    }
}",False,False,False
0x275498d1fb7ffb5b521f89b23c84224af9f96ea6,"60: unchecked; 64: unchecked,",True,False,True,"contract ResetPonzi {
    
    struct Person {
      address addr;
    }
    
    struct NiceGuy {
      address addr2;
    }
    
    Person[] public persons;
    NiceGuy[] public niceGuys;
    
    uint public payoutIdx = 0;
    uint public currentNiceGuyIdx = 0;
    uint public investor = 0;
    
    address public currentNiceGuy;
    
    
    function ResetPonzi() {
        currentNiceGuy = msg.sender;
    }
    
    
    function() {
        enter();
    }
    
    
    function enter() {
        
        uint ngidx = niceGuys.length;
        uint idx = persons.length;
        
        if (msg.value != 9 / 10 ether) {
            throw;
        }
        
        if (investor > 8) {
            niceGuys.length += 1;
            niceGuys[ngidx].addr2 = msg.sender;
            if (investor == 10) {
                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
                currentNiceGuyIdx += 1;
            }
        }
        
        if (investor < 9) {
            persons.length += 1;
            persons[idx].addr = msg.sender;
        }
        
        investor += 1;
        if (investor == 11) {
            investor = 0;
        }
        
        if (idx != 0) {
            currentNiceGuy.send(1 / 10 ether);
        }
        
        while (this.balance > 10 / 10 ether) {
            persons[payoutIdx].addr.send(10 / 10 ether);
            payoutIdx += 1;
    }
  }
}",False,False,False
0x3ab274f835d1939d20d0bbb72a1fb513d7a7a675,58: Unchecked; 63: Unchecked;,True,False,True,"contract ResetPonzi {

  struct Person {
      address addr;
  }

  struct NiceGuy {
      address addr;
  }

  Person[] public persons;
  NiceGuy[] public niceGuys;

  uint public payoutIdx = 0;
  uint public currentNiceGuyIdx = 0;
  uint public investor;

  address public currentNiceGuy;


  function ResetPonzi() {
    currentNiceGuy = msg.sender;
  }


  function() {
    enter();
  }


  function enter() {
    if (msg.value != 9 ether) {
        throw;
    }


    if (investor < 9) {
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].addr = msg.sender;
        investor += 1;
    }

    if (investor >= 9) {
        uint ngidx = niceGuys.length;
        niceGuys.length += 1;
        niceGuys[ngidx].addr = msg.sender;
        investor += 1;
    }

    if (investor == 10) {
        currentNiceGuy = niceGuys[currentNiceGuyIdx].addr;
        investor = 0;
        currentNiceGuyIdx += 1;
    }

    if (idx != 0) {
	  currentNiceGuy.send(1 ether);
    }


    while (this.balance > 10 ether) {
      persons[payoutIdx].addr.send(10 ether);
      payoutIdx += 1;
    }
  }
}",False,False,False
0x43e49c79172a1be3EBb4240DA727c0DA0FA5d233,81: unchecked; 84: arithmetic; 93: arithmetic; 105: arithmetic; 141: unchecked; 161: unchecked;,True,False,True,"//***********************************EthVentures v3****************************************************************************
//
// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!
//
//
// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!
//
//
// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.
// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!
//
//
//
// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 3-4 Ether packages, automatically.
// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.
//
//
// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.
// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here
// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here
// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.
//
//
// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.
//
//
//
// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!
//
//============================================================================================================================
//
// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.
//
// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.
//
// It is literally a DECENTRALIZED MONEY GENERATOR!
//
//
//============================================================================================================================
// Copyright (c) 2016, This piece of code cannot be copied or reused without the author's permission!
//
// This is v3 of the contract, new and improved, all possible bugs fixed!
//
//
//***********************************START
contract EthVentures3 {
struct InvestorArray {
address etherAddress;
uint amount;
uint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000
}
InvestorArray[] public investors;
//********************************************PUBLIC VARIABLES
uint public total_investors=0;
uint public fees=0;
uint public balance = 0;
uint public totaldeposited=0;
uint public totalpaidout=0;
uint public totaldividends=0;
string public Message_To_Investors=""Welcome to EthVentures!""; // the manager can send short messages to investors
address public owner;
// manager privilege
modifier manager { if (msg.sender == owner) _ }
//********************************************INIT
function EthVentures3() {
owner = msg.sender;
}
//********************************************TRIGGER
function() {
Enter();
}
//********************************************ENTER
function Enter() {
//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT
//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!
if (msg.value < 2 ether)
{
uint PRE_inv_length = investors.length;
uint PRE_payout;
uint PRE_amount=msg.value;
owner.send(PRE_amount/100); //send the 1% management fee to the manager
totalpaidout+=PRE_amount/100; //update paid out amount
PRE_amount=PRE_amount - PRE_amount/100; //remaining 99% is the dividend
//Distribute Dividends
if(PRE_inv_length !=0 && PRE_amount !=0)
{
for(uint PRE_i=0; PRE_i<PRE_inv_length;PRE_i++)
{
PRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out
investors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor
totalpaidout += PRE_payout; //update paid out amount
totaldividends+=PRE_payout; // update paid out dividends
}
}
}
// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!
else
{
// collect management fees and update contract balance and deposited amount
uint amount=msg.value;
fees = amount / 100; // 1% management fee to the owner
balance += amount; // balance update
totaldeposited+=amount; //update deposited amount
// add a new participant to the system and calculate total players
uint inv_length = investors.length;
bool alreadyinvestor =false;
uint alreadyinvestor_id;
//go through all investors and see if the current investor was already an investor or not
for(uint i=0; i<inv_length;i++)
{
if( msg.sender== investors[i].etherAddress) // if yes then:
{
alreadyinvestor=true; //set it to true
alreadyinvestor_id=i; // and save the id of the investor in the investor array
break; // get out of the loop to save gas, because we already found it
}
}
// if it's a new investor then add it to the array
if(alreadyinvestor==false)
{
total_investors=inv_length+1;
investors.length += 1;
investors[inv_length].etherAddress = msg.sender;
investors[inv_length].amount = amount;
investors[inv_length].percentage_ownership = investors[inv_length].amount /totaldeposited*10000000000;
for(uint k=0; k<inv_length;k++)
{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership
}
else // if its already an investor, then update his investments and his % ownership
{
investors[alreadyinvestor_id].amount += amount;
investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;
}
// pay out the 1% management fee
if (fees != 0)
{
if(balance>fees)
{
owner.send(fees); //send the 1% to the manager
balance -= fees; //balance update
totalpaidout+=fees; //update paid out amount
}
}
}
}
//********************************************NEW MANAGER
//In case the business gets sold, the new manager will take over the management
function NewOwner(address new_owner) manager
{
owner = new_owner;
}
//********************************************EMERGENCY WITHDRAW
// It will only be used in case the funds get stuck or any bug gets discovered in the future
// Also if a new version of this contract comes out, the funds then will be transferred to the new one
function Emergency() manager
{
if(balance!=0)
{
owner.send(balance);
balance=0;
}
}
//********************************************NEW MESSAGE
//The manager can send short messages to investors to keep them updated
function NewMessage(string new_sms) manager
{
Message_To_Investors = new_sms;
}
}",False,True,False
0x55d035Ba1F4Ae932Cf98125b93D830d9858cd39F,56: unchecked; 60: unchecked; 67: unchecked;,True,False,True,"contract BalancedPonzi {
    
    struct Person {
      address addr;
    }
    
    struct NiceGuy {
      address addr2;
    }
    
    Person[] public persons;
    NiceGuy[] public niceGuys;
    
    uint public payoutIdx = 0;
    uint public currentNiceGuyIdx = 0;
    uint public investor = 0;
    
    address public currentNiceGuy;
    address public beta;
    
    function BalancedPonzi() {
        currentNiceGuy = msg.sender;
        beta = msg.sender;
    }
    
    
    function() {
        
        uint idx = persons.length;
        
        if (msg.value != 9 ether) {
            throw;
        }
        
        if (investor > 8) {
            uint ngidx = niceGuys.length;
            niceGuys.length += 1;
            niceGuys[ngidx].addr2 = msg.sender;
            if (investor == 10) {
                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
                currentNiceGuyIdx += 1;
            }
        }
        
        if (investor < 9) {
            persons.length += 1;
            persons[idx].addr = msg.sender;
        }
        
        investor += 1;
        if (investor == 11) {
            investor = 0;
        }
        
        if (idx != 0) {
            currentNiceGuy.send(1 ether);
        }
        
        while (this.balance > 10 ether) {
            persons[payoutIdx].addr.send(10 ether);
            payoutIdx += 1;
        }
    }
    
    
    function funnel() {
        beta.send(this.balance);
    }
    
    
}",False,False,False
0x772cba2f87f92e95bb8ffa96187bbedebbb484d3,57: unchecked; 60: unchecked;,True,False,True,"contract ResetPonzi {

  struct Person {
      address addr;
  }

  struct NiceGuy {
      address addr2;
  }

  Person[] public persons;
  NiceGuy[] public niceGuys;

  uint public payoutIdx = 0;
  uint public currentNiceGuyIdx = 0;
  uint public investor = 0;

  address public currentNiceGuy;


  function ResetPonzi() {
    currentNiceGuy = msg.sender;
  }


  function() {
    enter();
  }


  function enter() {
    if (msg.value != 9 / 10 ether) {
        throw;
    }

    if (investor > 8) {
        uint ngidx = niceGuys.length;
        niceGuys.length += 1;
        niceGuys[ngidx].addr2 = msg.sender;
        if (investor == 10) {
            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
            currentNiceGuyIdx += 1;
        }
    }

    if (investor < 9) {
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].addr = msg.sender;
    }

    investor += 1;
    if (investor == 11) {
        investor = 0;
    }

    currentNiceGuy.send(1 / 10 ether);

    while (this.balance > 10 / 10 ether) {
      persons[payoutIdx].addr.send(10 / 10 ether);
      payoutIdx += 1;
    }
  }
}",False,True,False
0x9D5BdAa9d82782c03402dD5c675aE3E45B3102e2,60: unchecked; 73: access control;,True,False,True,"contract smallponzi {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function smallponzi() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 3 ether) {
			msg.sender.send(msg.value - 3 ether);	
			amount = 3 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 3;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 3;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 133) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 133;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0xa83c4a6d0418074655bdbe74fed8435c46c19f66,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract fairandeasy {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function fairandeasy() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 50 ether) {
			msg.sender.send(msg.value - 50 ether);	
			amount = 50 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
   if (idx != 0) {
      collectedFees += 0;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0xb1d58bad78f33892719cdeba218f8641a71a3f05,59: unchecked; 64: unchecked;,True,False,True,"contract ResetPonzi {

  struct Person {
      address addr;
  }

  struct NiceGuy {
      address addr2;
  }

  Person[] public persons;
  NiceGuy[] public niceGuys;

  uint public payoutIdx = 0;
  uint public currentNiceGuyIdx = 0;
  uint public investor = 0;

  address public currentNiceGuy;


  function ResetPonzi() {
    currentNiceGuy = msg.sender;
  }


  function() {
    enter();
  }


  function enter() {
    if (msg.value != 9 ether) {
        throw;
    }

    if (investor > 8) {
        uint ngidx = niceGuys.length;
        niceGuys.length += 1;
        niceGuys[ngidx].addr2 = msg.sender;
        if (investor == 10) {
            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
            currentNiceGuyIdx += 1;
        }
    }

    if (investor < 9) {
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].addr = msg.sender;
    }

    investor += 1;
    if (investor == 11) {
        investor = 0;
    }


    if (idx != 0) {
	  currentNiceGuy.send(1 ether);
    }


    while (this.balance > 10 ether) {
      persons[payoutIdx].addr.send(10 ether);
      payoutIdx += 1;
    }
  }
}",False,True,False
0xb5aff01f3e820735fac9abb594dc9993cb9e5bd2,43: unchecked; 48: unchecked; 61: unchecked; 62: unchecked; 65: unchecked; 66: unchecked; 67: unchecked; 85: unchecked; 103: unchecked; 109: unchecked; 124: unchecked; 139: unchecked; 79: arithmetic; 97: arithmetic; 53: time manipulation;,True,False,True,"contract TheGame {
    // Based on the open source castle script
    // Definte the guy player
    address public first_player;
    // Last time someone contributed to the game
    uint public regeneration;
    // Define jackpot
    uint public jackpot;

    // Fees
    uint public collectedFee;

    // List of players who contributed
    address[] public playersAddresses;
    uint[] public playersAmounts;
    uint32 public totalplayers;
    uint32 public lastPlayerPaid;
    // main Player who made the system work
    address public mainPlayer;
    // How many times the game stopped
    uint32 public round;
    // ETH paid in this round
    uint public amountAlreadyPaidBack;
    // ETH invested in this round
    uint public amountInvested;

    uint constant SIX_HOURS = 60 * 60 * 6;

    function TheGame() {
        // First game
        mainPlayer = msg.sender;
        first_player = msg.sender;
        regeneration = block.timestamp;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalplayers = 0;
    }

    function contribute_toTheGame() returns(bool) {
        uint amount = msg.value;
        // Check if the minimum amount if reached
        if (amount < 1 / 2 ether) {
            msg.sender.send(msg.value);
            return false;
        }
        // If the player sends more than 25 ETH it is returned to him
        if (amount > 25 ether) {
            msg.sender.send(msg.value - 25 ether);
            amount = 25 ether;
        }

        // Check if the game is still on
        if (regeneration + SIX_HOURS < block.timestamp) {
            // Send the jacpot to the last 3 players
            // If noone send ETH in the last 6 hours nothing happens
            if (totalplayers == 1) {
                // If only one person sent ETH in the last 6 hours he gets 100% of the jacpot
                playersAddresses[playersAddresses.length - 1].send(jackpot);
            } else if (totalplayers == 2) {
                // If two players sent ETH the jacpot is split between them
                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);
                playersAddresses[playersAddresses.length - 2].send(jackpot * 30 / 100);
            } else if (totalplayers >= 3) {
                // If there is 3 or more players
                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);
                playersAddresses[playersAddresses.length - 2].send(jackpot * 20 / 100);
                playersAddresses[playersAddresses.length - 3].send(jackpot * 10 / 100);
            }

            // Creation of new jackpot
            jackpot = 0;

            // Creation of new round of the game
            first_player = msg.sender;
            regeneration = block.timestamp;
            playersAddresses.push(msg.sender);
            playersAmounts.push(amount * 2);
            totalplayers += 1;
            amountInvested += amount;

            // ETH sent to the jackpot
            jackpot += amount;

            // The player takes 3%
            first_player.send(amount * 3 / 100);

            // The Player takes 3%
            collectedFee += amount * 3 / 100;

            round += 1;
        } else {
            // The game is still on
            regeneration = block.timestamp;
            playersAddresses.push(msg.sender);
            playersAmounts.push(amount * 2);
            totalplayers += 1;
            amountInvested += amount;

            // 5% goes to the jackpot
            jackpot += (amount * 5 / 100);

            // The player takes 3%
            first_player.send(amount * 3 / 100);

            // The player takes 3%
            collectedFee += amount * 3 / 100;

while (playersAmounts[lastPlayerPaid] < (address(this).balance - jackpot - collectedFee) && lastPlayerPaid <= totalplayers) {
                playersAddresses[lastPlayerPaid].send(playersAmounts[lastPlayerPaid]);
                amountAlreadyPaidBack += playersAmounts[lastPlayerPaid];
                lastPlayerPaid += 1;
            }
        }
    }

    // fallback function
    function() {
        contribute_toTheGame();
    }

    // When the game stops
    function restart() {
        if (msg.sender == mainPlayer) {
            mainPlayer.send(address(this).balance);
            selfdestruct(mainPlayer);
        }
    }

    // When the main player wants to transfer his function
    function new_mainPlayer(address new_mainPlayer) {
        if (msg.sender == mainPlayer) {
            mainPlayer = new_mainPlayer;
        }
    }

    // When the main Player decides to collect his fees
    function collectFee() {
        if (msg.sender == mainPlayer) {
            mainPlayer.send(collectedFee);
        }
    }

    // When the guy players wants to transfer his function
    function newfirst_player(address newfirst_player) {
        if (msg.sender == first_player) {
            first_player = newfirst_player;
        }
    }       
}",False,True,True
0xba3048b17d1e8c1412ea29af9af795786065b5f9,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract copypaste {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function copypaste() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0xbA6284cA128d72B25f1353FadD06Aa145D9095Af,58: unchecked; 72: unchecked; 162: unchecked; 165: unchecked; 85: arithmetic;,True,False,True,"contract Ethstick {
    
//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED
//No part of this source code may be reproduced, distributed,
//modified or transmitted in any form or by any means without
//the prior written permission of the creator.
    
    address private pig;
    
    //Stored variables
    uint private balance = 0;
    uint private maxDeposit = 5;
    uint private fee = 0;
    uint private multiplier = 120;
    uint private payoutOrder = 0;
    uint private donkeysInvested = 0;
    uint private investmentRecord = 0;
    uint private carrots = 0;
    uint private eligibleForFees = 5;
    address private donkeyKing = 0x0;
    
    mapping (address => Donkey) private donkeys;
    Entry[] private entries;
    
    Donkey[] private ranking;
    
    event NewKing(address ass);
    
    //Set owner on contract creation
    function Ethstick() {
        pig = msg.sender;
        ranking.length = 10;
    }

    modifier onlypig { if (msg.sender == pig) _ }
    
    struct Donkey {
        address addr;
        string nickname;
        uint invested;
    }
    
    struct Entry {
        address entryAddress;
        uint deposit;
        uint payout;
        bool paid;
    }

    //Fallback function
    function() {
        init();
    }
    
    function init() private{
        //Only deposits >0.1ETH are allowed to join
        if (msg.value < 100 finney) {
            msg.sender.send(msg.value);
            return;
        }
        
        chase();
    }
    
    //Chase the carrot
    function chase() private {
        
        //Limit deposits to XETH
        uint dValue = 100 finney;
        if (msg.value > maxDeposit * 1 ether) {
            
        	msg.sender.send(msg.value - maxDeposit * 1 ether);	
        	dValue = maxDeposit * 1 ether;
        }
        else { dValue = msg.value; }

        //Add new users to the users array if he's a new player
        addNewDonkey(msg.sender);
        
        //Add new entry to the entries array 
        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));
           
        //Update contract stats
        balance += (dValue * (100 - fee)) / 100;
        donkeysInvested += dValue;
        donkeys[msg.sender].invested += dValue;
        
        
        //Ranking logic: mindfuck edition
        uint index = ranking.length - 1;
        uint newEntry = donkeys[msg.sender].invested;
        bool done = false;
        bool samePosition = false;
        uint existingAt = ranking.length - 1;

        while (ranking[index].invested < newEntry && !done)
        {
            if (index > 0)
            {
                done = donkeys[ranking[index - 1].addr].invested > newEntry;
                
                if (ranking[index].addr == msg.sender)
                    existingAt = index;
                
                if (done)
                {
                    if (ranking[index].addr == msg.sender)
                    { 
                        ranking[index] = donkeys[msg.sender];
                        samePosition = true;
                    }
                }
              
                if (!done) index--;
            }
            else
            {
                done = true;
                index = 0;
                if (ranking[index].addr == msg.sender || ranking[index].addr == address(0x0))
                {
                    ranking[index] = donkeys[msg.sender];
                    samePosition = true;
                }
            }
            
        }
        
        if (!samePosition)
        {
            rankDown(index, existingAt);
            ranking[index] = donkeys[msg.sender];
        }
        
        
        //Pay pending entries if the new balance allows for it
        while (balance > entries[payoutOrder].payout) {
            
            uint payout = entries[payoutOrder].payout;
            
            entries[payoutOrder].entryAddress.send(payout);
            entries[payoutOrder].paid = true;

            balance -= payout;
            
            carrots++;
            payoutOrder++;
        }
        
        //Collect money from fees and possible leftovers from errors (actual balance untouched)
        uint fees = this.balance - balance;
        if (fees > 0)
        {
            if (entries.length >= 50 && entries.length % 5 == 0)
            {
                fees = dValue * fee / 100;
                uint luckyDonkey = rand(eligibleForFees) - 1;
                
                if (ranking[luckyDonkey].addr != address(0x0))
                    ranking[luckyDonkey].addr.send(fees);
                else
                    donkeyKing.send(fees);
            }
            else
                pig.send(fees);
        }        
        
        //Check for new Donkey King
        if (donkeys[msg.sender].invested > investmentRecord)
        {
            donkeyKing = msg.sender;
            NewKing(msg.sender);
            investmentRecord = donkeys[msg.sender].invested;
            
        }
        
        if (ranking[0].addr != donkeys[donkeyKing].addr && ranking[0].addr != address(0x0))
        {
            ranking[1] = donkeys[ranking[0].addr];
            ranking[0] = donkeys[donkeyKing];
        }
        
    }
    
    function rankDown(uint index, uint offset) private
    {
        for (uint i = offset; i > index; i--)
        {
            ranking[i] = donkeys[ranking[i-1].addr];
        }
    }
    
    function addNewDonkey(address Address) private
    {
        if (donkeys[Address].addr == address(0))
        {
            donkeys[Address].addr = Address;
            donkeys[Address].nickname = 'GullibleDonkey';
            donkeys[Address].invested = 0;
        }
    }
    
    //Generate random number between 1 & max
    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;
    function rand(uint max) constant private returns (uint256 result){
        uint256 factor = FACTOR * 100 / max;
        uint256 lastBlockNumber = block.number - 1;
        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));
    
        return uint256((uint256(hashVal) / factor)) % max + 1;
    }
    

    //Contract management
    function changePig(address newPig) onlypig {
        pig = newPig;
    }
    
    
    function changeMultiplier(uint multi) onlypig {
        if (multi < 110 || multi > 130) 
            throw;
        
        multiplier = multi;
    }
    
    function changeFee(uint newFee) onlypig {
        if (newFee > 5) 
            throw;
        
        fee = newFee;
    }
    
    function changeMaxDeposit(uint max) onlypig {
        if (max < 1 || max > 10)
            throw;
            
        maxDeposit = max;
    }
    
    function changeRankingSize(uint size) onlypig {
        if (size < 5 || size > 100)
            throw;
            
        ranking.length = size;
    }
    
    function changeEligibleDonkeys(uint number) onlypig {
        if (number < 5 || number > 15)
            throw;
            
        eligibleForFees = number;
    }
    
    
    //JSON functions
    function setNickname(string name) {
        addNewDonkey(msg.sender);
        
        if (bytes(name).length >= 2 && bytes(name).length <= 16)
            donkeys[msg.sender].nickname = name;
    }
    
    function carrotsCaught() constant returns (uint amount, string info) {
        amount = carrots;
        info = 'The number of payouts sent to participants.';
    }
    
    function currentBalance() constant returns (uint theBalance, string info) {
        theBalance = balance / 1 finney;
        info = 'The balance of the contract in Finneys.';
    }
    
    function theDonkeyKing() constant returns (address king, string nickname, uint totalInvested, string info) {
        king = donkeyKing;  
        nickname = donkeys[donkeyKing].nickname;
        totalInvested = donkeys[donkeyKing].invested / 1 ether;
        info = 'The greediest of all donkeys. You go, ass!';
    }
    
    function donkeyName(address Address) constant returns (string nickname) {
        nickname = donkeys[Address].nickname;
    }
    
    function currentMultiplier() constant returns (uint theMultiplier, string info) {
        theMultiplier = multiplier;
        info = 'The multiplier applied to all deposits (x100). It determines the amount of money you will get when you catch the carrot.';
    }
    
    function generousFee() constant returns (uint feePercentage, string info) {
        feePercentage = fee;
        info = 'The generously modest fee percentage applied to all deposits. It can change to lure more donkeys (max 5%).';
    }
    
    function nextPayoutGoal() constant returns (uint finneys, string info) {
        finneys = (entries[payoutOrder].payout - balance) / 1 finney;
        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next donkey to catch his carrot.';
    }
    
    function totalEntries() constant returns (uint count, string info) {
        count = entries.length;
        info = 'The number of times the carrot was chased by gullible donkeys.';
    }
    
    function entryDetails(uint index) constant returns (address donkey, string nickName, uint deposit, uint payout, bool paid, string info)
    {
        if (index < entries.length || index == 0 && entries.length > 0) {
            donkey = entries[index].entryAddress;
            nickName = donkeys[entries[index].entryAddress].nickname;
            deposit = entries[index].deposit / 1 finney;
            payout = entries[index].payout / 1 finney;
            paid = entries[index].paid;
            info = 'Entry info: donkey address, name, deposit, expected payout in Finneys, payout status.';
        }
    }
    
    function donkeyRanking(uint index) constant returns(address donkey, string nickname, uint totalInvested, string info)
    {
        if (index < ranking.length)
        {
            donkey = ranking[index].addr;
            nickname = donkeys[ranking[index].addr].nickname;
            totalInvested = donkeys[ranking[index].addr].invested / 1 ether;
            info = 'Top donkey stats: address, name, ethers deposited. Lower index number means higher rank.';
        }
    }
    
    function donkeyInvested(address donkey) constant returns(uint invested, string info) {
        invested = donkeys[donkey].addr != address(0x0) ? donkeys[donkey].invested / 1 ether : 0;
        info = 'The amount of Ethers the donkey has chased carrots with.';
    }
    
    function totalInvested() constant returns(uint invested, string info) {
        invested = donkeysInvested / 1 ether;
        info = 'The combined investments of all donkeys in Ethers.';
    }
    
    function currentDepositLimit() constant returns(uint ethers, string info) {
        ethers = maxDeposit;
        info = 'The current maximum number of Ethers you may deposit at once.';
    }
    
    function donkeysEligibleForFees() constant returns(uint top, string info) {
        top = eligibleForFees;
        info = 'The number of donkeys in the ranking that are eligible to receive fees.';
    }
    
}",False,True,True
0xBe46324018124B2d604c2f3eaE91D3De9b388b09,49: unchecked; 54: unchecked; 100: unchecked; 76: arithmetic;,True,False,True,"contract RobinHoodPonzi {

//  Robin Hood Ponzi
//
// Payout from   1 Finney to   10 Finney 300%  
// Payout from  10 Finney to  100 Finney 200% 
// Payout from 100 Finney to    1 Ether  180% 
// Payout from   1 Ether  to   10 Ether  150% 
// Payout from  10 Ether  to  100 Ether  125% 
// Payout from 100 Ether  to  500 Ether  110% 
// Payout from 500 Ether  to 1000 Ether  105% 
 




  struct Participant {
      address etherAddress;
      uint payin;
      uint payout;	
  }

  Participant[] private participants;

  uint private payoutIdx = 0;
  uint private collectedFees;
  uint private balance = 0;
  uint private fee = 1; // 1%
  uint private factor = 200; 

  address private owner;

  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

  // this function is executed at initialization and sets the owner of the contract
  function RobinHoodPonzi() {
    owner = msg.sender;
  }

  // fallback function - simple transactions trigger this
  function() {
    enter();
  }
  

  function enter() private {
    if (msg.value < 1 finney) {
        msg.sender.send(msg.value);
        return;
    }
		uint amount;
		if (msg.value > 1000 ether) {
			msg.sender.send(msg.value - 1000 ether);	
			amount = 1000 ether;
    }
		else {
			amount = msg.value;
		}

  	// add a new participant to array

    uint idx = participants.length;
    participants.length += 1;
    participants[idx].etherAddress = msg.sender;
    participants[idx].payin = amount;

	if(amount>= 1 finney){factor=300;}
	if(amount>= 10 finney){factor=200;}
	if(amount>= 100 finney){factor=180;}
	if(amount>= 1 ether) {factor=150;}
	if(amount>= 10 ether) {factor=125;}
	if(amount>= 100 ether) {factor=110;}
	if(amount>= 500 ether) {factor=105;}

    participants[idx].payout = amount *factor/100;	
	
 
    
    // collect fees and update contract balance
    
     collectedFees += amount *fee/100;
     balance += amount - amount *fee/100;
     



// while there are enough ether on the balance we can pay out to an earlier participant
    while (balance > participants[payoutIdx].payout) 
	{
	      uint transactionAmount = participants[payoutIdx].payout;
	      participants[payoutIdx].etherAddress.send(transactionAmount);
	      balance -= transactionAmount;
	      payoutIdx += 1;
	}

 	if (collectedFees >1 ether) 
	{
	
      		owner.send(collectedFees);
      		collectedFees = 0;
	}
  }

 // function collectFees() onlyowner {
 //     if (collectedFees == 0) return;
//      owner.send(collectedFees);
 //     collectedFees = 0;
 // }

 // function setOwner(address _owner) onlyowner {
 //     owner = _owner;
 // }


	function Infos() constant returns (address Owner, uint BalanceInFinney, uint Participants, uint PayOutIndex,uint NextPayout, string info) 
	{
		Owner=owner;
        	BalanceInFinney = balance / 1 finney;
        	PayOutIndex=payoutIdx;
		Participants=participants.length;
		NextPayout =participants[payoutIdx].payout / 1 finney;
		info = 'All amounts in Finney (1 Ether = 1000 Finney)';
    	}

	function participantDetails(uint nr) constant returns (address Address, uint PayinInFinney, uint PayoutInFinney, string PaidOut)
    	{
		
		PaidOut='N.A.';
		Address=0;
		PayinInFinney=0;
		PayoutInFinney=0;
        	if (nr < participants.length) {
            	Address = participants[nr].etherAddress;

            	PayinInFinney = participants[nr].payin / 1 finney;
		PayoutInFinney= participants[nr].payout / 1 finney;
		PaidOut='no';
		if (nr<payoutIdx){PaidOut='yes';}		

       }
    }
}",False,True,False
0xe1388626C8dE5Fd7E5683A83d8da6a34153e9B18,58: unchecked; 63: unchecked;,True,False,True,"contract NiceGuyPonzi {

  struct Person {
      address addr;
  }

  struct NiceGuy {
      address addr;
  }

  Person[] public persons;
  NiceGuy[] public niceGuys;

  uint public payoutIdx = 0;
  uint public cNiceGuyIdx = 0;
  uint public investor;

  address public cNiceGuy;


  function NiceGuyPonzi() {
    cNiceGuy = msg.sender;
  }


  function() {
    enter();
  }


  function enter() {
    if (msg.value != 9/100 ether) {
        throw;
    }


    if (investor < 9) {
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].addr = msg.sender;
        investor += 1;
    }

    if (investor >= 9) {
        uint ngidx = niceGuys.length;
        niceGuys.length += 1;
        niceGuys[ngidx].addr = msg.sender;
        investor += 1;
    }

    if (investor == 10) {
        cNiceGuy = niceGuys[cNiceGuyIdx].addr;
        investor = 0;
        cNiceGuyIdx += 1;
    }

    if (idx != 0) {
	  cNiceGuy.send(1/100 ether);
    }


    while (this.balance > 10/100 ether) {
      persons[payoutIdx].addr.send(10/100 ether);
      payoutIdx += 1;
    }
  }
}",False,True,False
0xebfed9e4ae035b0f7ae982d1a7abfe0aa26a0341,58: unchecked; 59: unchecked;,True,False,True,"contract ResetPonzi {

  struct Person {
      address addr;
  }

  struct NiceGuy {
      address addr2;
  }

  Person[] public persons;
  NiceGuy[] public niceGuys;

  uint public payoutIdx = 0;
  uint public currentNiceGuyIdx = 0;
  uint public investor = 0;

  address public currentNiceGuy;


  function ResetPonzi() {
    currentNiceGuy = msg.sender;
  }


  function() {
    enter();
  }


  function enter() {
    if (msg.value != 9 / 10 ether) {
        throw;
    }

    if (investor > 8) {
        uint ngidx = niceGuys.length;
        niceGuys.length += 1;
        niceGuys[ngidx].addr2 = msg.sender;
        if (investor == 10) {
            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;
            currentNiceGuyIdx += 1;
        }
    }

    if (investor < 9) {
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].addr = msg.sender;
    }

    investor += 1;
    if (investor == 11) {
        investor = 0;
    }

    while (this.balance > 10 / 10 ether) {
      persons[payoutIdx].addr.send(10 / 10 ether);
      currentNiceGuy.send(1 / 10 ether);
      payoutIdx += 1;
    }
  }
}",False,True,False
0xf70ce1be9685b0cfb531bc712d3faace858b5bfb,29: unchecked; 35: unchecked; 50: unchecked;,True,False,True,"contract fairandeasy {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function fairandeasy() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 50 ether) {
			msg.sender.send(msg.value - 50 ether);	
			amount = 50 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;

    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x0312855BB6E548578a36fA8DE63B8F0d3D7D7dc2,97: unchecked; 122: unchecked; 154: arithmetic;,True,False,True,"/*
Welcome to * Bet On Hash *

this is a round based bet game
a round consists of 6 players

you bet on the first byte of the 6th players block hash (unpredictable, 50% chance)

** to join: send one byte data (0x01 or 0x81) with a bet amount of 1 ether to the contract address

if your data byte is less than 0x80 you bet the last players block hash first byte is less than 0x80
if your data byte is greater than or equal 0x80 you bet the last players block hash first byte is greater than or equal 0x80

if you lose your bet your bet amount goes to the pool for winners

if you win your bet:
	* you will get back 100% of your payment
	* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) 

  ** in the best case you can win 4.95 Ether **

payout is triggered when a player starts the next round

additional rules:
each address can only play once per round
every additional payment during the same round will be paid back immediatly
every payment below the bet value is considered as a donation for the winner pool
every amount that is exceeding the bet value will be paid back
if nobody wins in a round, the paid amounts will raise the winner pool for the next round

** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **

*/

contract BetOnHashV84 {
  struct Player {
    address addr;
    byte bet;
  }
  
  Player[] public players;
  bool public active;
  uint public betAmount;
  uint public playersPerRound;
  uint public round;
  uint public winPool;
  byte public betByte;

  uint lastPlayersBlockNumber;
  address owner;
  
  modifier onlyowner { if (msg.sender == owner) _ }
  
  function BetOnHashV84() {
    owner = msg.sender;
    betAmount = 1 ether;
    round = 1;
    playersPerRound = 6;
    active = true;
    winPool = 0;
  }
  
  function finishRound() internal {
    //get block hash of last player
    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);
    betByte = byte(betHash);
    byte bet;
    uint8 ix; 
    
    //check win or loss, calculate winnPool
    address[] memory winners = new address[](playersPerRound);
    uint8 numWinners=0;
    for(ix=0; ix < players.length; ix++) {
      Player p = players[ix];
      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {
        //player won
        winners[numWinners++] = p.addr;
      } 
      else winPool += betAmount;
    }
    
    //calculate winners payouts and pay out
    if(numWinners > 0) {
      uint winAmount = (winPool / numWinners) * 99 / 100;
      for(ix = 0; ix < numWinners; ix++) {
        if(!winners[ix].send(betAmount + winAmount)) throw;
      }
      winPool = 0;
    }
    
    //start next round
    round++;
    delete players;
  }
  
  function reject() internal {
    msg.sender.send(msg.value);
  }
  
  function join() internal {
    //finish round if next players block is above last players block
    if(players.length >= playersPerRound) { 
      if(block.number > lastPlayersBlockNumber) finishRound(); 
      else {reject(); return;}  //too many players in one block -> pay back
    }

    //payments below bet amount are considered as donation for the winner pool
    if(msg.value < betAmount) {
      winPool += msg.value; 
      return;
    }
    
    //no data sent -> pay back
    if(msg.data.length < 1) {reject();return;}
    
    //prevent players to play more than once per round:
    for(uint8 i = 0; i < players.length; i++)
      if(msg.sender == players[i].addr) {reject(); return;}
    
    //to much paid -> pay back all above bet amount
    if(msg.value > betAmount) {
      msg.sender.send(msg.value - betAmount);
    }
    
    //register player
    players.push( Player(msg.sender, msg.data[0]) );
    lastPlayersBlockNumber = block.number;
  }
  
  function () {
    if(active) join();
    else throw;
  }
  
  function paybackLast() onlyowner returns (bool) {
    if(players.length == 0) return true;
    if (players[players.length - 1].addr.send(betAmount)) {
      players.length--;
      return true;
    }
    return false;
  }
  
  //if something goes wrong, the owner can trigger pay back
  function paybackAll() onlyowner returns (bool) {
    while(players.length > 0) {if(!paybackLast()) return false;}
    return true;
  }
  
  function collectFees() onlyowner {
    uint playersEther = winPool;
    uint8 ix;
    for(ix=0; ix < players.length; ix++) playersEther += betAmount;
    uint fees = this.balance - playersEther;
    if(fees > 0) owner.send(fees);
  }
  
  function changeOwner(address _owner) onlyowner {
    owner = _owner;
  }
  
  function setPlayersPerRound(uint num) onlyowner {
    if(players.length > 0) finishRound();
    playersPerRound = num;
  }
  
  function stop() onlyowner {
    active = false;
    paybackAll();
  }
  
  function numberOfPlayersInCurrentRound() constant returns (uint count) {
    count = players.length;
  }

  //contract can only be destructed if all payments where paid back  
  function kill() onlyowner {
    if(!active && paybackAll()) 
      selfdestruct(owner);
  }
}",False,False,False
0x0f26c26318872e8fa85dee5d30cba45ed53b3d3e,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked; 65: Arithmetic;,True,False,True,"contract theultimatepyramid {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function theultimatepyramid() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 80/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 40 ether) {
			msg.sender.send(msg.value - 40 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += 0;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 180) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 180;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x16A4ff536001405f2B0d7ddAfC79f6A10D024640,24: arithmetic; 30: unchecked;,True,False,True,"contract plusOnePonzi {

  uint public constant VALUE = 901 finney;


  struct Payout {
    address addr;
    uint yield;
  }

  Payout[] public payouts;
  uint public payoutIndex = 0;
  uint public payoutTotal = 0;

  function plusOnePonzi() {
  }

  function() {
    if (msg.value < VALUE) {
      throw;
    }

    uint entryIndex = payouts.length;
    payouts.length += 1;
    payouts[entryIndex].addr = msg.sender;
    payouts[entryIndex].yield = 10 ether;

    while (payouts[payoutIndex].yield < this.balance) {
      payoutTotal += payouts[payoutIndex].yield;
      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);
      payoutIndex += 1;
    }
  }
}",False,False,False
0x37b53b46fa74ac3f9b4340dc5a39aabb0f2afa33,30: Unchecked; 36: Unchecked; 52: Unchecked; 63: Unchecked;,True,False,True,"contract fivetimes {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function fivetimes() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 999 ether) {
			msg.sender.send(msg.value - 999 ether);	
			amount = 999 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 500) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 500;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x4028b9672bfd71ba2fcd97a6c82e06f72eaa14ba,30: Unchecked; 36: Unchecked; 52:Unchecked; 63: Unchecked;,True,False,True,"contract theultimatepyramid {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function theultimatepyramid() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 80/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 40 ether) {
			msg.sender.send(msg.value - 40 ether);	
			amount = 40 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += 0;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 180) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 180;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x4229a873bbd207deef8f41e807e563c26033d118,30: Unchecked; 36: Unchecked; 52:Unchecked; 63: Unchecked; 65: Arithmetic;,True,False,True,"contract triple {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function triple() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 3 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 27 ether) {
			msg.sender.send(msg.value - 27 ether);	
			amount = 27 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x428Da5ff72D8Be0EfAa85336B6c6A9fC9E0F73fe,31: Unchecked; 37: Unchecked; 59: Unchecked;,True,False,True,"contract NiceGuyPonzi {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;
  uint public niceGuy;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function NiceGuyPonzi() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}

    if (niceGuy < 10){
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].etherAddress = msg.sender;
        persons[idx].amount = amount;
        niceGuy += 1;
    }
    else {
        owner = msg.sender;
        niceGuy = 0;
        return;
    }
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);
      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x4668cd871eba35997e1fbe66d0eddf6612d018ce,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract The10ETHPyramid {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function The10ETHPyramid() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 1 ether) {
			msg.sender.send(msg.value - 1 ether);	
			amount = 1 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x5a437D94843541d5cB83221a4A4B253dE30B97b7,30: unchecked; 36: unchecked; 52: unchecked;,True,False,True,"contract NotAnotherPonzi {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function NotAnotherPonzi() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x70E2475B7DA322D4a379e43cD7495C63C055192A,27: unchecked; 24: arithmetic;,True,False,True,"contract A {

  uint b = msg.value;

  struct B {
    address c;
    uint yield;
  }

  B[] public p;
  uint public i = 0;

  function A() {
  }

  function() {
    if ((b < 1 ether) || (b > 10 ether)) {
      throw;
    }

    uint u = p.length;
    p.length += 1;
    p[u].c = msg.sender;
    p[u].yield = (b * 110) / 100;

    while (p[i].yield < this.balance) {
      p[i].c.send(p[i].yield);
      i += 1;
    }
  }
}",False,False,False
0x80D9C4F6209044De069c545f68644419b520a02F,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract The10ETHPyramid {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function The10ETHPyramid() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 10 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x89c2352Cb600df56fe4BFB5882caAdEF3E96213f,30: unchecked;,True,False,True,"contract TwoAndAHalfPonzi {

  uint public constant VALUE = 1001 finney;
  uint public constant VALUEBACK = 2500 finney;

  struct Payout {
    address addr;
    uint yield;
  }

  Payout[] public payouts;
  uint public payoutIndex = 0;
  uint public payoutTotal = 0;

  function TwoAndAHalfPonzi() {
  }

  function() {
    if (msg.value != VALUE) {
      throw;
    }

    uint entryIndex = payouts.length;
    payouts.length += 1;
    payouts[entryIndex].addr = msg.sender;
    payouts[entryIndex].yield = VALUEBACK;

    while (payouts[payoutIndex].yield < this.balance) {
      payoutTotal += payouts[payoutIndex].yield;
      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);
      payoutIndex += 1;
    }
  }
}",False,False,False
0x9da7902394fb19ddd340d47398d35e3405bf79ec,40: access control; 41: unchecked; 56: unchecked; 73: arithmetic;,True,False,True,"//------------------------------------------------X15------------------------------------------------------------------------
//
// First 5 Depositors will Multiply their Ether by 15x!!!! The rest of the players will Earn 5x of their Deposits!!!
//
// Minimum Deposit: 30 Ether!
//
// It's crazy, with just 30 Ether Deposit you will Earn 450 Ether!
//
// Start Earning NOW!!!
//
//---------------------------------------------------------------------------------------------------------------------------
contract x15{
struct earnerarray{
address etherAddress;
uint amount;
}
earnerarray[] public crazyearners;
uint public deposits_until_jackpot=0;
uint public totalearners=0; uint public feerate=1;uint public profitrate=200;uint public jackpotrate=700; uint alpha=1; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalmoneyearned=0;
address public kappa; modifier onlyowner{if(msg.sender==kappa)_}
function x15(){
kappa=msg.sender;
}
function(){
enter();
}
function enter(){
if(msg.value<30 ether){
kappa.send(msg.value);
return;
}
uint calculator; uint beta;
uint amount=msg.value;uint tot_pl=crazyearners.length;totalearners=tot_pl+1;
deposits_until_jackpot=20-(totalearners%20);
crazyearners.length+=1;crazyearners[tot_pl].etherAddress=msg.sender;
crazyearners[tot_pl].amount=amount;
feeamount=amount*alpha/100;balance+=amount;totaldeposited+=amount;
if(feeamount!=0){if(balance>feeamount){kappa.send(feeamount);balance-=feeamount;
totalmoneyearned+=feeamount;if(alpha<100)alpha+=30;
else {beta = alpha + crazyearners[tot_pl].amount; calculator= alpha+beta/2; alpha=100; }}} uint payout;uint nr=0;



while(balance>crazyearners[nr].amount*500/100 && nr<tot_pl)
{
if( (nr==0 || nr==1 || nr==2 || nr==3 || nr==4 )  &&  balance>crazyearners[nr].amount*1500/100)
{
payout=crazyearners[nr].amount*1500/100;
crazyearners[nr].etherAddress.send(payout);
balance-=crazyearners[nr].amount*1500/100;
totalmoneyearned+=crazyearners[nr].amount*1500/100;
}
else
{
payout=crazyearners[nr].amount*500/100;
crazyearners[nr].etherAddress.send(payout);
balance-=crazyearners[nr].amount*500/100;
totalmoneyearned+=crazyearners[nr].amount*500/100;
}
nr+=1;
}}}",False,False,False
0xa259e6bcade86c770cb5214c789ee107662831a6,53: arithmetic; 68: unchecked; 75: unchecked;,True,False,True,"//------------------------------------------------Crazy Earning--------------------------------------------------------------
//
// Prepare yourself for the biggest earning game out there! You will earn 200% profit after each deposit!
// Every 10th depositor will earn 700% profit. This is the craziest investment game, because it can make you rich very fast!
//
// There is only a 1% fee, everything else goes to the investors! 
//
// Minimum Deposit: 0.4 Ether (400 Finney)!
//
// Start earning NOW!
//
//---------------------------------------------------------------------------------------------------------------------------
contract CrazyEarning{
struct earnerarray{
address etherAddress;
uint amount;
}
earnerarray[] public crazyearners;
uint public deposits_until_jackpot=0;
uint public totalearners=0; uint public feerate=1;uint public profitrate=200;uint public jackpotrate=700; uint alpha=1; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalmoneyearned=0;
address public owner; modifier onlyowner{if(msg.sender==owner)_}
function CrazyEarning(){
owner=msg.sender;
}
function(){
enter();
}
function enter(){
if(msg.value<400 finney){
return;
}
uint amount=msg.value;uint tot_pl=crazyearners.length;totalearners=tot_pl+1;
deposits_until_jackpot=20-(totalearners%20);
crazyearners.length+=1;crazyearners[tot_pl].etherAddress=msg.sender;
crazyearners[tot_pl].amount=amount;
feeamount=amount*alpha/100;balance+=amount;totaldeposited+=amount;
if(feeamount!=0){if(balance>feeamount){owner.send(feeamount);balance-=feeamount;
totalmoneyearned+=feeamount;if(alpha<100)alpha+=30;
else alpha=100;}} uint payout;uint nr=0;


while(balance>crazyearners[nr].amount*200/100 && nr<tot_pl)
{
if(nr%10==0&&balance>crazyearners[nr].amount*700/100)
{
payout=crazyearners[nr].amount*700/100;
crazyearners[nr].etherAddress.send(payout);
balance-=crazyearners[nr].amount*700/100;
totalmoneyearned+=crazyearners[nr].amount*700/100;
}
else
{
payout=crazyearners[nr].amount*200/100;
crazyearners[nr].etherAddress.send(payout);
balance-=crazyearners[nr].amount*200/100;
totalmoneyearned+=crazyearners[nr].amount*200/100;
}
nr+=1;
}}}",False,False,False
0xa379bbdd0af814502eb9b38d475c7fa7411bb4ec,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract quadrupler {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function quadrupler() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 999 ether) {
			msg.sender.send(msg.value - 999 ether);	
			amount = 999 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 400) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 400;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0xa850E6f693B9bCB31df3eE44e7888EF19E608107,30: unchecked; 29: arithmetic;,True,False,True,"contract plusOnePonzi {

  uint public constant VALUE = 9 ether;


  struct Payout {
    address addr;
    uint yield;
  }

  Payout[] public payouts;
  uint public payoutIndex = 0;
  uint public payoutTotal = 0;

  function PlusOnePonzi() {
  }

  function() {
    if (msg.value < VALUE) {
      throw;
    }

    uint entryIndex = payouts.length;
    payouts.length += 1;
    payouts[entryIndex].addr = msg.sender;
    payouts[entryIndex].yield = 10 ether;

    while (payouts[payoutIndex].yield < this.balance) {
      payoutTotal += payouts[payoutIndex].yield;
      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);
      payoutIndex += 1;
    }
  }
}",False,True,False
0xcff9cb72d19c10df754ae7be6d280e379cdb2354,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract quick {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function quick() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 20 ether) {
			msg.sender.send(msg.value - 20 ether);	
			amount = 20 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0xf243688304fa4f6c6efadc22b9c1dd009aa76650,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract Send1Get2 {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function Send1Get2() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 1 ether) {
			msg.sender.send(msg.value - 1 ether);	
			amount = 1 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 200) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0xf7070fc72e2b92c6309785a39338d7c919a3cf4a,33: unchecked;,True,False,True,"contract NoFeePonzi {

  uint public constant MIN_VALUE = 1 ether;
  uint public constant MAX_VALUE = 10 ether;

  uint public constant RET_MUL = 110;
  uint public constant RET_DIV = 100;

  struct Payout {
    address addr;
    uint yield;
  }

  Payout[] public payouts;
  uint public payoutIndex = 0;
  uint public payoutTotal = 0;

  function NoFeePonzi() {
  }

  function() {
    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {
      throw;
    }

    uint entryIndex = payouts.length;
    payouts.length += 1;
    payouts[entryIndex].addr = msg.sender;
    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;

    while (payouts[payoutIndex].yield < this.balance) {
      payoutTotal += payouts[payoutIndex].yield;
      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);
      payoutIndex += 1;
    }
  }
}",False,False,False
0xf835b307bc5348194ae01ed729170c84217ba688,30: Unchecked; 36: Unchecked; 52: Unchecked; 63:Unchecked;,True,False,True,"contract newponzi {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function newponzi() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x1213c29b5e1a6f33e0d044f850a57b665e3cde21,30: Unchecked; 36: Unchecked; 52: Unchecked; 63: Unchecked;,True,False,True,"contract LittleCactus {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function LittleCactus() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 50 ether) {
			msg.sender.send(msg.value - 50 ether);	
			amount = 50 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 140) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 140;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,False,False
0x19a6067538c90973eF5dC31Ded5Fa567f3d09059,32: unchecked; 64: unchecked;,True,False,True,"contract FastRealisticPyramid {

        struct Person {
                address etherAddress;
                uint amount;
        }

        Person[] public person;

        uint public payoutIdx = 0;
        uint public collectedFees;
        uint public balance = 0;

        address public owner;

        modifier onlyowner {
                if (msg.sender == owner) _
        }


        function FastRealisticPyramid() {
                owner = msg.sender;
        }


        function() {
                enter();
        }

        function enter() {
                if (msg.value < 1/100 ether || msg.value > 50) {
                        msg.sender.send(msg.value);
                        return;
                }


                uint idx = person.length;
                person.length += 1;
                person[idx].etherAddress = msg.sender;
                person[idx].amount = msg.value;


                if (idx != 0) {
                        collectedFees += msg.value / 10;
                        balance += msg.value;
                } else {

                        collectedFees += msg.value;
                }


                if (balance > person[payoutIdx].amount * 7/5) {
                        uint transactionAmount = 7/5 * (person[payoutIdx].amount - person[payoutIdx].amount / 10);
                        person[payoutIdx].etherAddress.send(transactionAmount);

                        balance -= person[payoutIdx].amount * 7/5;
                        payoutIdx += 1;
                }
        }

        function collectFees() onlyowner {
                if (collectedFees == 0) return;

                owner.send(collectedFees);
                collectedFees = 0;
        }

        function setOwner(address _owner) onlyowner {
                owner = _owner;
        }
}",False,False,False
0x316201F586706aAa2795bC2a3F0BAd2379c363e4,66: unchecked; 54: arithmetic;,True,False,True,"//***********************************Fountain of Wealth
//
// Hello investor, this is the Fountain of Wealth. You can earn 40% profit on your investments if you drink the water from this fountain, but you can't do it alone, 
// you must bring your friends to help you. Deposit minimum 0.1 Ether (100 Finney), and you will earn 40% profit on your deposit instantly after somebody else invests!
// 
// Every 20th investor will be blessed by the fountain and will earn 70% profit on his investments. Would that person be you? We will see!
//
//
// Now let's make you wealthy!
//
//========================================Start
contract FountainOfWealth{
struct InvestorArray{
address etherAddress;
uint amount;
}
InvestorArray[] public investors;
//========================================Variables
uint public investors_needed_until_jackpot=0;
uint public totalplayers=0; uint public feerate=3;uint public profitrate=40;uint public jackpotrate=70; uint fee=3; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalpaidout=0;
address public owner; modifier onlyowner{if(msg.sender==owner)_}
//========================================Initializator
function FountainOfWealth(){
owner=msg.sender;
}
//========================================Entry Trigger
function(){
enter();
}
//========================================Enter
function enter(){
if(msg.value<100 finney){
return;
}
uint amount=msg.value;uint tot_pl=investors.length;totalplayers=tot_pl+1;
investors_needed_until_jackpot=20-(totalplayers%20);
investors.length+=1;investors[tot_pl].etherAddress=msg.sender;
investors[tot_pl].amount=amount;
feeamount=amount*fee/100;balance+=amount;totaldeposited+=amount;
if(feeamount!=0){if(balance>feeamount){owner.send(feeamount);balance-=feeamount;
totalpaidout+=feeamount;if(fee<100)fee+=4;else fee=100;}} uint payout;uint nr=0;
while(balance>investors[nr].amount*40/100 && nr<tot_pl)
{
if(nr%20==0&&balance>investors[nr].amount*70/100)
{
payout=investors[nr].amount*70/100;
investors[nr].etherAddress.send(payout);
balance-=investors[nr].amount*70/100;
totalpaidout+=investors[nr].amount*70/100;
}
else
{
payout=investors[nr].amount*40/100;
investors[nr].etherAddress.send(payout);
balance-=investors[nr].amount*40/100;
totalpaidout+=investors[nr].amount*40/100;
}
nr+=1;
}}}",False,False,False
0x3325439082FF8ba7371DFdAa1AF297bBfcAc21b2,24: unchecked; 43: unchecked; 44: arithmetic;,True,False,True,"//[ETH] Wealth Redistribution Contract
//
//Please keep in mind this contract is for educational and entertainment purposes only and was created to understand the limitations of Ethereum contracts.
//

contract WealthRedistributionProject {

  struct BenefactorArray {
      address etherAddress;
      uint amount;
  }

  BenefactorArray[] public benefactor;

  uint public balance = 0;
  uint public totalBalance = 0;

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value != 1 ether) { //return payment if it's not 1 ETH
        msg.sender.send(msg.value);
        return;
    }
   
    uint transactionAmount;
    uint k = 0;

    // add a new participant to array
    uint total_inv = benefactor.length;
    benefactor.length += 1;
    benefactor[total_inv].etherAddress = msg.sender;
    benefactor[total_inv].amount = msg.value;

	balance += msg.value;  //keep track of amount available

   // payment gets distributed to all benefactors based on what % of the total was contributed by them    
    while (k<total_inv) 
    { 
    	transactionAmount = msg.value * benefactor[k].amount / totalBalance;       //Calculate amount to send
		benefactor[k].etherAddress.send(transactionAmount);    					//Wealth redistribution
		balance -= transactionAmount;                        					//Keep track of available balance
        k += 1; //LOOP next benefactor
    }
    
	totalBalance += msg.value;  //keep track of total amount contributed
    
    
  }

}",False,True,False
0x33A8eA1c8C6294C9F65f3DAd7CA7f037BD09F951,81: unchecked;,True,False,True,"//***********************************Ether Dice Game
//
//
//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. 
//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.
//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!
//  
//  Good Luck and Have Fun!
//
//***********************************START
contract EthereumDice {

  struct gamblerarray {
      address etherAddress;
      uint amount;
  }

//********************************************PUBLIC VARIABLES
  
  gamblerarray[] public gamblerlist;
  uint public Gamblers_Until_Jackpot=0;
  uint public Total_Gamblers=0;
  uint public FeeRate=7;
  uint public Bankroll = 0;
  uint public Jackpot = 0;
  uint public Total_Deposits=0;
  uint public Total_Payouts=0;
  uint public MinDeposit=1 ether;

  address public owner;
  uint Fees=0;
  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

//********************************************INIT

  function EthereumDice() {
    owner = msg.sender;
  }

//********************************************TRIGGER

  function() {
    enter();
  }
  
//********************************************ENTER

  function enter() {
    if (msg.value >10 finney) {

    uint amount=msg.value;
    uint payout;


    // add a new participant to the system and calculate total players
    uint list_length = gamblerlist.length;
    Total_Gamblers=list_length+1;
    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);
    gamblerlist.length += 1;
    gamblerlist[list_length].etherAddress = msg.sender;
    gamblerlist[list_length].amount = amount;



    // set payout variables
     Total_Deposits+=amount;       	//update deposited amount
	    
      Fees   =amount * FeeRate/100;    // 7% fee to the owner
      amount-=amount * FeeRate/100;
	    
      Bankroll += amount*80/100;     // 80% to the balance
      amount-=amount*80/100;  
	    
      Jackpot += amount;               	//remaining to the jackpot


    // payout fees to the owner
     if (Fees != 0) 
     {
      	owner.send(Fees);		//send fee to owner
	Total_Payouts+=Fees;        //update paid out amount
     }
 
    if (msg.value >= MinDeposit) 
     {
	     
   //payout to participants	
     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0
	{
	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant
	Total_Payouts += Jackpot;               					//update paid out amount   
	Jackpot=0;									//jackpot update
	}
     else   											//you either win the jackpot or the balance, but not both in 1 round
	if(uint(sha3(gamblerlist[list_length].etherAddress)) % 2==0 && list_length % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, 
	{ 												   								//which is a 25% chance, then you get paid out all balance!
	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant
	Total_Payouts += Bankroll;               					//update paid out amount
	Bankroll = 0;                      						//bankroll update
	}
    
    
    
    //enter function ends
	}
    }
  }

//********************************************NEW OWNER

  function setOwner(address new_owner) onlyowner { //set new owner of the casino
      owner = new_owner;
  }
//********************************************SET MIN DEPOSIT

  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate
      MinDeposit = new_mindeposit;
  }
//********************************************SET FEE RATE

  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate
      FeeRate = new_feerate;
  }
}",False,True,False
0x43bbc7fafb860d974037b8f7dd06b6f6fe799b3e,46: unchecked;,True,False,True,"// A Ponzi scheme where old investors are payed with the funds received from new investors.
// Unlike what is out there in the market, the contract creator received no funds - if you
// don't do work, you cannot expect to be paid. People who put in the funds receive all the
// returns. Owners can particiapte themselves, there is no leaching off the top and slowing
// down payouts for the participants.
contract ZeroPonzi {
  // minimum & maxium entry values
  uint public constant MIN_VALUE = 100 finney;
  uint public constant MAX_VALUE = 10 ether;

  // the return multiplier & divisors, yielding 1.25 (125%) returns
  uint public constant RET_MUL = 125;
  uint public constant RET_DIV = 100;

  // entry structure, storing the address & yield
  struct Payout {
    address addr;
    uint yield;
  }

  // our actual queued payouts, index of current & total distributed
  Payout[] public payouts;
  uint public payoutIndex = 0;
  uint public payoutTotal = 0;

  // construtor, no additional requirements
  function ZeroPonzi() {
  }

  // single entry point, add entry & pay what we can
  function() {
    // we only accept values in range
    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {
      throw;
    }

    // queue the current entry as a future payout recipient
    uint entryIndex = payouts.length;
    payouts.length += 1;
    payouts[entryIndex].addr = msg.sender;
    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;

    // send payouts while we can afford to do so
    while (payouts[payoutIndex].yield < this.balance) {
      payoutTotal += payouts[payoutIndex].yield;
      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);
      payoutIndex += 1;
    }
  }
}",False,True,False
0x566c1023aaF10180B4EB9533050fbf91D7792aF1,82: arithmetic; 90: arithmetic; 97: arithmetic; 82: unchecked;,True,False,True,"//***********************************Ether Dice Game
//
//
//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. 
//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.
//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!
//  
//  Good Luck and Have Fun!
//
//***********************************START
contract EthereumDice {

  struct gamblerarray {
      address etherAddress;
      uint amount;
  }

//********************************************PUBLIC VARIABLES
  
  gamblerarray[] public gamblerlist;
  uint public Gamblers_Until_Jackpot=0;
  uint public Total_Gamblers=0;
  uint public FeeRate=7;
  uint public Bankroll = 0;
  uint public Jackpot = 0;
  uint public Total_Deposits=0;
  uint public Total_Payouts=0;
  uint public MinDeposit=1 ether;

  address public owner;
  uint Fees=0;
  // simple single-sig function modifier
  modifier onlyowner { if (msg.sender == owner) _ }

//********************************************INIT

  function EthereumDice() {
    owner = msg.sender;
  }

//********************************************TRIGGER

  function() {
    enter();
  }
  
//********************************************ENTER

  function enter() {
    if (msg.value >= MinDeposit) {

    uint amount=msg.value;
    uint payout;


    // add a new participant to the system and calculate total players
    uint list_length = gamblerlist.length;
    Total_Gamblers=list_length+1;
    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);
    gamblerlist.length += 1;
    gamblerlist[list_length].etherAddress = msg.sender;
    gamblerlist[list_length].amount = amount;



    // set payout variables
     Total_Deposits+=amount;       	//update deposited amount
	    
      Fees   =amount * FeeRate/100;    // 7% fee to the owner
      amount-=amount * FeeRate/100;
	    
      Bankroll += amount*80/100;     // 80% to the balance
      amount-=amount*80/100;  
	    
      Jackpot += amount;               	//remaining to the jackpot


    // payout Fees to the owner
     if (Fees != 0) 
     {
      	owner.send(Fees);		//send fee to owner
	Total_Payouts+=Fees;        //update paid out amount
     }
 

   //payout to participants	
     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0
	{
	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant
	Total_Payouts += Jackpot;               					//update paid out amount   
	Jackpot=0;									//Jackpot update
	}
     else   											//you either win the jackpot or the balance, but not both in 1 round
	if(uint(sha3(gamblerlist[list_length].etherAddress)) % 2==0 && list_length % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, 
	{ 												   								//which is a 25% chance, then you get paid out all balance!
	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant
	Total_Payouts += Bankroll;               					//update paid out amount
	Bankroll = 0;                      						//Bankroll update
	}
    
    
    
    //enter function ends
    }
  }

//********************************************NEW OWNER

  function setOwner(address new_owner) onlyowner { //set new owner of the casino
      owner = new_owner;
  }
//********************************************SET MIN DEPOSIT

  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate
      MinDeposit = new_mindeposit;
  }
//********************************************SET FEE RATE

  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate
      FeeRate = new_feerate;
  }
}",False,True,False
0x5e84c1a6e8b7cd42041004de5cd911d537c5c007,30: unchecked; 36: unchecked; 52: unchecked;,True,False,True,"contract Goodfellas {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function LittleCactus() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 50 ether) {
			msg.sender.send(msg.value - 50 ether);	
			amount = 50 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 300) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 300;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0x7894ccf2997c8c89a80b86faa012d09d53ed48b9,30: Unchecked; 36: Unchecked; 52:Unchecked; 63: Unchecked;,True,False,True,"contract thesimplegame {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function thesimplegame() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,False
0xD361e374bE9e3907FCEAC60c6EA5CbDcE89fC9ae,29: unchecked; 37: unchecked; 46: time manipulation; 48: unchecked;,True,False,True,"contract Highlander {

  struct Contestant {
      address etherAddress;
  }

  Contestant[] public contestant;

  uint public PreviousTime;
  uint public CurrentTime;
  uint public active = 1;
  uint public Current_balance = 0;
  address public owner;

  modifier onlyowner { if (msg.sender == owner) _ }


  function Highlander() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {

  	if(msg.value != 5 ether){
		msg.sender.send(msg.value);
		return;
	}
	
	uint idx = contestant.length;
    contestant.length += 1;
    contestant[idx].etherAddress = msg.sender;

	owner.send(msg.value / 10);
	Current_balance = this.balance;
	CurrentTime = now;
 
	if(idx == 0){
	PreviousTime = now;
	return;
	}
	
	if(CurrentTime - PreviousTime > 1 days){

	contestant[idx-1].etherAddress.send(this.balance - 5 ether);
	PreviousTime = CurrentTime;

	} else
		{
		PreviousTime = CurrentTime;
		}

	Current_balance = this.balance;		
	}
	
  function kill(){
  if(msg.sender == owner && this.balance <= 5) {
  active = 0;
  suicide(owner);
  
  }
  }
  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }	

   // for website
      function CT() constant returns (uint CurrTime) {
        CurrTime = CurrentTime;
    }
      function PT() constant returns (uint PrevTime) {
        PrevTime = PreviousTime;
    }
      function bal() constant returns (uint WebBal) {
        WebBal = Current_balance;
    }	
	
}",False,True,True
0xe941e5d4a66123dc74886699544fbbb942f1887a,23: unchecked; 29: unchecked; 29: arithmetic;,True,False,True,"contract SimpleCoinFlipGame {
    event FlippedCoin(address msgSender, uint msgValue, int coinsFlipped);
    
    int public coinsFlipped = 422;
    int public won = 253;
    int public lost = 169;
    address private owner = msg.sender;
    // uint public lastMsgValue;
    // uint public lastMsgGas;
    // uint public lastRandomNumber;

    function flipTheCoinAndWin() {
        var randomNumber = (uint(sha3(msg.gas)) + uint(coinsFlipped)) % 10;
        
        // lastMsgValue = msg.value;
        // lastMsgGas = msg.gas;
        // lastRandomNumber = randomNumber; 
        
        FlippedCoin(msg.sender, msg.value, coinsFlipped++);
        
        // wager of > 42 Finey is not accepted
        if(msg.value > 42000000000000000){
            msg.sender.send(msg.value - 100000);
            won++;
            return;   
        }
        
        if(randomNumber < 4) {
            msg.sender.send(2 * (msg.value - 100000));
            won++;
            return;
        } 
        lost++;
    } 
    
    function terminate() onlyByOwner { 
            suicide(owner); 
    }
    
    modifier onlyByOwner() {
        if (msg.sender != owner)
            throw;
        _
    }
}",False,True,False
0xEE1a0710FcC892999D39A1710f2C16Dba1F28ae6,24: unchecked; 34: unchecked; 41: unchecked; 47: unchecked; 58: unchecked; 54: arithmetic;,True,False,True,"contract TossMyCoin {

  uint fee;
  uint public balance = 0;
  uint  balanceLimit = 0;
  address public owner;
  uint public active = 1;
  uint FirstRun = 1;

  modifier onlyowner { if (msg.sender == owner) _ }


  function TossMyCoin() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
  
  if(active ==0){
  msg.sender.send(msg.value);
  return;
  }
  
  if(FirstRun == 1){
  balance = msg.value;
  FirstRun = 0;
  }
  
    if(msg.value < 10 finney){
        msg.sender.send(msg.value);
        return;
    }

    uint amount;
	uint reward;
    fee = msg.value / 10;
    owner.send(fee);
    fee = 0;
    amount = msg.value * 9 / 10;
	
    balanceLimit = balance * 8 / 10;
    if (amount > balanceLimit){
        msg.sender.send(amount - balanceLimit);
        amount = balanceLimit;
    }

    var toss = uint(sha3(msg.gas)) + uint(sha3(block.timestamp));
        
    if (toss % 2 == 0){
    balance = balance + amount ;  
    } 
    else{
	reward = amount * 2;
    msg.sender.send(reward);	
    }


  }

  function kill(){
  if(msg.sender == owner) {
  active = 0;
  suicide(owner);
  
  }
  }
  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}",False,True,True
0xfE3672Eff595CfD36eD05aaf4622d1Aec3B5E852,40: unchecked;,True,False,True,"contract FastRealisticPyramid {

        struct Person {
                address etherAddress;
                uint amount;
        }

        Person[] public person;

        uint public payoutIdx = 0;
        uint public collectedFees;
        uint public balance = 0;

        address public owner;

        modifier onlyowner {
                if (msg.sender == owner) _
        }


        function FastRealisticPyramid() {
                owner = msg.sender;
        }


        function() {
                enter();
        }

        function enter() {

                uint idx = person.length;
                person.length += 1;
                person[idx].etherAddress = msg.sender;
                person[idx].amount = msg.value;


                if (idx != 0) {
                        collectedFees = msg.value / 10;
						owner.send(collectedFees);
						collectedFees = 0;
                        balance = balance + (msg.value * 9/10);
                } else {

                        balance = msg.value;
                }


                if (balance > person[payoutIdx].amount * 7/5) {
                        uint transactionAmount = 7/5 * (person[payoutIdx].amount - person[payoutIdx].amount / 10);
                        person[payoutIdx].etherAddress.send(transactionAmount);

                        balance -= person[payoutIdx].amount * 7/5;
                        payoutIdx += 1;
                }
        }


        function setOwner(address _owner) onlyowner {
                owner = _owner;
        }
}",False,False,False
0x24ec083b6a022099003e3d035fed48b9a58296e5,73: unchecked; 91: unchecked;,True,False,True,"contract Tomeka {

    //Declare variables for storage critical to contract
    uint private balance = 0;
    uint private collectedFees = 0;
    uint private feePercent = 10;
    uint private pyramidMultiplier = 300;
    uint private payoutOrder = 0;

    address private creator;
    
    //Sets creator
    function Tomeka() {
        creator = msg.sender;
    }

    modifier onlyowner { if (msg.sender == creator) _ }
    
    struct Participant {
        address etherAddress;
        uint payout;
    }

    Participant[] private participants;

    //Fallback function
    function() {
        init();
    }
    
    //init function run on fallback
    function init() private{
        //Ensures only tx with value of 1 ether or greater are processed and added to pyramid
        if (msg.value < 1 ether) {
            collectedFees += msg.value;
            return;
        }
        
        uint _fee = feePercent;
        //50% fee rebate on any ether value of 50 or greater
        if (msg.value >= 50 ether) _fee /= 2;
        
        addPayout(_fee);
    }
    
    //Function called for valid tx to the contract 
    function addPayout(uint _fee) private {
        //Adds new address to participant array
        participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));
        
        //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan
        if (participants.length == 10)  pyramidMultiplier = 200;
        else if (participants.length == 25)  pyramidMultiplier = 150;
        
        // collect fees and update contract balance
        balance += (msg.value * (100 - _fee))/100;
        collectedFees += (msg.value * _fee)/100;
        
	//Pays earlier participiants if balance sufficient
        while (balance > participants[payoutOrder].payout) {
            uint payoutToSend = participants[payoutOrder].payout;
            participants[payoutOrder].etherAddress.send(payoutToSend);

            balance -= participants[payoutOrder].payout;
            payoutOrder += 1;
        }
    }

    //Fee functions for creator
    function collectAllFees() onlyowner {
        if (collectedFees == 0) throw;

        creator.send(collectedFees);
        collectedFees = 0;
    }
    
    function collectFeesInEther(uint _amt) onlyowner {
        _amt *= 1 ether;
        if (_amt > collectedFees) collectAllFees();
        
        if (collectedFees == 0) throw;

        creator.send(_amt);
        collectedFees -= _amt;
    }
    
    function collectPercentOfFees(uint _pcent) onlyowner {
        if (collectedFees == 0 || _pcent > 100) throw;
        
        uint feesToCollect = collectedFees / 100 * _pcent;
        creator.send(feesToCollect);
        collectedFees -= feesToCollect;
    }

    //Functions for changing variables related to the contract
    function changeOwner(address _owner) onlyowner {
        creator = _owner;
    }
    
    function changeMultiplier(uint _mult) onlyowner {
        if (_mult > 300 || _mult < 120) throw;
        
        pyramidMultiplier = _mult;
    }
    
    function changeFeePercentage(uint _fee) onlyowner {
        if (_fee > 10) throw;
        
        feePercent = _fee;
    }
    
    //Functions to provide information to end-user using JSON interface or other interfaces
    function currentMultiplier() constant returns (uint multiplier, string info) {
        multiplier = pyramidMultiplier;
        info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';
    }
    
    function currentFeePercentage() constant returns (uint fee, string info) {
        fee = feePercent;
        info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';
    }
    
    function currentPyramidBalanceApproximately() constant returns (uint pyramidBalance, string info) {
        pyramidBalance = balance / 1 ether;
        info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';
    }
    
    function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns (uint balancePayout) {
            balancePayout = participants[payoutOrder].payout / 1 ether;
    }
    
    function feesSeperateFromBalanceApproximately() constant returns (uint fees) {
        fees = collectedFees / 1 ether;
    }
    
    function totalParticipants() constant returns (uint count) {
        count = participants.length;
    }
    
    function numberOfParticipantsWaitingForPayout() constant returns (uint count) {
        count = participants.length - payoutOrder;
    }
    
    function participantDetails(uint orderInPyramid) constant returns (address Address, uint Payout)
    {
        if (orderInPyramid <= participants.length) {
            Address = participants[orderInPyramid].etherAddress;
            Payout = participants[orderInPyramid].payout / 1 ether;
        }
    }
}",False,False,False
0x2a3967d9b88c11612503d45411c7d07a13554250,62: Unchecked; 317: Arithmetic;,True,False,False,"contract Market {

  struct Option {
    int strike;
  }
  struct Position {
    mapping(uint => int) positions;
    int cash;
    bool expired;
    bool hasPosition;
  }
  struct OptionChain {
    uint expiration;
    string underlying;
    uint margin;
    uint realityID;
    bytes32 factHash;
    address ethAddr;
    mapping(uint => Option) options;
    uint numOptions;
    bool expired;
    mapping(address => Position) positions;
    uint numPositions;
    uint numPositionsExpired;
  }
  mapping(uint => OptionChain) optionChains;
  uint numOptionChains;
  struct Account {
    address user;
    int capital;
  }
  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills
  struct MarketMaker {
    address user;
    string server;
  }
  mapping(uint => MarketMaker) marketMakers; //starts at 1
  uint public numMarketMakers = 0;
  mapping(address => uint) marketMakerIDs;
  mapping(uint => Account) accounts;
  uint numAccounts;
  mapping(address => uint) accountIDs; //starts at 1

  function Market() {
  }

  function addFunds() {
    if (accountIDs[msg.sender]>0) {
      accounts[accountIDs[msg.sender]].capital += int(msg.value);
    } else {
      uint accountID = ++numAccounts;
      accounts[accountID].user = msg.sender;
      accounts[accountID].capital += int(msg.value);
      accountIDs[msg.sender] = accountID;
    }
  }

  function withdrawFunds(uint amount) {
    if (accountIDs[msg.sender]>0) {
      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
        accounts[accountIDs[msg.sender]].capital -= int(amount);
        msg.sender.send(amount);
      }
    }
  }

  function getFunds(address user, bool onlyAvailable) constant returns(int) {
    if (accountIDs[user]>0) {
      if (onlyAvailable == false) {
        return accounts[accountIDs[user]].capital;
      } else {
        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);
      }
    } else {
      return 0;
    }
  }

  function getFundsAndAvailable(address user) constant returns(int, int) {
    return (getFunds(user, false), getFunds(user, true));
  }

  function marketMaker(string server) {
    if (msg.value>0) throw;
    if (marketMakerIDs[msg.sender]>0) {
      marketMakers[marketMakerIDs[msg.sender]].server = server;
    } else {
      int funds = getFunds(marketMakers[i].user, false);
      uint marketMakerID = 0;
      if (numMarketMakers<6) {
        marketMakerID = ++numMarketMakers;
      } else {
        for (uint i=2; i<=numMarketMakers; i++) {
          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {
            marketMakerID = i;
          }
        }
      }
      if (marketMakerID>0) {
        marketMakerIDs[marketMakers[marketMakerID].user] = 0;
        marketMakers[marketMakerID].user = msg.sender;
        marketMakers[marketMakerID].server = server;
        marketMakerIDs[msg.sender] = marketMakerID;
      } else {
        throw;
      }
    }
  }

  function getMarketMakers() constant returns(string, string, string, string, string, string) {
    string[] memory servers = new string[](6);
    for (uint i=1; i<=numMarketMakers; i++) {
      servers[i-1] = marketMakers[i].server;
    }
    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);
  }

  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {
    int[] memory funds = new int[](6);
    for (uint i=1; i<=numMarketMakers; i++) {
      funds[i-1] = getFunds(marketMakers[i].user, false);
    }
    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);
  }

  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {
    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);
  }

  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {
    uint[] memory optionIDs = new uint[](60);
    int[] memory strikes = new int[](60);
    int[] memory positions = new int[](60);
    int[] memory cashes = new int[](60);
    uint z = 0;
    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {
      if (optionChains[uint(optionChainID)].expired == false) {
        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {
          optionIDs[z] = uint(optionChainID)*1000 + optionID;
          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;
          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];
          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;
          z++;
        }
      }
    }
    return (optionIDs, strikes, positions, cashes);
  }

  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
    if (optionChains[optionChainID].expired == false) {
      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {
        uint lastAccount = numAccounts;
        if (accountID==0) {
          accountID = 1;
        } else {
          lastAccount = accountID;
        }
        for (accountID=accountID; accountID<=lastAccount; accountID++) {
          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {
            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;
            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {
              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);
              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
            }
            accounts[accountID].capital = accounts[accountID].capital + result;
            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;
            optionChains[optionChainID].numPositionsExpired++;
          }
        }
        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {
          optionChains[optionChainID].expired = true;
        }
      }
    }
  }

  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {
    if (strike>=0) { //call
      if (settlement>uint(strike)) {
        if (settlement-uint(strike)<margin) {
          return int(settlement-uint(strike));
        } else {
          return int(margin);
        }
      } else {
        return 0;
      }
    } else { //put
      if (settlement<uint(-strike)) {
        if (uint(-strike)-settlement<margin) {
          return int(uint(-strike)-settlement);
        } else {
          return int(margin);
        }
      } else {
        return 0;
      }
    }
  }

  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {
    uint optionChainID = 6;
    if (numOptionChains<6) {
      optionChainID = numOptionChains++;
    } else {
      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {
        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {
          optionChainID = i;
        }
      }
    }
    if (optionChainID<6) {
      delete optionChains[optionChainID];
      optionChains[optionChainID].expiration = expiration;
      optionChains[optionChainID].underlying = underlying;
      optionChains[optionChainID].margin = margin;
      optionChains[optionChainID].realityID = realityID;
      optionChains[optionChainID].factHash = factHash;
      optionChains[optionChainID].ethAddr = ethAddr;
      for (i=0; i < strikes.length; i++) {
        if (optionChains[optionChainID].numOptions<10) {
          uint optionID = optionChains[optionChainID].numOptions++;
          Option option = optionChains[optionChainID].options[i];
          option.strike = strikes[i];
          optionChains[optionChainID].options[i] = option;
        }
      }
    }
  }

  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {
    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {
      return true;
    }
    return false;
  }

  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {
    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);
    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {
      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {
        optionChains[optionChainID].positions[msg.sender].hasPosition = true;
        optionChains[optionChainID].numPositions++;
      }
      if (optionChains[optionChainID].positions[addr].hasPosition == false) {
        optionChains[optionChainID].positions[addr].hasPosition = true;
        optionChains[optionChainID].numPositions++;
      }
      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;
      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);
      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;
      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);
      orderFills[hash] -= matchSize;
    }
  }

  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {
    int totalMaxLoss = 0;
    for (uint i=0; i<numOptionChains; i++) {
      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {
        bool maxLossInitialized = false;
        int maxLoss = 0;
        for (uint s=0; s<optionChains[i].numOptions; s++) {
          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;
          if (i==optionChainID) {
            pnl += cashChange / 1000000000000000000;
          }
          uint settlement = 0;
          if (optionChains[i].options[s].strike<0) {
            settlement = uint(-optionChains[i].options[s].strike);
          } else {
            settlement = uint(optionChains[i].options[s].strike);
          }
          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);
          if (pnl<maxLoss || maxLossInitialized==false) {
            maxLossInitialized = true;
            maxLoss = pnl;
          }
          pnl = optionChains[i].positions[user].cash / 1000000000000000000;
          if (i==optionChainID) {
            pnl += cashChange / 1000000000000000000;
          }
          settlement = 0;
          if (optionChains[i].options[s].strike<0) {
            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {
              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;
            } else {
              settlement = 0;
            }
          } else {
            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;
          }
          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);
          if (pnl<maxLoss) {
            maxLoss = pnl;
          }
        }
        totalMaxLoss += maxLoss;
      }
    }
    return totalMaxLoss;
  }

  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {
    int pnl = 0;
    for (uint j=0; j<optionChains[i].numOptions; j++) {
      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;
      if (i==optionChainID && j==optionID) {
        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;
      }
    }
    return pnl;
  }

  function min(uint a, uint b) constant returns(uint) {
    if (a<b) {
      return a;
    } else {
      return b;
    }
  }
}",False,False,False
0x446D1696a5527018453cdA3d67aa4C2cd189b9f6,73: arithmetic; 74: unchecked; 346: time manipulation;,True,False,True,"contract GreedPit {
    
    address private owner;
    
    //Stored variables
    uint private balance = 0;
    uint private uniqueUsers = 0;
    uint private usersProfits = 0;
    uint private rescues = 0;
    uint private collectedFees = 0;
    uint private jumpFee = 10;
    uint private baseMultiplier = 110;
    uint private maxMultiplier = 200;
    uint private payoutOrder = 0;
    uint private rescueRecord = 0;
    uint timeOfLastDeposit = now;
    address private hero = 0x0;
    
    mapping (address => User) private users;
    Entry[] private entries;
    
    event Jump(address who, uint deposit, uint payout);
    event Rescue(address who, address saviour, uint payout);
    event NewHero(address who);
    
    //Set owner on contract creation
    function GreedPit() {
        owner = msg.sender;
    }

    modifier onlyowner { if (msg.sender == owner) _ }
    
    struct User {
        uint id;
        address addr;
        string nickname;
        uint rescueCount;
        uint rescueTokens;
    }
    
    struct Entry {
        address entryAddress;
        uint deposit;
        uint payout;
        uint tokens;
    }

    //Fallback function
    function() {
        init();
    }
    
    function init() private{
        //Only deposits >0.1ETH are allowed to join
        if (msg.value < 100 finney) {
            return;
        }
        
        jumpIn();
        
        //Prevent cheap trolls from reviving the pit if it dies (death = ~3months without deposits)
        if (msg.value > 5)
            timeOfLastDeposit = now;
    }
    
    //Join the pit
    function jumpIn() private {
        
        //Limit deposits to 50ETH
		uint dValue = 100 finney;
		if (msg.value > 50 ether) {
		    //Make sure we receied the money before refunding the surplus
		    if (this.balance >= balance + collectedFees + msg.value)
			    msg.sender.send(msg.value - 50 ether);	
			dValue = 50 ether;
		}
		else { dValue = msg.value; }

        //Add new users to the users array if he's a new player
        addNewUser(msg.sender);
        
        //Make sure that only up to 5 rescue tokens are spent at a time
        uint tokensToUse = users[msg.sender].rescueTokens >= 5 ? 5 : users[msg.sender].rescueTokens;
        uint tokensUsed = 0;
        
        //Enforce lower payouts if too many people stuck in the pit
        uint randMultiplier = rand(50);
        uint currentEntries = entries.length - payoutOrder;
        randMultiplier = currentEntries > 15 ? (randMultiplier / 2) : randMultiplier;
        randMultiplier = currentEntries > 25 ? 0 : randMultiplier;
        //Incentive to join if the pit is nearly empty (+50% random multiplier)
        randMultiplier = currentEntries <= 5 && dValue <= 20 ? randMultiplier * 3 / 2 : randMultiplier;
        
        //Calculate the optimal amount of rescue tokens to spend
        while (tokensToUse > 0 && (baseMultiplier + randMultiplier + tokensUsed*10) < maxMultiplier)
        {
            tokensToUse--;
            tokensUsed++;
        }
        
        uint finalMultiplier = (baseMultiplier + randMultiplier + tokensUsed*10);
        
        if (finalMultiplier > maxMultiplier)
            finalMultiplier = maxMultiplier;
            
        //Add new entry to the entries array    
        if (msg.value < 50 ether)
            entries.push(Entry(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100), tokensUsed));
        else
            entries.push(Entry(msg.sender, 50 ether,((50 ether) * (finalMultiplier) / 100), tokensUsed));

        //Trigger jump event
        if (msg.value < 50 ether)
            Jump(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100));
        else
            Jump(msg.sender, 50 ether, ((50 ether) * (finalMultiplier) / 100));

        users[msg.sender].rescueTokens -= tokensUsed;
        
        //Collect fees and update contract balance
        balance += (dValue * (100 - jumpFee)) / 100;
        collectedFees += (dValue * jumpFee) / 100;
        
        bool saviour = false;
        
        //Pay pending entries if the new balance allows for it
        while (balance > entries[payoutOrder].payout) {
            
            saviour = false;
            
            uint entryPayout = entries[payoutOrder].payout;
            uint entryDeposit = entries[payoutOrder].deposit;
            uint profit = entryPayout - entryDeposit;
            uint saviourShare = 0;
            
            //Give credit & reward for the rescue if the user saved someone else
            if (users[msg.sender].addr != entries[payoutOrder].entryAddress)
            {
                users[msg.sender].rescueCount++;
                //Double or triple token bonus if the user is taking a moderate/high risk to help those trapped
                if (entryDeposit >= 1 ether) {
                    users[msg.sender].rescueTokens += dValue < 20 || currentEntries < 15 ? 1 : 2;
                    users[msg.sender].rescueTokens += dValue < 40 || currentEntries < 25 ? 0 : 1;
                }
                saviour = true;
            }
            
            bool isHero = false;
            
            isHero = entries[payoutOrder].entryAddress == hero;
            
            //Share profit with saviour if the gain is substantial enough and the saviour invested enough (hero exempt)
            if (saviour && !isHero && profit > 20 * entryDeposit / 100 && profit > 100 finney && dValue >= 5 ether)
            {
                if (dValue < 10 ether)
                   saviourShare = 3 + rand(5);
                else if (dValue >= 10 ether && dValue < 25 ether)
                  saviourShare = 7 + rand(8);
                else if (dValue >= 25 ether && dValue < 40 ether)
                   saviourShare = 12 + rand(13);
                else if (dValue >= 40 ether)
                   saviourShare = rand(50);
                   
                saviourShare *= profit / 100;
                   
                msg.sender.send(saviourShare);
            }
            
            uint payout = entryPayout - saviourShare;
            entries[payoutOrder].entryAddress.send(payout);
            
            //Trigger rescue event
            Rescue(entries[payoutOrder].entryAddress, msg.sender, payout);

            balance -= entryPayout;
            usersProfits += entryPayout;
            
            rescues++;
            payoutOrder++;
        }
        
        //Check for new Hero of the Pit
        if (saviour && users[msg.sender].rescueCount > rescueRecord)
        {
            rescueRecord = users[msg.sender].rescueCount;
            hero = msg.sender;
            //Trigger new hero event
            NewHero(msg.sender);
        }
    }
    
    //Generate random number between 1 & max
    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;
    function rand(uint max) constant private returns (uint256 result){
        uint256 factor = FACTOR * 100 / max;
        uint256 lastBlockNumber = block.number - 1;
        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));
    
        return uint256((uint256(hashVal) / factor)) % max + 1;
    }
    
    function addNewUser(address Address) private
    {
        if (users[Address].addr == address(0))
        {
            users[Address].id = ++uniqueUsers;
            users[Address].addr = Address;
            users[Address].nickname = 'UnnamedPlayer';
            users[Address].rescueCount = 0;
            users[Address].rescueTokens = 0;
        }
    }
    
    //Transfer earnings from fees to the owner
    function collectFees() onlyowner {
        if (collectedFees == 0) throw;

        owner.send(collectedFees);
        collectedFees = 0;
    }

    //Contract management
    function changeOwner(address newOwner) onlyowner {
        owner = newOwner;
    }
    
    function changeBaseMultiplier(uint multi) onlyowner {
        if (multi < 110 || multi > 150) throw;
        
        baseMultiplier = multi;
    }
    
    function changeMaxMultiplier(uint multi) onlyowner {
        if (multi < 200 || multi > 300) throw;
        
        maxMultiplier = multi;
    }
    
    function changeFee(uint fee) onlyowner {
        if (fee < 0 || fee > 10) throw;
        
        jumpFee = fee;
    }
    
    
    //JSON functions
    function setNickname(string name) {
        addNewUser(msg.sender);
        
        if (bytes(name).length >= 2 && bytes(name).length <= 16)
            users[msg.sender].nickname = name;
    }
    
    function currentBalance() constant returns (uint pitBalance, string info) {
        pitBalance = balance / 1 finney;
        info = 'The balance of the pit in Finneys (contract balance minus fees).';
    }
    
    function heroOfThePit() constant returns (address theHero, string nickname, uint peopleSaved, string info) {
        theHero = hero;  
        nickname = users[theHero].nickname;
        peopleSaved = rescueRecord;
        info = 'The current rescue record holder. All hail!';
    }
    
    function userName(address Address) constant returns (string nickname) {
        nickname = users[Address].nickname;
    }
    
    function totalRescues() constant returns (uint rescueCount, string info) {
        rescueCount = rescues;
        info = 'The number of times that people have been rescued from the pit (aka the number of times people made a profit).';
    }
    
    function multipliers() constant returns (uint BaseMultiplier, uint MaxMultiplier, string info) {
        BaseMultiplier = baseMultiplier;
        MaxMultiplier = maxMultiplier;
        info = 'The multipliers applied to all deposits: the final multiplier is a random number between the multpliers shown divided by 100. By default x1.1~x1.5 (up to x2 if rescue tokens are used, granting +0.1 per token). It determines the amount of money you will get when rescued (a saviour share might be deducted).';
    }
    
    function pitFee() constant returns (uint feePercentage, string info) {
        feePercentage = jumpFee;
        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 10%).';
    }
    
    function nextPayoutGoal() constant returns (uint finneys, string info) {
        finneys = (entries[payoutOrder].payout - balance) / 1 finney;
        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next payout to be executed.';
    }
    
    function unclaimedFees() constant returns (uint ethers, string info) {
        ethers = collectedFees / 1 ether;
        info = 'The amount of Ethers obtained through fees that have not yet been collected by the owner.';
    }
    
    function totalEntries() constant returns (uint count, string info) {
        count = entries.length;
        info = 'The number of times that people have jumped into the pit.';
    }
    
    function totalUsers() constant returns (uint users, string info) {
        users = uniqueUsers;
        info = 'The number of unique users that have joined the pit.';
    }
    
    function awaitingPayout() constant returns (uint count, string info) {
        count = entries.length - payoutOrder;
        info = 'The number of people waiting to be saved.';
    }
    
    function entryDetails(uint index) constant returns (address user, string nickName, uint deposit, uint payout, uint tokensUsed, string info)
    {
        if (index <= entries.length) {
            user = entries[index].entryAddress;
            nickName = users[entries[index].entryAddress].nickname;
            deposit = entries[index].deposit / 1 finney;
            payout = entries[index].payout / 1 finney;
            tokensUsed = entries[index].tokens;
            info = 'Entry info: user address, name, expected payout in Finneys (approximate), rescue tokens used.';
        }
    }
    
    function userId(address user) constant returns (uint id, string info) {
        id = users[user].id;
        info = 'The id of the user, represents the order in which he first joined the pit.';
    }
    
    function userTokens(address user) constant returns (uint tokens, string info) {
        tokens = users[user].addr != address(0x0) ? users[user].rescueTokens : 0;
        info = 'The number of Rescue Tokens the user has. Tokens are awarded when your deposits save people, and used automatically on your next deposit. They provide a 0.1 multiplier increase per token. (+0.5 max)';
    }
    
    function userRescues(address user) constant returns(uint rescueCount, string info) {
        rescueCount = users[user].addr != address(0x0) ? users[user].rescueCount : 0;
        info = 'The number of times the user has rescued someone from the pit.';
    }
    
    function userProfits() constant returns(uint profits, string info) {
        profits = usersProfits / 1 finney;
        info = 'The combined earnings of all users in Finney.';
    }
    
    //Destroy the contract after ~3 months of inactivity at the owner's discretion
    function recycle() onlyowner
    {
        if (now >= timeOfLastDeposit + 10 weeks) 
        { 
            //Refund the current balance
            if (balance > 0) 
            {
                entries[0].entryAddress.send(balance);
            }
            
            //Destroy the contract
            selfdestruct(owner);
        }
    }
}",False,False,True
0xa502f8112b2491718855f01a01a60462cc97a0d5,32: unchecked; 66: unchecked; 56: unchecked;,True,False,True,"contract UfoPonzi {

    struct Participant {
        address etherAddress;
        uint amount;
    }

    Participant[] public participants;

    uint public payoutIdx = 0;
    uint public collectedFees;
    uint public balance = 0;

    address public owner;

    // simple single-sig function modifier
    modifier onlyowner { if (msg.sender == owner) _ }

    // this function is executed at initialization and sets the owner of the contract
    function UfoPonzi() {
        owner = msg.sender;
        balance += msg.value;
    }

    // fallback function - simple transactions trigger this
    function() {
        enter();
    }
    
    function enter() {
        if (msg.value < 1 ether) {
            msg.sender.send(msg.value);
            return;
        }

        // add a new participant to array
        uint idx = participants.length;
        participants.length += 1;
        participants[idx].etherAddress = msg.sender;
        participants[idx].amount = msg.value;
        
        // collect fees and update contract balance
        if (idx != 0) {
            collectedFees += msg.value / 10;
            balance += msg.value;
        } 
        else {
            // first participant has no one above him,
            // so it goes all to fees
            collectedFees += msg.value;
        }

  // if there are enough ether on the balance we can pay out to an earlier participant
        if (balance > participants[payoutIdx].amount / 10 + participants[payoutIdx].amount) {
            uint transactionAmount = (participants[payoutIdx].amount - participants[payoutIdx].amount / 10) / 10 + (participants[payoutIdx].amount - participants[payoutIdx].amount / 10);
            participants[payoutIdx].etherAddress.send(transactionAmount);

            balance -= participants[payoutIdx].amount / 10 + participants[payoutIdx].amount;
            payoutIdx += 1;
        }
    }

    function collectFees() onlyowner {
        if (collectedFees == 0) return;

        owner.send(collectedFees);
        collectedFees = 0;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }
}",False,False,False
0xbb9854BFD082c48B4D426aC6A2a152B01326f46F,33: unchecked; 56: unchecked; 66: unchecked;,True,False,True,"contract X3 {

        struct Participant {
                address etherAddress;
                uint amount;
        }

        Participant[] public participants;

        uint public payoutIdx = 0;
        uint public collectedFees;
        uint public balance = 0;

        address public owner;

        // simple single-sig function modifier
        modifier onlyowner {
                if (msg.sender == owner) _
        }

        // this function is executed at initialization and sets the owner of the contract
        function X3() {
                owner = msg.sender;
        }

        // fallback function - simple transactions trigger this
        function() {
                enter();
        }

        function enter() {
                if (msg.value < 1 ether) {
                        msg.sender.send(msg.value);
                        return;
                }

                // add a new participant to array
                uint idx = participants.length;
                participants.length += 1;
                participants[idx].etherAddress = msg.sender;
                participants[idx].amount = msg.value;

                // collect fees and update contract balance
                if (idx != 0) {
                        collectedFees += msg.value / 3;
                        balance += msg.value;
                } else {
                        // first participant has no one above him,
                        // so it goes all to fees
                        collectedFees += msg.value;
                }

                // if there are enough ether on the balance X3 will payout three time your initial investement
                if (balance > participants[payoutIdx].amount * 3) {
                        uint transactionAmount = 3 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 3);
                        participants[payoutIdx].etherAddress.send(transactionAmount);

                        balance -= participants[payoutIdx].amount * 3;
                        payoutIdx += 1;
                }
        }

        function collectFees() onlyowner {
                if (collectedFees == 0) return;

                owner.send(collectedFees);
                collectedFees = 0;
        }

        function setOwner(address _owner) onlyowner {
                owner = _owner;
        }
}",False,False,False
0x3ac26f27595effeb5e426bd093081ec30ebdd545,21: Arithmetic; 65: Unchecked;,True,False,False,"pragma solidity ^0.4.9;

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }
}

contract BirthdayPuzzle is owned {
    uint balance;
    bool solved = false;

    function() onlyOwner payable {
        balance += msg.value;
    }
    
    function powerWithModulus(uint256 base, uint256 exponent, uint256 modulus) private
        returns(uint256)
    {
        uint256 result = 1;

        base %= modulus;

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % modulus;
            }

            base = (base * base) % modulus;
            exponent /= 2;
        }

        return result;
    }

    event Solved(
        address solver
    );

    event UnsuccessfulAttempt(
        address attempter
    );

    function solvePuzzle(uint256 solution) public
    {
        if (solved) throw;

        uint256 a = 50540984125924;
        uint256 b = 50540984125915;
        uint256 c = 1981;
        uint256 d = 2017;
        uint256 e;

        e = powerWithModulus(1234567890, solution, 4 * a + c);
        if (powerWithModulus(e, d, 4 * b + d) == 1234567890) {
            Solved(msg.sender);
            solved = true;
            msg.sender.send(balance);
        } else {
            UnsuccessfulAttempt(msg.sender);
        }
    }
}",False,False,False
0x498e950892260b0e9dfd5895d7501f340e92d263,77: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

contract Presale {
    mapping (address => uint) public balances;
    uint public transfered_total = 0;
    
    uint public constant min_goal_amount = 5 ether;
    uint public constant max_goal_amount = 10 ether;
    
    // Vega Fund Round A Address
    address public project_wallet;

    uint public presale_start_block;
    uint public presale_end_block;
    
    // est. of blocks count in 1 month
    // Based on 1 block every 17 seconds, 30 days would produce ~152,471
    // Just for allowing for some additional time round to 153,000
    uint constant blocks_in_one_months = 100;
    
    // block number of the end of refund window, 
    // which will occur in the end of 1 month after presale
    uint public refund_window_end_block;
    
    function Presale(uint _start_block, uint _end_block, address _project_wallet) {
        if (_start_block <= block.number) throw;
        if (_end_block <= _start_block) throw;
        if (_project_wallet == 0) throw;
        
        presale_start_block = _start_block;
        presale_end_block = _end_block;
        project_wallet = _project_wallet;
	refund_window_end_block = presale_end_block + blocks_in_one_months;
    }
	
    function has_presale_started() private constant returns (bool) {
	return block.number >= presale_start_block;
    }
    
    function has_presale_time_ended() private constant returns (bool) {
        return block.number > presale_end_block;
    }
    
    function is_min_goal_reached() private constant returns (bool) {
        return transfered_total >= min_goal_amount;
    }
    
    function is_max_goal_reached() private constant returns (bool) {
        return transfered_total >= max_goal_amount;
    }
    
    // Accept ETH while presale is active or until maximum goal is reached.
    function () payable {
	// check if presale has started
        if (!has_presale_started()) throw;
	    
	// check if presale date is not over
	if (has_presale_time_ended()) throw;
	    
	// don`t accept transactions with zero value
	if (msg.value == 0) throw;

        // check if max goal is not reached
	if (is_max_goal_reached()) throw;
        
        if (transfered_total + msg.value > max_goal_amount) {
            // return change
	    var change_to_return = transfered_total + msg.value - max_goal_amount;
	    if (!msg.sender.send(change_to_return)) throw;
            
            var to_add = max_goal_amount - transfered_total;
            balances[msg.sender] += to_add;
	    transfered_total += to_add;
        } else {
            // set data
	    balances[msg.sender] += msg.value;
	    transfered_total += msg.value;
        }
    }
    
    // Transfer ETH to Vega Round A address, as soon as minimum goal is reached.
    function transfer_funds_to_project() {
        if (!is_min_goal_reached()) throw;
        if (this.balance == 0) throw;
        
        // transfer ethers to Vega Round A address
        if (!project_wallet.send(this.balance)) throw;
    }
    
    // Refund ETH in case minimum goal was not reached during presale.
    // Refund will be available for one month window after presale.
    function refund() {
        if (!has_presale_time_ended()) throw;
        if (is_min_goal_reached()) throw;
        if (block.number > refund_window_end_block) throw;
        
        var amount = balances[msg.sender];
        // check if sender has balance
        if (amount == 0) throw;
        
        // reset balance
        balances[msg.sender] = 0;
        
        // actual refund
        if (!msg.sender.send(amount)) throw;
    }
    
    // In case any ETH has left unclaimed after one month window, send them to Vega Round A address.
    function transfer_left_funds_to_project() {
        if (!has_presale_time_ended()) throw;
        if (is_min_goal_reached()) throw;
        if (block.number <= refund_window_end_block) throw;
        
        if (this.balance == 0) throw;
        // transfer left ETH to Vega Round A address
        if (!project_wallet.send(this.balance)) throw;
    }
}",False,True,True
0xf9735dc96a98f68ac8fe6fccf1e7b9876ddb6b47,73: arithmetic;,True,False,False,"pragma solidity ^0.4.2;

contract Presale {
    mapping (address => uint) public balances;
    uint public transfered_total = 0;
    
    uint public constant min_goal_amount = 5 ether;
    uint public constant max_goal_amount = 10 ether;
    
    // Vega Fund Round A Address
    address public project_wallet;

    uint public presale_start_block;
    uint public presale_end_block;
    
    // est. of blocks count in 1 month
    // Based on 1 block every 17 seconds, 30 days would produce ~152,471
    // Just for allowing for some additional time round to 153,000
    uint constant blocks_in_one_months = 153000;
    
    // block number of the end of refund window, 
    // which will occur in the end of 1 month after presale
    uint public refund_window_end_block;
    
    function Presale(uint _start_block, uint _end_block, address _project_wallet) {
        if (_start_block <= block.number) throw;
        if (_end_block <= _start_block) throw;
        if (_project_wallet == 0) throw;
        
        presale_start_block = _start_block;
        presale_end_block = _end_block;
        project_wallet = _project_wallet;
	refund_window_end_block = presale_end_block + blocks_in_one_months;
    }
	
    function has_presale_started() private constant returns (bool) {
	return block.number >= presale_start_block;
    }
    
    function has_presale_time_ended() private constant returns (bool) {
        return block.number > presale_end_block;
    }
    
    function is_min_goal_reached() private constant returns (bool) {
        return transfered_total >= min_goal_amount;
    }
    
    function is_max_goal_reached() private constant returns (bool) {
        return transfered_total >= max_goal_amount;
    }
    
    // Accept ETH while presale is active or until maximum goal is reached.
    function () payable {
	// check if presale has started
        if (!has_presale_started()) throw;
	    
	// check if presale date is not over
	if (has_presale_time_ended()) throw;
	    
	// don`t accept transactions with zero value
	if (msg.value == 0) throw;

        // check if max goal is not reached
	if (is_max_goal_reached()) throw;
        
        if (transfered_total + msg.value > max_goal_amount) {
            // return change
	    var change_to_return = transfered_total + msg.value - max_goal_amount;
	    if (!msg.sender.send(change_to_return)) throw;
            
            var to_add = max_goal_amount - transfered_total;
            balances[msg.sender] += to_add;
	    transfered_total += to_add;
        } else {
            // set data
	    balances[msg.sender] += msg.value;
	    transfered_total += msg.value;
        }
    }
    
    // Transfer ETH to Vega Round A address, as soon as minimum goal is reached.
    function transfer_funds_to_project() {
        if (!is_min_goal_reached()) throw;
        if (this.balance == 0) throw;
        
        // transfer ethers to Vega Round A address
        if (!project_wallet.send(this.balance)) throw;
    }
    
    // Refund ETH in case minimum goal was not reached during presale.
    // Refund will be available for one month window after presale.
    function refund() {
        if (!has_presale_time_ended()) throw;
        if (is_min_goal_reached()) throw;
        if (block.number > refund_window_end_block) throw;
        
        var amount = balances[msg.sender];
        // check if sender has balance
        if (amount == 0) throw;
        
        // reset balance
        balances[msg.sender] = 0;
        
        // actual refund
        if (!msg.sender.send(amount)) throw;
    }
    
    // In case any ETH has left unclaimed after one month window, send them to Vega Round A address.
    function transfer_left_funds_to_project() {
        if (!has_presale_time_ended()) throw;
        if (is_min_goal_reached()) throw;
        if (block.number <= refund_window_end_block) throw;
        
        if (this.balance == 0) throw;
        // transfer left ETH to Vega Round A address
        if (!project_wallet.send(this.balance)) throw;
    }
}",False,True,True
0xff3216f86a723f2c23b03b5cd1f622eb1a204159,FP,True,False,False,"pragma solidity ^0.4.2;

contract ValentineRegistry {

    event LogValentineRequestCreated(string requesterName, string valentineName, string customMessage, address valentineAddress, address requesterAddress);
    event LogRequestAccepted(address requesterAddress);

    struct Request {
        string requesterName;
        string valentineName;
        string customMessage;
        bool doesExist;
        bool wasAccepted;
        address valentineAddress;
    }
    address public owner;
    // Requests maps requester addresses to the requests details
    mapping (address => Request) private requests;
    uint public numRequesters;
    address[] public requesters;
    address constant ADDRESS_NULL = 0;
    uint constant MAX_CUSTOM_MESSAGE_LENGTH = 140;
    uint constant MAX_NAME_LENGTH = 25;
    uint constant COST = 0.1 ether;

    modifier restricted() {
        if (msg.sender != owner)
            throw;
        _;
    }
    modifier costs(uint _amount) {
        if (msg.value < _amount)
            throw;
        _;
    }
    modifier prohibitRequestUpdates() {
        if (requests[msg.sender].doesExist)
            throw;
        _;
    }

    function ValentineRegistry() {
        owner = msg.sender;
    }

    // Creates a valentine request that can only be accepted by the specified valentineAddress
    function createTargetedValentineRequest(string requesterName, string valentineName,
        string customMessage, address valentineAddress)
        costs(COST)
        prohibitRequestUpdates
        payable
        public {
        createNewValentineRequest(requesterName, valentineName, customMessage, valentineAddress);
    }

    // Creates a valentine request that can be fullfilled by any address
    function createOpenValentineRequest(string requesterName, string valentineName, string customMessage)
        costs(COST)
        prohibitRequestUpdates
        payable
        public {
        createNewValentineRequest(requesterName, valentineName, customMessage, ADDRESS_NULL);
    }

    function createNewValentineRequest(string requesterName, string valentineName, string customMessage,
        address valentineAddress)
        internal {
        if (bytes(requesterName).length > MAX_NAME_LENGTH || bytes(valentineName).length > MAX_NAME_LENGTH
            || bytes(customMessage).length > MAX_CUSTOM_MESSAGE_LENGTH) {
            throw; // invalid request
        }
        bool doesExist = true;
        bool wasAccepted = false;
        Request memory r = Request(requesterName, valentineName, customMessage, doesExist,
        wasAccepted, valentineAddress);
        requesters.push(msg.sender);
        numRequesters++;
        requests[msg.sender] = r;
        LogValentineRequestCreated(requesterName, valentineName, customMessage, valentineAddress, msg.sender);
    }

    function acceptValentineRequest(address requesterAddress) public {
        Request request = requests[requesterAddress];
        if (!request.doesExist) {
            throw; // the request doesn't exist
        }
        request.wasAccepted = true;
        LogRequestAccepted(requesterAddress);
    }

    function getRequestByRequesterAddress(address requesterAddress) public returns (string, string, string, bool, address, address) {
        Request r = requests[requesterAddress];
        if (!r.doesExist) {
            return ("""", """", """", false, ADDRESS_NULL, ADDRESS_NULL);
        }
        return (r.requesterName, r.valentineName, r.customMessage, r.wasAccepted, r.valentineAddress, requesterAddress);
    }

    function getRequestByIndex(uint index) public returns (string, string, string, bool, address, address) {
        if (index >= requesters.length) {
            throw;
        }
        address requesterAddress = requesters[index];
        Request r = requests[requesterAddress];
        return (r.requesterName, r.valentineName, r.customMessage, r.wasAccepted, r.valentineAddress, requesterAddress);
    }

    function updateOwner(address newOwner)
        restricted
        public {
        owner = newOwner;
    }

    function cashout(address recipient)
        restricted
        public {
        address contractAddress = this;
        if (!recipient.send(contractAddress.balance)) {
            throw;
        }
    }
}",False,False,False
0x3cf853facae392c3e4310ab805da30a1da508609,123: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. 
// IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. 
// YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.
//
// THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find some additional checks and excessive code, consuming some extra gas. This is intentional. 
// Even though the contract should work without these parts, they make the code more secure in production and for future refactoring.
// Also, they show more clearly what we have considered and addressed during development.
// Discussion is welcome!
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
    uint public constant PRESALE_START  = 3151809; /* approx. 09.02.2017 14:30 */
    uint public constant PRESALE_END    = 3152066; /* approx. 09.02.2017 15:30 */
    uint public constant WITHDRAWAL_END = 3152323; /* approx. 09.02.2017 16:30 */


    address public constant OWNER = 0xE76fE52a251C8F3a5dcD657E47A6C8D16Fdf4bFA;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x4fd997ed7c10dbd04e95d3730cd77d79513076f2,132: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. 
// IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. 
// YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.
//
// THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find some additional checks and excessive code, consuming some extra gas. This is intentional. 
// Even though the contract should work without these parts, they make the code more secure in production and for future refactoring.
// Also, they show more clearly what we have considered and addressed during development.
// Discussion is welcome!
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4"";

    /* ====== configuration START ====== */
    uint public constant PRESALE_START  = 3172723; /* approx. 12.02.2017 23:50 */
    uint public constant PRESALE_END    = 3302366; /* approx. 06.03.2017 00:00 */
    uint public constant WITHDRAWAL_END = 3678823; /* approx. 06.05.2017 00:00 */

    address public constant OWNER = 0xE76fE52a251C8F3a5dcD657E47A6C8D16Fdf4bFA;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 4000;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 12000;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,True,True
0x51dce38369b7d57d367fa1b738723a626f15b8ff,134: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. 
// IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. 
// YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.
//
// THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find some additional checks and excessive code, consuming some extra gas. This is intentional. 
// Even though the contract should work without these parts, they make the code more secure in production and for future refactoring.
// Also, they show more clearly what we have considered and addressed during development.
// Discussion is welcome!
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
    
    uint public constant PRESALE_START  = 3147370; /* approx. 08.02.2017 20:15 */
    uint public constant PRESALE_END    = 3147494; /* approx. 09.02.2017 08:00 */
    uint public constant WITHDRAWAL_END = 3153254; /* approx. 10.02.2017 08:00 */


    address public constant OWNER = 0xE76fE52a251C8F3a5dcD657E47A6C8D16Fdf4bFA;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x5965c4ee0e04ab0aa480527b7c91be8deca47f9c,134: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. 
// IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. 
// YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.
//
// THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find some additional checks and excessive code, consuming some extra gas. This is intentional. 
// Even though the contract should work without these parts, they make the code more secure in production and for future refactoring.
// Also, they show more clearly what we have considered and addressed during development.
// Discussion is welcome!
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
    
    uint public constant PRESALE_START  = 3142163; /* approx. 08.02.2017 00:00 */
    uint public constant PRESALE_END    = 3142994; /* approx. 08.02.2017 12:00 */
    uint public constant WITHDRAWAL_END = 3145873; /* approx. 08.02.2017 23:59 */


    address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x5e3741d9faa0f62660bdecdd3ac43c97c83a9881,123: arithmetic; 133: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. 
// IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. 
// YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.
//
// THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find some additional checks and excessive code, consuming some extra gas. This is intentional. 
// Even though the contract should work without these parts, they make the code more secure in production and for future refactoring.
// Also, they show more clearly what we have considered and addressed during development.
// Discussion is welcome!
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
    uint public constant PRESALE_START  = 3147370; /* approx. 08.02.2017 20:15 */
    uint public constant PRESALE_END    = 3155594; /* approx. 10.02.2017 20:00 */
    uint public constant WITHDRAWAL_END = 3161353; /* approx. 11.02.2017 20:00 */


    address public constant OWNER = 0xE76fE52a251C8F3a5dcD657E47A6C8D16Fdf4bFA;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x85169e1f0d8c2f27dd44f1cfbb81172dfeafe7c1,134: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. 
// IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. 
// YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.
//
// THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find some additional checks and excessive code, consuming some extra gas. This is intentional. 
// Even though the contract should work without these parts, they make the code more secure in production and for future refactoring.
// Also, they show more clearly what we have considered and addressed during development.
// Discussion is welcome!
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3142163; /* approx. 08.02.2017 00:00 */
    uint public constant PRESALE_END    = 3145693; /* approx. 08.02.2017 23:59 */
    uint public constant WITHDRAWAL_END = 3151453; /* approx. 09.02.2017 23:59 */


    address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xdcf14a9cba1d5ee6d4671c20c559373f331910ea,72: arithmetic;,True,False,True,"pragma solidity ^0.4.0;

contract Lotto {

    //	Play lottery.
    //	Rules:
    //	-Address plays between minPlay & mayPlay in order to increase stack amount.
    //	-Address can play many times.
    //	-A fee is directly withrawn from incoming amounts (see feesPerMillion).
    //	-As soon as the jackpot goes beyond the target, an address is chosen randomly proportionally to its stack amount.
    //	-The winner address get paid with the jackpot.
    //	-gameNumber is increased and minPlay,maxPlay,target get the values from nextMinPlay,nextMaxPlay,nextTarget.
    //	-nextMinPlay,nextMaxPlay,nextTarget can only be changed by the owner for the next game.


    address public owner;
    uint256 public gameNumber;
    uint256 public feesPerMillion;
    uint256 public nextFeesPerMillion;
    uint256 public jackpot;
    uint256 public target;
    uint256 public nextTarget;
    uint256 public minPlay;
    uint256 public nextMinPlay;
    uint256 public maxPlay;
    uint256 public nextMaxPlay;
    mapping(address => uint256) public playersAmounts;
    address[] public playersList;
    uint256 private vMillion;


    event newGame(uint256 ts, uint256 game);
    event newPlay(uint256 ts, uint256 game, address player, uint256 grossAmount, uint256 amount, uint256 stack, uint256 jackpot, uint256 target);
    event newWinner(uint256 ts, uint256 game, address player, uint256 amount);
    event forceGame(uint256 ts,  uint256 game);
    event payment(uint256 ts, address addr, uint256 amount, bool status);



    function Lotto(){
        owner=msg.sender;
        gameNumber=1;
        vMillion=1000000;
        feesPerMillion=5000;
        nextFeesPerMillion=feesPerMillion;
        minPlay=1 ether;
        nextMinPlay=minPlay;
        maxPlay=3 ether;
        nextMaxPlay=maxPlay;
        target=10 ether;
        nextTarget=target;
        jackpot=0;
        newGame(block.timestamp, gameNumber);
    }



    function() payable public{}



    function play() payable public {
        if(msg.sender==owner) throw;
        if(msg.value<minPlay || msg.value>maxPlay) throw;

        if(playersAmounts[msg.sender]==0){
            playersList.push(msg.sender);
        }
        uint256 amount;
        amount=(vMillion-feesPerMillion)*msg.value/vMillion;
        playersAmounts[msg.sender]=playersAmounts[msg.sender]+amount;
        jackpot=jackpot+amount;
        newPlay(block.timestamp, gameNumber, msg.sender, msg.value, amount, playersAmounts[msg.sender], jackpot, target);
        if(jackpot>=target){
            _pickWinner();
        }
    }



    function _pickWinner() private{
        uint256 random;
        random=(uint256(sha256(block.blockhash(block.number-1), block.coinbase, block.difficulty, block.gaslimit, block.number, block.timestamp, msg.data, msg.gas, msg.sender, msg.sig, msg.value))%jackpot)+1;
        uint256 playerNumber;
        bool keepGoing;
        playerNumber=0;
        keepGoing=true;
        while(keepGoing && playerNumber<playersList.length){
            if(random<=playersAmounts[playersList[playerNumber]]){
                keepGoing=false;
            }else{
                random=random-playersAmounts[playersList[playerNumber]];
                playerNumber=playerNumber+1;
            }
        }
        if(!keepGoing){
            newWinner(block.timestamp, gameNumber, playersList[playerNumber], jackpot);
            if(playersList[playerNumber].send(jackpot)){
                payment(block.timestamp, playersList[playerNumber], jackpot, true);
            }else{
                payment(block.timestamp, playersList[playerNumber], jackpot, false);
            }
        }
        target=nextTarget;
        minPlay=nextMinPlay;
        maxPlay=nextMaxPlay;
        feesPerMillion=nextFeesPerMillion;
        jackpot=0;
        gameNumber=gameNumber+1;
        for(uint256 i; i<playersList.length; i++){
            playersAmounts[playersList[i]]=0;
        }
        delete playersList;
    }



    function _admin(uint256 cmd, uint256 value) public{
       if(msg.sender!=owner) throw;
       if(cmd==1){
           nextTarget=value;
       }else if(cmd==2){
           nextMinPlay=value;
       }else if(cmd==3){
           nextMaxPlay=value;
       }else if(cmd==4){
           nextFeesPerMillion=value;
       }else if(cmd==5){
           forceGame(block.timestamp, gameNumber);
           _pickWinner();
       }
    }



    function _withdraw(address destination, uint256 value) public{
       if(msg.sender!=owner) throw;
       if(value>=(this.balance-jackpot)) throw;
       if(destination.send(value)){
           payment(block.timestamp, destination, value, true);
       }else{
           payment(block.timestamp, destination, value, false);
       }
    }

}",False,False,True
0x0b983fa1bcbdf24bdbfacb660faa76c586a16c64,109: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//


contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3116560; //	approx. 03.02.2017 18:30
	uint public constant PRESALE_END    = 3116597; //	approx. 03.02.2017 18:45
	uint public constant WITHDRAWAL_END = 3116657; //	approx. 03.02.2017 19:00


	address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x2a28cc275b458019910e3b8b8ee58f17eb6d38c8,133: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
	uint public constant PRESALE_START  = 3125170; /* approx. 05.02.2017 04:20 CET */
    uint public constant PRESALE_END    = 3125195; /* approx. 05.02.2017 04:25 CET */
    uint public constant WITHDRAWAL_END = 3125215; /* approx. 05.02.2017 04:30 CET */


    address public constant OWNER = 0x41ab8360dEF1e19FdFa32092D83a7a7996C312a4;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    //inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if state is not less than given
    modifier inStateBefore(State state) {
        if (state >= currentState()) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x3aaa5474a09804b08120e6e33bfc433367ab238c,123: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3128000; /* approx. 05.02.2017 13:50 CET */
    uint public constant PRESALE_END    = 3128350; /* approx. 05.02.2017 15:00 CET */
    uint public constant WITHDRAWAL_END = 3128470; /* approx. 05.02.2017 15:30 CET */
    
    address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x5ae14c0101e0a40c709340592f1f1c052ef4ab92,140: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3127430;    /* approx. 22.01.2017 20:00 CET */
    uint public constant PRESALE_END    = 3127490;    /* approx. 23.01.2017 14:00 CET */
    uint public constant WITHDRAWAL_END = 3127499;    /* approx. 23.01.2017 18:00 CET */

    address public constant OWNER = 0x41ab8360dEF1e19FdFa32092D83a7a7996C312a4;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x5ed5b9a13af4581524ebb7a0701bc4366d002289,134: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3127150; /* approx. 05.02.2017 11:00 CET */
    uint public constant PRESALE_END    = 3127750; /* approx. 05.02.2017 13:00 CET */
    uint public constant WITHDRAWAL_END = 3128710; /* approx. 05.02.2017 17:00 CET */


    address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x60b1bfaa999ab532df3ab804b43ed549a8636501,134: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3127375; /* approx. 05.02.2017 11:00 CET */
    uint public constant PRESALE_END    = 3127785; /* approx. 05.02.2017 13:00 CET */
    uint public constant WITHDRAWAL_END = 3128795; /* approx. 05.02.2017 17:00 CET */


    address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x9bf233b2f9eea51708c0b345f28fc621f83daa78,45: arithmetic; 42: time manipulation;,True,False,True,"pragma solidity ^0.4.6;

contract token { function transferFrom(address sender, address receiver, uint amount) returns(bool success){  } }

contract Crowdsale {
    /* if successful, the funds will be retrievable by this address */
    address public beneficiary = 0x003230bbe64eccd66f62913679c8966cf9f41166; 
    /* if the funding goal is not reached, investors may withdraw their funds */
    uint public fundingGoal = 50000000;
    /* the maximum amount of tokens to be sold */
    uint public maxGoal = 394240000; 
    /* how much has been raised by crowdale (in ETH) */
    uint public amountRaised; 
    /* the start date of the crowdsale */
    uint public start = 1488294000; 
    /* the number of tokens already sold */
    uint public tokensSold; 
    /* there are different prices in different time intervals */
    uint[4] public deadlines = [1488297600, 1488902400, 1489507200,1490112000];
    uint[4] public prices = [833333333333333, 909090909090909,952380952380952, 1000000000000000];
    /* the address of the token contract */
    token public tokenReward;
    /* the balances (in ETH) of all investors */
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    /* notifying transfers and the success of the crowdsale*/
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    

    /*  initialization, set the token address */
    function Crowdsale( ) {
        tokenReward = token(0xb4e7fc7f59c2ec07aee08c46241d7b47de4cec06);
    }

    /* whenever anyone sends funds to a contract, the corresponding amount of tokens is transfered if the crowdsale started and hasn't been
        closed already and the maxGoal wasn't reached yet.*/
    function () payable{
        uint amount = msg.value;
        uint numTokens = amount / getPrice();
        if (crowdsaleClosed||now<start||tokensSold+numTokens>maxGoal) throw;
        balanceOf[msg.sender] = amount;
        amountRaised += amount;
        tokensSold+=numTokens;
        if(!tokenReward.transferFrom(beneficiary, msg.sender, numTokens)) throw;
        FundTransfer(msg.sender, amount, true);
    }
    
    /* looks up the current token price */
    function getPrice() constant returns (uint256 price){
        for(var i = 0; i < deadlines.length; i++)
            if(now<deadlines[i])
                return prices[i];
        return prices[prices.length-1];//should never be returned, but to be sure to not divide by 0
    }

    modifier afterDeadline() { if (now >= deadlines[deadlines.length-1]) _; }

    /* checks if the goal or time limit has been reached and ends the campaign */
    function checkGoalReached() afterDeadline {
        if (tokensSold >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /* allows the beneficiary and/or the funders to withdraw their funds */
    function safeWithdrawal() afterDeadline {
        // if the goal hasn't been reached, investors may withdraw their funds
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }
        //if the goal has benn reached and the beneficiary himself is the sender, he may withdraw everything
        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                //If we fail to send the funds to beneficiary, unlock funders balance
                fundingGoalReached = false;
            }
        }
    }
}",False,False,True
0xaedde4941e7eac04f97be3a89af50a454d7c5f89,133: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3127400;    /* approx. 22.01.2017 20:00 CET */
    uint public constant PRESALE_END    = 3127410;    /* approx. 23.01.2017 14:00 CET */
    uint public constant WITHDRAWAL_END = 3127420;    /* approx. 23.01.2017 18:00 CET */

    address public constant OWNER = 0x41ab8360dEF1e19FdFa32092D83a7a7996C312a4;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xaffd8d333badb2a6dfab4854c5a30ac2dbb9db9f,133: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
	uint public constant PRESALE_START  = 3125270; /* approx. 05.02.2017 04:20 CET */
    uint public constant PRESALE_END    = 3125280; /* approx. 05.02.2017 04:25 CET */
    uint public constant WITHDRAWAL_END = 3125290; /* approx. 05.02.2017 04:30 CET */


    address public constant OWNER = 0x41ab8360dEF1e19FdFa32092D83a7a7996C312a4;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is after than the given one.
    modifier inStateBefore(State state) {
        if (currentState() > state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xb2048d829482dbc9baf6951c28909e5c49686041,133: arithmetic; 144: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
	uint public constant PRESALE_START  = 3125250; /* approx. 05.02.2017 04:20 CET */
    uint public constant PRESALE_END    = 3125260; /* approx. 05.02.2017 04:25 CET */
    uint public constant WITHDRAWAL_END = 3125270; /* approx. 05.02.2017 04:30 CET */


    address public constant OWNER = 0x41ab8360dEF1e19FdFa32092D83a7a7996C312a4;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is after than the given one.
    modifier inStateBefore(State state) {
        if (currentState() > state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xb9068705fbdc3b06c11763d2c260be682e6844ff,133: arithmetic; 144: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */

    uint public constant PRESALE_START  = 3128000; /* approx. 05.02.2017 13:50 CET */
    uint public constant PRESALE_END    = 3129250; /* approx. 05.02.2017 18:00 CET */
    uint public constant WITHDRAWAL_END = 3129490; /* approx. 05.02.2017 19:00 CET */
    
    address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if the current state is not before than the given one.
    modifier inStateBefore(State state) {
        if (currentState() >= state) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xd3f3eb105daa3712eda7709f59ac0ec0d2d202b5,133: arithmetic; 144: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

//
// ==== DISCLAIMER ====
//
// ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.
// ALTHOUGH THIS SMART CONTRACT CREATED WITH GREAT CARE AND IN HOPE TO BE USEFUL, NO GUARANTEES OF FLAWLES OPERATION CAN BE GIVEN. 
// ESPECIALLY SUBTILE BUGS, HACKER ATTACS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE AN UNINTENTIONAL BEHAVIOUR. 
// YOU ARE DEEPLY ENCORAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. 
// DON'T USE THIS SMART CONTRACT IN CASE OF ANY SUBSTANTIONAL DOUBTS OR IF YOU DON'T KNOW WHAT ARE YOU DOING.
//
// THIS SOFTWARE IS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====
//
//
// ==== PARANOIA NOTICE ==== 
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract should works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// ====
//

/// @author ethernian
/// @notice report bugs to: bugs@ethernian.com
/// @title Presale Contract

contract Presale {

    string public constant VERSION = ""0.1.4-beta"";

    /* ====== configuration START ====== */
	uint public constant PRESALE_START  = 3125150; /* approx. 05.02.2017 04:20 CET */
    uint public constant PRESALE_END    = 3125175; /* approx. 05.02.2017 04:25 CET */
    uint public constant WITHDRAWAL_END = 3125195; /* approx. 05.02.2017 04:30 CET */


    address public constant OWNER = 0x41ab8360dEF1e19FdFa32092D83a7a7996C312a4;

    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */

    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
    mapping (address => uint) public balances;

    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
    bool public isAborted = false;


    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (!OWNER.send(this.balance)) throw;
    }

    function abort() external
    inStateBefore(State.REFUND_RUNNING)
    onlyOwner
    {
        isAborted = true;
    }

    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (isAborted) {
            return this.balance > 0 
                   ? State.REFUND_RUNNING 
                   : State.CLOSED;
        } else if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (this.balance == 0) {
            return State.CLOSED;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else {
            return State.REFUND_RUNNING;
        } 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }

    //fails if state is not less than given
    modifier inStateBefore(State state) {
        if (state >= currentState()) throw;
        _;
    }

    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
                throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
        if (msg.sender != OWNER)  throw;
        _;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xe1e8eabd8fcf08ed50ae1f2ed4710c1a1f38542c,119: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//


contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3116580; //	approx. 03.02.2017 18:30
	uint public constant PRESALE_END    = 3116597; //	approx. 03.02.2017 18:45
	uint public constant WITHDRAWAL_END = 3116657; //	approx. 03.02.2017 19:00


	address public constant OWNER = 0xA4769870EB607A4fDaBFfbcC3AD066c8213bD87D;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0xe3c61a3bff7cb03ddd422258006fddd5ba1ed0fe,119: arithmetic; 130: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//


contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3116646; //	approx. 	03.02.2017 18:50
	uint public constant PRESALE_END    = 3116686; //	approx. 	03.02.2017 19:00
	uint public constant WITHDRAWAL_END = 3116726; //	approx. 	03.02.2017 19:10


	address public constant OWNER = 0xA4769870EB607A4fDaBFfbcC3AD066c8213bD87D;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x022de2e28a61f9d197f8966dd0fc8f7ddf70f2dc,118: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//

contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3071952; //	approx. 	27.01.2017 08:30
	uint public constant PRESALE_END    = 3074472; //	approx. 	27.01.2017 19:00
	uint public constant WITHDRAWAL_END = 3080232; //	approx. 	28.01.2017 19:00


	address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,True,True
0xb78e82956b6037e13b83c287aa9047f748c0f55a,117: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//

contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3058138; //	approx. 25.01.2017 01:45
	uint public constant PRESALE_END    = 3061678; //	approx. 25.01.2017 16:30
	uint public constant WITHDRAWAL_END = 3062398; //	approx. 25.01.2017 19:30

	address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x6e01ee36b522a824609b7f7dfb5e4aa8fbb48934,FP,True,False,False,"//https://github.com/codetract/ethToken

pragma solidity ^0.4.6;

/**
@title StandardToken
@author https://github.com/ConsenSys/Tokens/tree/master/Token_Contracts/contracts
*/
contract StandardToken {
    uint256 public totalSupply;
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    /**
    @notice Function transfers '_value' tokens from 'msg.sender' to '_to'
    @param _to The address of the destination account
    @param _value The number of tokens to be transferred
    @return success Whether the transfer is successful
    */
    function transfer(address _to, uint256 _value) returns(bool success) {
        if(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    /**
    @notice Function transfers '_value' tokens from '_from' to '_to' if there is allowance
    @param _from The address of the source account
    @param _to The address of the destination account
    @param _value The number of tokens to be transferred
    @return success Whether the transfer is successful
    */
    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {
        if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    /**
   	@notice Returns the balance associated with the relevant address
   	@param _owner address of account owner
   	@return { ""balance"" : ""token balance of _owner"" }
   	*/
    function balanceOf(address _owner) constant returns(uint256 balance) {
        return balances[_owner];
    }

    /**
    @notice Function approves `_addr` to spend `_value` tokens of msg.sender
    @param _spender The address of the account able to transfer the tokens
    @param _value The amount of wei to be approved for transfer
    @return success Whether the approval was successful or not
    */
    function approve(address _spender, uint256 _value) returns(bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
    @notice Returns the amount for _spender left approved by _owner
    @param _owner The address of the account owning tokens
    @param _spender The address of the account able to transfer the tokens
    @return remaining Amount of remaining tokens allowed to spent
    */
    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {
        return allowed[_owner][_spender];
    }

}

/**
@title HumanStandardToken
@author https://github.com/ConsenSys/Tokens/tree/master/Token_Contracts/contracts
*/
contract HumanStandardToken is StandardToken {
    string public name; //fancy name: eg Simon Bucks
    uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol; //An identifier: eg SBX
    string public version; //human 0.1 standard. Just an arbitrary versioning scheme.
}

/**
@title EthToken
@author https://codetract.io
*/
contract EthToken is HumanStandardToken {
    /**
    @notice Constructor function for the EthToken contract
    @dev Contract to trade ether to tokens at 1 to 1
    */
    function EthToken() {
        balances[msg.sender] = 0;
        totalSupply = 0;
        name = 'ETH Token';
        decimals = 18;
        symbol = 'Ξ';
        version = '0.2';
    }

    event LogCreateToken(address indexed _from, uint256 _value);
    event LogRedeemToken(address indexed _from, uint256 _value);

    /**
    @notice Creates ether tokens corresponding to the amount of ether received 'msg.value'. Updates account token balance
    @return success Whether the transfer is successful
    */
    function createToken() payable returns(bool success) {
        if(msg.value == 0) {
            throw;
        }
        if((balances[msg.sender] + msg.value) > balances[msg.sender] && (totalSupply + msg.value) > totalSupply) {
            totalSupply += msg.value;
            balances[msg.sender] += msg.value;
            LogCreateToken(msg.sender, msg.value);
            return true;
        } else {
            throw;
        }
    }

    /**
    @notice Converts token quantity defined by '_token' into ether and sends back to msg.sender
    @param _tokens The number of tokens to be converted to ether
    @return success Whether the transfer is successful
    */
    function redeemToken(uint256 _tokens) returns(bool success) {
        if(this.balance < totalSupply) {
            throw;
        }
        if(_tokens == 0) {
            throw;
        }
        if(balances[msg.sender] >= _tokens && totalSupply >= _tokens) {
            balances[msg.sender] -= _tokens;
            totalSupply -= _tokens;
            if(msg.sender.send(_tokens)) {
                LogRedeemToken(msg.sender, _tokens);
                return true;
            } else {
                throw;
            }
        } else {
            throw;
        }
    }

    function() payable {
        createToken();
    }
}",Significant,False,False
0x142eba6cd4e1977fba4a440c882ee460654d1766,22: arithmetic;,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if (((_value*tokenTaxRate*10)/100)%10 != 0) balanceOf[bank]+=1;
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
		//now check for rounding down which would result in permanent loss of coins
		if (((tokensOfferedOf[_from]*tokenTaxRate*10)/100)%10 != 0) balanceOf[bank]+=1;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
}",False,False,False
0x1654d540616bfb3f13973ed6019e43005be43219,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	event Transfer(address indexed _from, address indexed _to, uint256 _value);
	
	function totalSupply() constant returns (uint256 totalSupply) {
	    return 10000;
	}
	function balanceOf(address _owner) constant returns (uint256 balance) {
	    return balanceOf[_owner];
	}
	
	function transfer(address _to, uint256 _value) returns (bool success) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) return false;
		if (balanceOf[_to]+_value<balanceOf[_to]) return false;
		if (_value<0) return false;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
		Transfer(msg.sender,_to,_value);
		return true;
	}
	
	mapping (address => mapping (address=>uint256)) approvalList;
	function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
		if (balanceOf[_from]<_value) return false;
		if (balanceOf[_to]+_value<balanceOf[_to]) return false;
		if (_value<0) return false;
		if (approvalList[_from][msg.sender]<_value) return false;
		approvalList[_from][msg.sender]-=_value;
		balanceOf[_from] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
		Transfer(_from,_to,_value);
		return true;
	}
	event Approval(address indexed _owner, address indexed _spender, uint256 _value);
	function approve(address _spender, uint256 _value) returns (bool success) {
	    approvalList[msg.sender][_spender]=_value;
	    Approval(msg.sender,_spender,_value);
	    return true;
	}
	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
	    return approvalList[_owner][_spender];
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
		Transfer(_from,msg.sender,tokensOfferedOf[_from]);
		//now check for rounding down which would result in permanent loss of coins
		if ((tokensOfferedOf[_from]*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
}",False,False,False
0x1b27996479b11abc8a8d0447deb3fb0183788484,118: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//

contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3051585;    /* approx. 23.01.2017 23:45 CET */
	uint public constant PRESALE_END    = 3055605;    /* approx. 24.01.2017 16:30 CET */
	uint public constant WITHDRAWAL_END = 3056325;    /* approx. 24.01.2017 19:30 CET */


	address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x4c24fd04063e8b1c881e5ec0f46208d66d010c64,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
}",False,False,False
0x5d39fcebe89ab0397947881539fd6dc7d99c6a87,111: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  PARANOIA DISCLAIMER ****
// A carefull reader will find here some unnecessary checks and excessive code consuming some extra valueable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactorings.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
// @author ethernian
//

contract Presale {

	function cleanUp() onlyOwner {
		selfdestruct(OWNER);
	}

    string public constant VERSION = ""0.1.3-[min1,max5]"";

	/* ====== configuration START ====== */
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;
	uint public constant PRESALE_START = 3044444;
	uint public constant PRESALE_END = 3044555;
	uint public constant WITHDRAWAL_END = 3044666;
	address public constant OWNER = 0xF55DFd2B02Cf3282680C94BD01E9Da044044E6A2;
    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,False,True
0x60f0ee673e413e1c134d1497eeecce8ddd2fdd74,117: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//

contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3044895;    /* approx. 22.01.2017 21:15 CET */
	uint public constant PRESALE_END    = 3048975;    /* approx. 23.01.2017 14:15 CET */
	uint public constant WITHDRAWAL_END = 3049935;    /* approx. 23.01.2017 18:15 CET */

	address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,True,True
0x693399aae96a88b966b05394774cfb7b880355b4,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	event Transfer(address indexed _from, address indexed _to, uint256 _value);
	
	function totalSupply() constant returns (uint256 totalSupply) {
	    return 10000;
	}
	function balanceOf(address _owner) constant returns (uint256 balance) {
	    return balanceOf[_owner];
	}
	
	function transfer(address _to, uint256 _value) returns (bool success) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
		Transfer(msg.sender,_to,_value);
		return true;
	}
	
	mapping (address => mapping (address=>uint256)) approvalList;
	function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
		if (balanceOf[_from]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		if (approvalList[_from][msg.sender]<_value) throw;
		approvalList[_from][msg.sender]-=_value;
		balanceOf[_from] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
		Transfer(_from,_to,_value);
		return true;
	}
	event Approval(address indexed _owner, address indexed _spender, uint256 _value);
	function approve(address _spender, uint256 _value) returns (bool success) {
	    approvalList[msg.sender][_spender]=_value;
	    Approval(msg.sender,_spender,_value);
	    return true;
	}
	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
	    return approvalList[_owner][_spender];
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
		Transfer(_from,msg.sender,tokensOfferedOf[_from]);
		//now check for rounding down which would result in permanent loss of coins
		if ((tokensOfferedOf[_from]*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
}",False,True,False
0x81a47e985b7a133728e97efc7f9ec3654b6e73f0,85: unchecked;,True,False,True,"pragma solidity ^0.4.8;

contract Omnipurse {

  struct Contribution {
    address sender;
    uint value;
    bool refunded;
    uint256 timestamp;
  }

  struct Purse {
    address creator;
    uint256 timestamp;
    string title;
    uint8 status;
    uint numContributions;
    uint totalContributed;
    mapping (uint => Contribution) contributions;
  }

  uint public numPurse;
  mapping (uint => Purse) purses;
  mapping (address => uint[]) pursesByCreator;
  mapping (address => string) nicknames;

  function searchPursesByAddress(address creator) constant returns (uint[] ids) {
    ids = pursesByCreator[creator];
  }

  function getPurseDetails(uint purseId) constant returns (
    address creator,
    uint256 timestamp,
    string title,
    uint8 status,
    uint numContributions,
    uint totalContributed
  ) {
    Purse p = purses[purseId];
    creator = p.creator;
    timestamp = p.timestamp;
    title = p.title;
    status = p.status;
    numContributions = p.numContributions;
    totalContributed = p.totalContributed;
  }

  function getPurseContributions(uint purseId, uint contributionId) constant returns (
    address sender,
    uint value,
    bool refunded,
    string nickname,
    uint timestamp
  ) {
    Purse p = purses[purseId];
    Contribution c = p.contributions[contributionId];
    sender = c.sender;
    value = c.value;
    refunded = c.refunded;
    nickname = nicknames[c.sender];
    timestamp = c.timestamp;
  }

  function createPurse(string title) returns (uint purseId) {
    purseId = numPurse++;
    purses[purseId] = Purse(msg.sender, block.timestamp, title, 1, 0, 0);
    pursesByCreator[msg.sender].push(purseId);
  }

  function contributeToPurse(uint purseId) payable {
    Purse p = purses[purseId];
    if (p.status != 1) { throw; }
    p.totalContributed += msg.value;
    p.contributions[p.numContributions++] = Contribution(msg.sender, msg.value,
                                                        false, block.timestamp);
  }

  function dissmisPurse(uint purseId) {
    Purse p = purses[purseId];
    if (p.creator != msg.sender || (p.status != 1 && p.status != 4)) { throw; }
    bool success = true;
    for (uint i=0; i<p.numContributions; i++) {
      Contribution c = p.contributions[i];
      if(!c.refunded) {
        c.refunded = c.sender.send(c.value);
      }
      success = success && c.refunded;
    }
    p.status = success ? 3 : 4;
  }

  function finishPurse(uint purseId) {
    Purse p = purses[purseId];
    if (p.creator != msg.sender || p.status != 1) { throw; }
    if (p.creator.send(p.totalContributed)) { p.status = 2; }
  }

  function registerNickname(string nickname) {
    nicknames[msg.sender] = nickname;
  }

}",False,True,True
0x8b807cf49ca593c4678811211df2992e64f2f3ef,107: arithmetic; 117: arithmetic;,True,False,False,"pragma solidity ^0.4.6;

// Presale Smart Contract
//
// **** START:  WORK IN PROGRESS DISCLAIMER ****
// This is a work in progress and not intended for reuse.
// So don't reuse unless you know exactly what are you doing! 
// **** END:  WORK IN PROGRESS DISCLAIMER ****
//
// **** START:  PARANOIA DISCLAIMER ****
// A careful reader will find here some unnecessary checks and excessive code consuming some extra valuable gas. It is intentionally. 
// Even contract will works without these parts, they make the code more secure in production as well for future refactoring.
// Additionally it shows more clearly what we have took care of.
// You are welcome to discuss that places.
// **** END OF: PARANOIA DISCLAIMER *****
//
//
// @author ethernian
//

contract Presale {

    string public constant VERSION = ""0.1.3-beta"";

	/* ====== configuration START ====== */

	uint public constant PRESALE_START  = 3044593;    /* approx. 22.01.2017 20:00 CET */
	uint public constant PRESALE_END    = 3048913;    /* approx. 23.01.2017 14:00 CET */
	uint public constant WITHDRAWAL_END = 3049873;    /* approx. 23.01.2017 18:00 CET */

	address public constant OWNER = 0x45d5426471D12b21C3326dD0cF96f6656F7d14b1;
	
    uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1;
    uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 5;
    uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1;

    /* ====== configuration END ====== */
	
    string[5] private stateNames = [""BEFORE_START"",  ""PRESALE_RUNNING"", ""WITHDRAWAL_RUNNING"", ""REFUND_RUNNING"", ""CLOSED"" ];
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }

    uint public total_received_amount;
	mapping (address => uint) public balances;
	
    uint private constant MIN_TOTAL_AMOUNT_TO_RECEIVE = MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MAX_TOTAL_AMOUNT_TO_RECEIVE = MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH * 1 ether;
    uint private constant MIN_ACCEPTED_AMOUNT = MIN_ACCEPTED_AMOUNT_FINNEY * 1 finney;
	

    //constructor
    function Presale () validSetupOnly() { }

    //
    // ======= interface methods =======
    //

    //accept payments here
    function ()
    payable
    noReentrancy
    {
        State state = currentState();
        if (state == State.PRESALE_RUNNING) {
            receiveFunds();
        } else if (state == State.REFUND_RUNNING) {
            // any entring call in Refund Phase will cause full refund
            sendRefund();
        } else {
            throw;
        }
    }

    function refund() external
    inState(State.REFUND_RUNNING)
    noReentrancy
    {
        sendRefund();
    }


    function withdrawFunds() external
    inState(State.WITHDRAWAL_RUNNING)
    onlyOwner
    noReentrancy
    {
        // transfer funds to owner if any
        if (this.balance > 0) {
            if (!OWNER.send(this.balance)) throw;
        }
    }


    //displays current contract state in human readable form
    function state()  external constant
    returns (string)
    {
        return stateNames[ uint(currentState()) ];
    }


    //
    // ======= implementation methods =======
    //

    function sendRefund() private tokenHoldersOnly {
        // load balance to refund plus amount currently sent
        var amount_to_refund = balances[msg.sender] + msg.value;
        // reset balance
        balances[msg.sender] = 0;
        // send refund back to sender
        if (!msg.sender.send(amount_to_refund)) throw;
    }


    function receiveFunds() private notTooSmallAmountOnly {
      // no overflow is possible here: nobody have soo much money to spend.
      if (total_received_amount + msg.value > MAX_TOTAL_AMOUNT_TO_RECEIVE) {
          // accept amount only and return change
          var change_to_return = total_received_amount + msg.value - MAX_TOTAL_AMOUNT_TO_RECEIVE;
          if (!msg.sender.send(change_to_return)) throw;

          var acceptable_remainder = MAX_TOTAL_AMOUNT_TO_RECEIVE - total_received_amount;
          balances[msg.sender] += acceptable_remainder;
          total_received_amount += acceptable_remainder;
      } else {
          // accept full amount
          balances[msg.sender] += msg.value;
          total_received_amount += msg.value;
      }
    }


    function currentState() private constant returns (State) {
        if (block.number < PRESALE_START) {
            return State.BEFORE_START;
        } else if (block.number <= PRESALE_END && total_received_amount < MAX_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.PRESALE_RUNNING;
        } else if (block.number <= WITHDRAWAL_END && total_received_amount >= MIN_TOTAL_AMOUNT_TO_RECEIVE) {
            return State.WITHDRAWAL_RUNNING;
        } else if (this.balance > 0){
            return State.REFUND_RUNNING;
        } else {
            return State.CLOSED;		
		} 
    }

    //
    // ============ modifiers ============
    //

    //fails if state dosn't match
    modifier inState(State state) {
        if (state != currentState()) throw;
        _;
    }


    //fails if something in setup is looking weird
    modifier validSetupOnly() {
        if ( OWNER == 0x0 
            || PRESALE_START == 0 
            || PRESALE_END == 0 
            || WITHDRAWAL_END ==0
            || PRESALE_START <= block.number
            || PRESALE_START >= PRESALE_END
            || PRESALE_END   >= WITHDRAWAL_END
            || MIN_TOTAL_AMOUNT_TO_RECEIVE > MAX_TOTAL_AMOUNT_TO_RECEIVE )
				throw;
        _;
    }


    //accepts calls from owner only
    modifier onlyOwner(){
    	if (msg.sender != OWNER)  throw;
    	_;
    }


    //accepts calls from token holders only
    modifier tokenHoldersOnly(){
        if (balances[msg.sender] == 0) throw;
        _;
    }


    // don`t accept transactions with value less than allowed minimum
    modifier notTooSmallAmountOnly(){	
        if (msg.value < MIN_ACCEPTED_AMOUNT) throw;
        _;
    }


    //prevents reentrancy attacs
    bool private locked = false;
    modifier noReentrancy() {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }
}//contract",False,True,True
0x911d71eed45dbc20059004f8476fe149105bf1dc,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
		//now check for rounding down which would result in permanent loss of coins
		if ((tokensOfferedOf[_from]*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
}",False,True,False
0x9c794584b2f482653937b529647924606446e7f4,36: arithmetic;,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	function send(address _to, uint256 _value) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
}",False,True,False
0xabcdd0dbc5ba15804f5de963bd60491e48c3ef0b,FP,True,False,False,"pragma solidity ^0.4.7;
contract Investment{
    /** the owner of the contract, C4C */
    address owner;
    /** List of all investors. */
    address[] public investors;
    /** The investors's balances. */
    mapping(address => uint) public balances;
    /** The total amount raised. */
    uint public amountRaised;
    /** The index of the investor currentlz being paid out. */
    uint public investorIndex;
    /** The return rates (factors) per interval (in raised Ether). */
    uint[] public rates;
    uint[] public limits;
    /** indicates if ne investments are accepted */
    bool public closed;
    /** Notifies listeners that a new investment was undertaken */
    event NewInvestment(address investor, uint amount);
    /** Notifies listeners that ether was returned to the investors */
    event Returned(uint amount);

    
    function Investment(){
        owner = msg.sender;
        limits= [0, 1000000000000000000000, 4000000000000000000000, 10000000000000000000000];
        rates= [15, 14, 13,12];//1 decimal
    }
    
    /**
     * Adds new investors to the list and calculates the balance according to the current rate.
     * Minimum value: 1 ETH.
     * */
     function invest() payable{
        if (closed) throw;
        if (msg.value < 1 ether) throw;
        if (balances[msg.sender]==0){//new investor
            investors.push(msg.sender);
        }
        balances[msg.sender] += calcReturnValue(msg.value, amountRaised); 
        amountRaised += msg.value;
        NewInvestment(msg.sender, msg.value);
     }
     
     /**
      * call invest() whenever ether is sent to the contract
      * */
     function() payable{
         invest();
     }
     
     /**
      * calcultes the return value depending on the amount raised, limits and rates
      * @param value : the investment value
      * @param amRa : the amount raised
      * */
     function calcReturnValue(uint value, uint amRa) internal returns (uint){
         if(amRa >= limits[limits.length-1]) return value/10*rates[limits.length-1];
         for(uint i = limits.length-2; i >= 0; i--){
             if(amRa>=limits[i]){
                uint newAmountRaised = amRa+value;
                if(newAmountRaised>limits[i+1]){
                    uint remainingVal=newAmountRaised-limits[i+1];
                    return (value-remainingVal)/10 * rates[i] + calcReturnValue(remainingVal, limits[i+1]);
                }  
                else
                    return value/10*rates[i];
             }
         }
     }
     
     /**
      * Enables the owner to withdraw the funds
      * */
     function withdraw(){
         if(msg.sender==owner){
             msg.sender.send(this.balance);
         }
     }
     
     /**
      * called to pay the investor
      * */
     function returnInvestment() payable{
        returnInvestmentRecursive(msg.value);
        Returned(msg.value);
     }
     
     /**
      * sends the given value to the next investor(s) in the list
      * */
     function returnInvestmentRecursive(uint value) internal{
        if (investorIndex>=investors.length || value==0) return;
        else if(value<=balances[investors[investorIndex]]){
            balances[investors[investorIndex]]-=value;
            if(!investors[investorIndex].send(value)) throw; 
        } 
        else if(balances[investors[investorIndex]]>0){
            uint val = balances[investors[investorIndex]];
            balances[investors[investorIndex]]=0;
            if(!investors[investorIndex].send(val)) throw;
            investorIndex++;
            returnInvestmentRecursive(value-val);
        } 
        else{
            investorIndex++;
            returnInvestmentRecursive(value);
        }
     }
     
     function getNumInvestors() constant returns(uint){
         return investors.length;
     }
     
     /** do not accept any more investments */
     function close(){
         if(msg.sender==owner)
            closed=true;
     }
     
     /** allow investments */
     function open(){
         if(msg.sender==owner)
            closed=false;
     }
}",False,False,False
0xbFb0Cfd13dbB56c2dbf69EAe33255f0EF1fC7955,FP,True,False,False,"pragma solidity ^0.4.8;

contract testingToken {
    /* Public variables of the token */
    string public standard = ""Token 0.1"";
    string public name = ""Testing Token"";
    string public symbol = ""TT"";
    uint8 public decimals = 2;
    uint256 public totalSupply = 10000;
    
    /*other vars*/
	mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public weiWantedOf;
	mapping (address => uint256) public tokensOfferedOf;
	mapping (address => bool) public tradeActive;
	address public bank;
	uint256 public ethTaxRate = 10;
	uint256 public tokenTaxRate = 5;
	function testingToken() {
		bank = msg.sender;
		balanceOf[msg.sender] = 100000;
	}
	
	event Transfer(address indexed _from, address indexed _to, uint256 _value);
	
	function balanceOf(address _owner) constant returns (uint256 balance) {
	    return balanceOf[_owner];
	}
	
	function transfer(address _to, uint256 _value) returns (bool success) { //give tokens to someone
		if (balanceOf[msg.sender]<_value) return false;
		if (balanceOf[_to]+_value<balanceOf[_to]) return false;
		if (_value<0) return false;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
		Transfer(msg.sender,_to,_value);
		return true;
	}
	
	mapping (address => mapping (address=>uint256)) approvalList;
	function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
		if (balanceOf[_from]<_value) return false;
		if (balanceOf[_to]+_value<balanceOf[_to]) return false;
		if (_value<0) return false;
		if (approvalList[_from][msg.sender]<_value) return false;
		approvalList[_from][msg.sender]-=_value;
		balanceOf[_from] -= _value;
		balanceOf[_to] += (_value*(100-tokenTaxRate))/100;
		balanceOf[bank] += (_value*tokenTaxRate)/100;
		//now check for rounding down which would result in permanent loss of coins
		if ((_value*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
		Transfer(_from,_to,_value);
		return true;
	}
	event Approval(address indexed _owner, address indexed _spender, uint256 _value);
	function approve(address _spender, uint256 _value) returns (bool success) {
	    approvalList[msg.sender][_spender]=_value;
	    Approval(msg.sender,_spender,_value);
	    return true;
	}
	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
	    return approvalList[_owner][_spender];
	}
	
	function offerTrade(uint256 _weiWanted, uint256 _tokensOffered) { //offer the amt of ether you want and the amt of tokens youd give
	    weiWantedOf[msg.sender] = _weiWanted;
	    tokensOfferedOf[msg.sender] = _tokensOffered;
	    tradeActive[msg.sender] = true;
	}
	function agreeToTrade(address _from) payable { //choose a trade to agree to and execute it
	    if (!tradeActive[_from]) throw;
	    if (weiWantedOf[_from]!=msg.value) throw;
	    if (balanceOf[_from]<tokensOfferedOf[_from]) throw;
	    if (!_from.send((msg.value*(100-ethTaxRate))/100)) throw;
	    balanceOf[_from] -= tokensOfferedOf[_from];
	    balanceOf[msg.sender] += (tokensOfferedOf[_from]*(100-tokenTaxRate))/100;
		balanceOf[bank] += (tokensOfferedOf[_from]*tokenTaxRate)/100;
		tradeActive[_from] = false;
		Transfer(_from,msg.sender,tokensOfferedOf[_from]);
		//now check for rounding down which would result in permanent loss of coins
		if ((tokensOfferedOf[_from]*tokenTaxRate)%100 != 0) balanceOf[bank]+=1;
	}
	
	modifier bankOnly {
		if (msg.sender != bank) throw;
		_;
	}
	
	function setTaxes(uint256 _ethTaxRate, uint256 _tokenTaxRate) bankOnly { //the bank can change the tax rates
		ethTaxRate = _ethTaxRate;
		tokenTaxRate = _tokenTaxRate;
	}
	function extractWei(uint256 _wei) bankOnly { //withdraw money from the contract
		if (!msg.sender.send(_wei)) throw;
	}
	function transferOwnership(address _bank) bankOnly { //change owner
		bank = _bank;
	}
	
	function () {
	    throw;
	}
}",False,True,False
0xf2b8e10e7b230cc55040a7a90be75c933719c507,44: arithmetic; 53: time manipulation; 58: time manipulation;,True,False,True,"pragma solidity ^0.4.6;

contract token { function transferFrom(address sender, address receiver, uint amount) returns(bool success){  } }

contract Crowdsale {
    /* if successful, the funds will be retrievable by this address */
    address public beneficiary = 0x003230bbe64eccd66f62913679c8966cf9f41166; 
    /* if the funding goal is not reached, investors may withdraw their funds */
    uint public fundingGoal = 50000000;
    /* the maximum amount of tokens to be sold */
    uint public maxGoal = 394240000; 
    /* how much has been raised by crowdale (in ETH) */
    uint public amountRaised; 
    /* the start date of the crowdsale */
    uint public start = 1487257200; 
    /* the number of tokens already sold */
    uint public tokensSold; 
    /* there are different prices in different time intervals */
    uint[4] public deadlines = [1487260800, 1487865600, 1488470400,1489075200];
    uint[4] public prices = [833333333333333, 909090909090909,952380952380952, 1000000000000000];
    /* the address of the token contract */
    token public tokenReward;
    /* the balances (in ETH) of all investors */
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    /* notifying transfers and the success of the crowdsale*/
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    

    /*  initialization, set the token address */
    function Crowdsale( ) {
        tokenReward = token(0xc378b7e2f88f945be121d80edcbc31bc7259a983);
    }

    /* whenever anyone sends funds to a contract, the corresponding amount of tokens is transfered if the crowdsale started and hasn't been
        closed already and the maxGoal wasn't reached yet.*/
    function () payable{
        uint amount = msg.value;
        uint numTokens = amount / getPrice();
        if (crowdsaleClosed||now<start||tokensSold+numTokens>maxGoal) throw;
        balanceOf[msg.sender] = amount;
        amountRaised += amount;
        tokensSold+=numTokens;
        if(!tokenReward.transferFrom(beneficiary, msg.sender, numTokens)) throw;
        FundTransfer(msg.sender, amount, true);
    }
    
    /* looks up the current token price */
    function getPrice() constant returns (uint256 price){
        for(var i = 0; i < deadlines.length; i++)
            if(now<deadlines[i])
                return prices[i];
        return prices[prices.length-1];//should never be returned, but to be sure to not divide by 0
    }

    modifier afterDeadline() { if (now >= deadlines[deadlines.length-1]) _; }

    /* checks if the goal or time limit has been reached and ends the campaign */
    function checkGoalReached() afterDeadline {
        if (tokensSold >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /* allows the beneficiary and/or the funders to withdraw their funds */
    function safeWithdrawal() afterDeadline {
        // if the goal hasn't been reached, investors may withdraw their funds
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }
        //if the goal has benn reached and the beneficiary himself is the sender, he may withdraw everything
        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                //If we fail to send the funds to beneficiary, unlock funders balance
                fundingGoalReached = false;
            }
        }
    }
}",False,True,True
0x949bEd886c739f1A3273629b3320db0C5024c719,FP,False,True,False,"pragma solidity ^0.4.6;
/*
The AMIS Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.

AMIS contract extends HumanStandardToken, https://github.com/consensys/tokens

.*/
contract Token {

    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}


contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}


contract HEStandardToken is StandardToken {

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }

    /* Public variables of the token */

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract & in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    string public version = 'HE0.2';       //human 0.1 standard. Just an arbitrary versioning scheme.

    function HEStandardToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        ) {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}

// Creates 20,000,000.000000000000000000 AMIS (AMIS) Tokens
contract AMIS is HEStandardToken(20000000000000000, ""AMIS"", 9, ""AMIS"") {}",False,False,False
0xD8912C10681D8B21Fd3742244f44658dBA12264E,54: arithmetic;,False,True,False,"/*
The Pluton Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.

Pluton contract extends HumanStandardToken, https://github.com/consensys/tokens

.*/
contract Token {

    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}


contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}


contract HumanStandardToken is StandardToken {

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }

    /* Public variables of the token */

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract & in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.

    function HumanStandardToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        ) {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}

// Creates 20,000,000.000000000000000000 Pluton (PLU) Tokens
contract Pluton is HumanStandardToken(20000000000000000000000000, ""Pluton"", 18, ""PLU"") {}",False,False,False
0xf77089f2F00fca83501705b711Cbb10a0De77628,FP,False,True,False,"contract Token {

    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}


/*
This implements ONLY the standard functions and NOTHING else.
For a token like you would want to deploy in something like Mist, see HumanStandardToken.sol.

If you deploy this, you won't have anything useful.

Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20
.*/

contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}

/*
This Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.

In other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans.
Imagine coins, currencies, shares, voting weight, etc.
Machine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners.

1) Initial Finite Supply (upon creation one specifies how much is minted).
2) In the absence of a token registry: Optional Decimal, Symbol & Name.
3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred.

.*/

contract HumanStandardToken is StandardToken {

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }

    /* Public variables of the token */

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract & in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.

    function HumanStandardToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        ) {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",False,False,False
0x89d64bc7e46bdc49a89652ae9bb167418cbad62e,FP,False,True,False,"/*
  live: 0x89d64bc7e46bdc49a89652ae9bb167418cbad62e
morden: 0xe379e36671acbcc87ec7b760c07e6e45a1294944
  solc: v0.3.1-2016-04-12-3ad5e82 (optimization)
*/

contract tokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token);
}

contract Token {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function totalSupply() constant returns (uint256 supply);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
    function approveAndCall(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
}

contract SafeAddSub {
    function safeToAdd(uint a, uint b) internal returns (bool) {
        return (a + b > a);
    }

    function safeToSubtract(uint a, uint b) internal returns (bool) {
        return (a >= b);
    }

    function safeAdd(uint a, uint b) internal returns (uint256) {
        if (!safeToAdd(a, b)) throw;
        return a + b;
    }

    function safeSubtract(uint a, uint b) internal returns (uint256) {
        if (!safeToSubtract(a, b)) throw;
        return a - b;
    }
}

contract EthToken is Token, SafeAddSub {
    string public constant name = ""Ether Token Proxy"";
    string public constant symbol = ""ETH"";
    uint8   public constant decimals = 18;
    uint256 public constant baseUnit = 10**18;
    
    mapping (address => uint256) _balanceOf;
    mapping (address => mapping (address => uint256)) _allowance;

    event Deposit(address indexed owner, uint256 amount);
    event Withdrawal(address indexed owner, uint256 amount);

    function totalSupply() constant returns (uint256 supply) {
        return this.balance;
    }
    
    function () {
        deposit();
    }
    
    function deposit() {
        _balanceOf[msg.sender] = safeAdd(_balanceOf[msg.sender], msg.value);
        Deposit(msg.sender, msg.value);
    }
    
    function redeem() {
        withdraw(_balanceOf[msg.sender]);
    }
    
    function withdraw(uint256 _value) returns (bool success) {
        _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);
        if (!msg.sender.send(_value)) {
            if (!msg.sender.call.gas(msg.gas).value(_value)()) throw;
        }
        Withdrawal(msg.sender, _value);
        return true;
    }
    
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return _balanceOf[_owner];
    }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (_to == address(this) || _to == 0) {
            return withdraw(_value);
        } else {
            _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);
            _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);
            Transfer(msg.sender, _to, _value);
        }
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (!safeToSubtract(_allowance[_from][msg.sender], _value)) throw;
        if (_to == address(this) || _to == 0) {
            if (!transferFrom(_from, msg.sender, _value)) throw;
            withdraw(_value);
        } else {
            _balanceOf[_from] = safeSubtract(_balanceOf[_from], _value);
            _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);
            _allowance[_from][msg.sender] = safeSubtract(_allowance[_from][msg.sender], _value);
            Transfer(_from, _to, _value);
        }
        return true;
    }
    
    function approve(address _spender, uint256 _value) returns (bool success) {
        _allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value) returns (bool success) {
        if (approve(_spender, _value)) {
            tokenRecipient(_spender).receiveApproval(msg.sender, _value, this);
            return true;
        }
        throw;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return _allowance[_owner][_spender];
    }
}",False,False,False
0xd9f7cd813983bd89d18015cc3022f7b9b97d26d4,FP,False,True,False,"pragma solidity ^0.4.0;

contract IconomiToken {

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event BlockLockSet(uint256 _value);
  event NewOwner(address _newOwner);

  modifier onlyOwner {
    if (msg.sender == owner) {
      _;
    }
  }

  modifier blockLock {
    if (!isLocked() || msg.sender == owner) {
      _;
    }
  }

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  uint256 public totalSupply;
  string public name;
  uint8 public decimals;
  string public symbol;
  string public version = '0.0.1';
  address public owner;
  uint256 public lockedUntilBlock;

  function IconomiToken(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol,
    uint256 _lockedUntilBlock
    ) {
    balances[msg.sender] = _initialAmount;
    totalSupply = _initialAmount;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
    lockedUntilBlock = _lockedUntilBlock;
    owner = msg.sender;
  }

  /* Approves and then calls the receiving contract */
  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
    //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
    //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
    if(!_spender.call(bytes4(sha3(""receiveApproval(address,uint256,address,bytes)"")), msg.sender, _value, this, _extraData)) { throw; }
    return true;

  }

  function transfer(address _to, uint256 _value) blockLock checkIfToContract(_to) returns (bool success) {

    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }

  }

  function transferFrom(address _from, address _to, uint256 _value) blockLock checkIfToContract(_to) returns (bool success) {

    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }

  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function setBlockLock(uint256 _lockedUntilBlock) onlyOwner returns (bool success) {
    lockedUntilBlock = _lockedUntilBlock;
    BlockLockSet(_lockedUntilBlock);
    return true;
  }

  function isLocked() constant returns (bool success) {
    return lockedUntilBlock > block.number;
  }

  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
}


contract IconomiTokenTest is IconomiToken {
  function IconomiTokenTest(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol,
    uint256 _lockedUntilBlock
    ) IconomiToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol, _lockedUntilBlock) {
  }

  function destruct() onlyOwner {
    selfdestruct(owner);
  }
}",False,False,False
0x384e762dAd922B22a0d06f4D1229582473D2DEe6,70: arithmetic;,False,True,False,"pragma solidity ^0.4.0;

contract IconomiToken {

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event BlockLockSet(uint256 _value);
  event NewOwner(address _newOwner);

  modifier onlyOwner {
    if (msg.sender == owner) {
      _;
    }
  }

  modifier blockLock(address _sender) {
    if (!isLocked() || _sender == owner) {
      _;
    }
  }

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  uint256 public totalSupply;
  string public name;
  uint8 public decimals;
  string public symbol;
  string public version = '0.0.1';
  address public owner;
  uint256 public lockedUntilBlock;

  function IconomiToken(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol,
    uint256 _lockedUntilBlock
    ) {
    balances[msg.sender] = _initialAmount;
    totalSupply = _initialAmount;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
    lockedUntilBlock = _lockedUntilBlock;
    owner = msg.sender;
  }

  /* Approves and then calls the receiving contract */
  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
    //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
    //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
    if(!_spender.call(bytes4(sha3(""receiveApproval(address,uint256,address,bytes)"")), msg.sender, _value, this, _extraData)) { throw; }
    return true;

  }

  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {

    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }

  }

  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {

    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }

  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function setBlockLock(uint256 _lockedUntilBlock) onlyOwner returns (bool success) {
    lockedUntilBlock = _lockedUntilBlock;
    BlockLockSet(_lockedUntilBlock);
    return true;
  }

  function isLocked() constant returns (bool success) {
    return lockedUntilBlock > block.number;
  }

  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
}


contract IconomiTokenTest is IconomiToken {
  function IconomiTokenTest(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol,
    uint256 _lockedUntilBlock
    ) IconomiToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol, _lockedUntilBlock) {
  }

  function destruct() onlyOwner {
    selfdestruct(owner);
  }
}",False,False,False
0xdda65daa223aaae4add64e4e390cda7101c4ab41,FP,False,True,False,"// This contract just saves in the blockchain the intention to withdraw dth
// A Bot will execute this operation in the ETC blockchain and will save
// the result back
contract Owned {
    /// Prevents methods from perfoming any value transfer
    modifier noEther() {if (msg.value > 0) throw; _}
    /// Allows only the owner to call a function
    modifier onlyOwner { if (msg.sender == owner) _ }

    function Owned() { owner = msg.sender;}
    address owner;


    function changeOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }

    function execute(address _dst, uint _value, bytes _data) onlyOwner {
        _dst.call.value(_value)(_data);
    }

    function getOwner() noEther constant returns (address) {
        return owner;
    }
}

contract CrossWhitehatWithdraw is Owned {
    address bot;
    uint price;

    Operation[] public operations;

    modifier onlyBot { if ((msg.sender == owner)||(msg.sender == bot)) _ }

    struct Operation {
        address dth;
        address etcBeneficiary;
        uint percentage;
        uint queryTime;

        uint answerTime;
        uint result;
        bytes32 dthTxHash;
    }

    function CrossWhitehatWithdraw(uint _price, address _bot) Owned() {
        price = _price;
        bot = _bot;
    }

    function withdraw(address _etcBeneficiary, uint _percentage) returns (uint) {
        if (_percentage > 100) throw;
        if (msg.value < price) throw;
        Operation op = operations[operations.length ++];
        op.dth = msg.sender;
        op.etcBeneficiary = _etcBeneficiary;
        op.percentage = _percentage;
        op.queryTime = now;
        Withdraw(op.dth, op.etcBeneficiary, op.percentage, operations.length -1);

        return operations.length -1;
    }

    function setResult(uint _idOperation, uint _result, bytes32 _dthTxHash) onlyBot noEther {
        Operation op = operations[_idOperation];
        if (op.dth == 0) throw;
        op.answerTime = now;
        op.result = _result;
        op.dthTxHash = _dthTxHash;
        WithdrawResult(_idOperation, _dthTxHash, _result);
    }

    function setBot(address _bot) onlyOwner noEther  {
        bot = _bot;
    }

    function getBot() noEther constant returns (address) {
        return bot;
    }

    function setPrice(uint _price) onlyOwner noEther  {
        price = _price;
    }

    function getPrice() noEther constant returns (uint) {
        return price;
    }

    function getOperation(uint _idOperation) noEther constant returns (address dth,
        address etcBeneficiary,
        uint percentage,
        uint queryTime,
        uint answerTime,
        uint result,
        bytes32 dthTxHash)
    {
        Operation op = operations[_idOperation];
        return (op.dth,
                op.etcBeneficiary,
                op.percentage,
                op.queryTime,
                op.answerTime,
                op.result,
                op.dthTxHash);
    }

    function getOperationsNumber() noEther constant returns (uint) {
        return operations.length;
    }

    function() {
        throw;
    }

    function kill() onlyOwner {
        uint i;
        for (i=0; i<operations.length; i++) {
            Operation op = operations[i];
            op.dth =0;
            op.etcBeneficiary =0;
            op.percentage=0;
            op.queryTime=0;
            op.answerTime=0;
            op.result=0;
            op.dthTxHash=0;
        }
        operations.length=0;
        bot=0;
        price=0;
        selfdestruct(owner);
    }

    event Withdraw(address indexed dth, address indexed beneficiary, uint percentage, uint proposal);
    event WithdrawResult(uint indexed proposal, bytes32 indexed hash, uint result);


}",False,False,False
0x9053d234a1ff2290f087a1ca9460e3263121e580,70: reentrancy;,False,True,False,"pragma solidity ^0.4.4;
/**
 * @title Contract for object that have an owner
 */
contract Owned {
    /**
     * Contract owner address
     */
    address public owner;

    /**
     * @dev Store owner on creation
     */
    function Owned() { owner = msg.sender; }

    /**
     * @dev Delegate contract to another person
     * @param _owner is another person address
     */
    function delegate(address _owner) onlyOwner
    { owner = _owner; }

    /**
     * @dev Owner check modifier
     */
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}


/**
 * @title Contract for objects that can be morder
 */
contract Mortal is Owned {
    /**
     * @dev Destroy contract and scrub a data
     * @notice Only owner can kill me
     */
    function kill() onlyOwner
    { suicide(owner); }
}


contract Comission is Mortal {
    address public ledger;
    bytes32 public taxman;
    uint    public taxPerc;

    /**
     * @dev Comission contract constructor
     * @param _ledger Processing ledger contract
     * @param _taxman Tax receiver account
     * @param _taxPerc Processing tax in percent
     */
    function Comission(address _ledger, bytes32 _taxman, uint _taxPerc) {
        ledger  = _ledger;
        taxman  = _taxman;
        taxPerc = _taxPerc;
    }

    /**
     * @dev Refill ledger with comission
     * @param _destination Destination account
     */
    function process(bytes32 _destination) payable returns (bool) {
        // Handle value below 100 isn't possible
        if (msg.value < 100) throw;

        var tax = msg.value * taxPerc / 100; 
        var refill = bytes4(sha3(""refill(bytes32)"")); 
        if ( !ledger.call.value(tax)(refill, taxman)
          || !ledger.call.value(msg.value - tax)(refill, _destination)
           ) throw;
        return true;
    }
}

library CreatorComission {
    function create(address _ledger, bytes32 _taxman, uint256 _taxPerc) returns (Comission)
    { return new Comission(_ledger, _taxman, _taxPerc); }

    function version() constant returns (string)
    { return ""v0.5.0 (a9ea4c6c)""; }

    function abi() constant returns (string)
    { return '[{""constant"":false,""inputs"":[{""name"":""_destination"",""type"":""bytes32""}],""name"":""process"",""outputs"":[{""name"":"""",""type"":""bool""}],""payable"":true,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""kill"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""taxman"",""outputs"":[{""name"":"""",""type"":""bytes32""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""ledger"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_owner"",""type"":""address""}],""name"":""delegate"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""owner"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""taxPerc"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""inputs"":[{""name"":""_ledger"",""type"":""address""},{""name"":""_taxman"",""type"":""bytes32""},{""name"":""_taxPerc"",""type"":""uint256""}],""type"":""constructor""}]'; }
}",False,False,False
0x6ff323e36bfdb20502b23780695f4e77e36cde95,FP,False,True,False,"// Single-owner wallet that keeps ETC and ETH separately and helps preventing
// replaying both, incoming and outgoing transactions.
//
// Once instantiated, the contract sets up three addressed:
// 1. Address to be used to send and receive ETC.  This address will reject all
//    incoming ETH transfers, so its ETH balance will always be zero;
// 2. Address to be used to send and receive ETH.  This address will reject all
//    incoming ETC transfers, so its ETC balance will always be zero;
// 3. Address to be used to receive payments in both flavors of ether or even
//    unsplit replayable ETC+ETH payments.  Ether coming to this address will
//    be automatically classified and distributed among address 1 and address 2.
contract TriWallet {
  // Is set to true in the forked branch and to false in classic branch.
  bool public thisIsFork;

  // Address of ETC subwallet.
  address public etcWallet;

  // Address of ETH subwallet.
  address public ethWallet;

  // Log address of ETC subwallet
  event ETCWalletCreated(address etcWalletAddress);

  // Log address of ETH subwallet
  event ETHWalletCreated(address ethWalletAddress);

  // Instantiate the contract.
  function TriWallet () {
    // Check whether we are in fork branch or in classic one
    thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();
    
    // Create ETC subwallet
    etcWallet = new BranchWallet (msg.sender, !thisIsFork);
    
    // Create ETH subwallet
    ethWallet = new BranchWallet (msg.sender, thisIsFork);
  
    // Log address of ETC subwallet
    ETCWalletCreated (etcWallet);

    // Log address of ETH subwallet
    ETHWalletCreated (ethWallet);
  }

  // Distribute pending balance between ETC and ETH subwallets.
  function distribute () {
    if (thisIsFork) {
      // Send all ETH to ETH subwallet
      if (!ethWallet.send (this.balance)) throw;
    } else {
      // Send all ETC to ETC subwallet
      if (!etcWallet.send (this.balance)) throw;
    }
  }
}

// Wallet contract that operates only in ""right"" branch.
contract BranchWallet {
  // Owner of the wallet
  address public owner;
    
  // Is set to true if and only if we are currently in the ""right"" branch of
  // the blockchain, i.e. the branch this wallet is operating in.
  bool public isRightBranch;

  // Instantiate the contract.
  //
  // @param owner owner of the contract
  // @isRightBranch whether we are currently in the ""right"" branch
  function BranchWallet (address _owner, bool _isRightBranch) {
    owner = _owner;
    isRightBranch = _isRightBranch;
  }

  // Only accept money in ""right"" branch.
  function () {
    if (!isRightBranch) throw;
  }

  // Execute a transaction using money from this wallet.
  //
  // @param to transaction destination
  // @param value transaction value
  // @param data transaction data
  function send (address _to, uint _value) {
    if (!isRightBranch) throw;
    if (msg.sender != owner) throw;
    if (!_to.send (_value)) throw;
  }

  // Execute a transaction using money from this wallet.
  //
  // @param to transaction destination
  // @param value transaction value
  // @param data transaction data
  function execute (address _to, uint _value, bytes _data) {
    if (!isRightBranch) throw;
    if (msg.sender != owner) throw;
    if (!_to.call.value (_value)(_data)) throw;
  }
}

// Simple smart contract that allows anyone to tell where we are currently in the
// ""right"" branch of blockchain.
contract BranchSender {
  // Is set to true if and only if we are currently in the ""right"" branch of
  // the blockchain.
  bool public isRightBranch;
}",False,True,False
0xE197529709D7cBaf31756C6d9B8742718E17FCA5,FP,False,True,False,"contract owned {
    function owned() {
        owner = msg.sender;
    }

    address public owner;

    modifier onlyowner { if (msg.sender != owner) throw; _ }

    event OwnershipTransfer(address indexed from, address indexed to);

    function transferOwnership(address to) public onlyowner {
        owner = to;
        OwnershipTransfer(msg.sender, to);
    }
}
// Token standard API
// https://github.com/ethereum/EIPs/issues/20
contract ERC20 {
    function totalSupply() constant returns (uint supply);
    function balanceOf(address who) constant returns (uint value);
    function allowance(address owner, address spender) constant returns (uint _allowance);
    function transfer(address to, uint value) returns (bool ok);
    function transferFrom(address from, address to, uint value) returns (bool ok);
    function approve(address spender, uint value) returns (bool ok);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}


contract Order is owned {
    ERC20 public token;
    uint public weiPerToken;
    uint public decimalPlaces;

    function Order(address _token, uint _weiPerToken, uint _decimalPlaces) {
        token = ERC20(_token);
        weiPerToken = _weiPerToken;
        decimalPlaces = _decimalPlaces;
    }

    function sendRobust(address to, uint value) internal {
        if (!to.send(value)) {
            if (!to.call.value(value)()) throw;
        }
    }

    function min(uint a, uint b) internal returns (uint) {
        if (a <= b) {
            return a;
        } else {
            return b;
        }
    }

    function getTransferableBalance(address who) internal returns (uint amount) {
        uint allowance = token.allowance(msg.sender, address(this));
        uint balance = token.balanceOf(msg.sender);

        amount = min(min(allowance, balance), numTokensAbleToPurchase());

        return amount;
    }

    function numTokensAbleToPurchase() constant returns (uint) {
        return (this.balance / weiPerToken) * decimalPlaces;
    }

    event OrderFilled(address _from, uint numTokens);

    // Fills or partially fills the order.
    function _fillOrder(address _from, uint numTokens) internal returns (bool) {
        if (numTokens == 0) throw;
        if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;

        if (!token.transferFrom(_from, owner, numTokens)) return false;
        sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
        OrderFilled(_from, numTokens);
        return true;
    }

    function fillOrder(address _from, uint numTokens) public returns (bool) {
        return _fillOrder(_from, numTokens);
    }

    // Simpler call signature that uses `msg.sender`
    function fillMyOrder(uint numTokens) public returns (bool) {
        return _fillOrder(msg.sender, numTokens);
    }

    // Simpler call signature that defaults to the account allowance.
    function fillTheirOrder(address who) public returns (bool) {
        return _fillOrder(who, getTransferableBalance(who));
    }

    // Simpler call signature that uses `msg.sender` and the current approval
    // value.
    function fillOrderAuto() public returns (bool) {
        return _fillOrder(msg.sender, getTransferableBalance(msg.sender));
    }

    // Even simpler call signature that tries to transfer as many as possible.
    function () {
        // allow receipt of funds
        if (msg.value > 0) {
            return;
        } else {
            fillOrderAuto();
        }
    }

    // Cancel the order, returning all funds to the owner.
    function cancel() onlyowner {
        selfdestruct(owner);
    }
}",False,True,False
0x35bd607db942fe1f10ce12b309e3a67e16660fe1,47: reentrancy; 48: reentrancy; 55: reentrancy; 64: reentrancy;,False,True,False,"pragma solidity ^0.4.9;

contract OrangeGov_Main {
    address public currentContract;
    
	mapping(address=>mapping(string=>bool)) permissions;
	mapping(address=>mapping(string=>bool)) userStatuses;
	mapping(string=>address) contractIDs;
	mapping(string=>bool) contractIDExists;
	address[] contractArray; //the contracts in the above 2 tables
	function OrangeGov_Main () {
	    permissions[msg.sender][""all""]=true;
	}
	function getHasPermission(address user, string permissionName, string userStatusAllowed) returns (bool hasPermission){ //for use between contracts
	    return permissions[msg.sender][permissionName]||permissions[msg.sender][""all""]||userStatuses[msg.sender][userStatusAllowed];
	}
	function getContractByID(string ID) returns (address addr,bool exists){ //for use between contracts
	    return (contractIDs[ID],contractIDExists[ID]);
	}
	
    modifier permissionRequired(string permissionName,string userStatusAllowed) {
        _; //code will be run; code MUST have variable permissionName(name of permission) and userStatusAllowed(a certain user statu is the only thing necessary)
        if (getHasPermission(msg.sender,permissionName,userStatusAllowed)){
            throw;
        }
    }
    
    function removeFromContractIDArray(address contractToRemove) {
        for (uint x=0;x<contractArray.length-1;x++) {
            if (contractArray[x]==contractToRemove) {
                contractArray[x]=contractArray[contractArray.length-1];
	            contractArray.length--;
	            return;
            }
        }
    }
    
	function addContract(string ID,bytes code) permissionRequired(""addContract"",""""){
	    address addr;
        assembly {
            addr := create(0,add(code,0x20), mload(code))
            jumpi(invalidJumpLabel,iszero(extcodesize(addr)))
        }
        address oldAddr = contractIDs[ID];
	    contractIDs[ID]=addr;
	    contractIDExists[ID]=true;
	    oldAddr.call.gas(msg.gas)(bytes4(sha3(""changeCurrentContract(address)"")),addr); //if there was a previous contract, tell it the new one's address
	    addr.call.gas(msg.gas)(bytes4(sha3(""tellPreviousContract(address)"")),oldAddr); //feed it the address of the previous contract
	    removeFromContractIDArray(addr);
	    contractArray.length++;
	    contractArray[contractArray.length-1]=addr;
	}
	function removeContract(string ID) permissionRequired(""removeContract"",""""){
	    contractIDExists[ID]=false;
	    contractIDs[ID].call.gas(msg.gas)(bytes4(sha3(""changeCurrentContract(address)"")),currentContract); //make sure people using know it's out of service
	    removeFromContractIDArray(contractIDs[ID]);
	}
	function update(bytes code) permissionRequired(""update"",""""){
	    address addr;
        assembly {
            addr := create(0,add(code,0x20), mload(code))
            jumpi(invalidJumpLabel,iszero(extcodesize(addr)))
        }
        addr.call.gas(msg.gas)(bytes4(sha3(""tellPreviousContract(address)"")),currentContract);
        currentContract = addr;
        for (uint x=0;x<contractArray.length-1;x++) {
            contractArray[x].call.gas(msg.gas)(bytes4(sha3(""changeMain(address)"")),currentContract);
        }
	}
	function tellPreviousContract(address prev) { //called in the update process
	    
	}
	function spendEther(address addr, uint256 weiAmt) permissionRequired(""spendEther"",""""){
	    if (!addr.send(weiAmt)) throw;
	}
	function givePermission(address addr, string permission) permissionRequired(""givePermission"",""""){
	    if (getHasPermission(msg.sender,permission,"""")){
	        permissions[addr][permission]=true;
	    }
	}
	function removePermission(address addr, string permission) permissionRequired(""removePermission"",""""){
	    permissions[addr][permission]=false;
	}
}",False,False,False
0x33098a5e8f5e932831434748cdad425487b9aaf1,69: reentrancy;,False,True,False,"pragma solidity ^0.4.4;
/**
 * @title Contract for object that have an owner
 */
contract Owned {
    /**
     * Contract owner address
     */
    address public owner;

    /**
     * @dev Store owner on creation
     */
    function Owned() { owner = msg.sender; }

    /**
     * @dev Delegate contract to another person
     * @param _owner is another person address
     */
    function delegate(address _owner) onlyOwner
    { owner = _owner; }

    /**
     * @dev Owner check modifier
     */
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}

/**
 * @title Contract for objects that can be morder
 */
contract Mortal is Owned {
    /**
     * @dev Destroy contract and scrub a data
     * @notice Only owner can kill me
     */
    function kill() onlyOwner
    { suicide(owner); }
}


contract Comission is Mortal {
    address public ledger;
    bytes32 public taxman;
    uint    public taxPerc;

    /**
     * @dev Comission contract constructor
     * @param _ledger Processing ledger contract
     * @param _taxman Tax receiver account
     * @param _taxPerc Processing tax in percent
     */
    function Comission(address _ledger, bytes32 _taxman, uint _taxPerc) {
        ledger  = _ledger;
        taxman  = _taxman;
        taxPerc = _taxPerc;
    }

    /**
     * @dev Refill ledger with comission
     * @param _destination Destination account
     */
    function process(bytes32 _destination) payable returns (bool) {
        // Handle value below 100 isn't possible
        if (msg.value < 100) throw;

        var tax = msg.value * taxPerc / 100; 
        var refill = bytes4(sha3(""refill(bytes32)"")); 
        if ( !ledger.call.value(tax)(refill, taxman)
          || !ledger.call.value(msg.value - tax)(refill, _destination)
           ) throw;
        return true;
    }
}

contract Invoice is Mortal {
    address   public signer;
    uint      public closeBlock;

    Comission public comission;
    string    public description;
    bytes32   public beneficiary;
    uint      public value;

    /**
     * @dev Offer type contract
     * @param _comission Comission handler address
     * @param _description Deal description
     * @param _beneficiary Beneficiary account
     * @param _value Deal value
     */
    function Invoice(address _comission,
                     string  _description,
                     bytes32 _beneficiary,
                     uint    _value) {
        comission   = Comission(_comission);
        description = _description;
        beneficiary = _beneficiary;
        value       = _value;
    }

    /**
     * @dev Call me to withdraw money
     */
    function withdraw() onlyOwner {
        if (closeBlock != 0) {
            if (!comission.process.value(value)(beneficiary)) throw;
        }
    }

    /**
     * @dev Payment fallback function
     */
    function () payable {
        // Condition check
        if (msg.value != value
           || closeBlock != 0) throw;

        // Store block when closed
        closeBlock = block.number;
        signer = msg.sender;
        PaymentReceived();
    }
    
    /**
     * @dev Payment notification
     */
    event PaymentReceived();
}

library CreatorInvoice {
    function create(address _comission, string _description, bytes32 _beneficiary, uint256 _value) returns (Invoice)
    { return new Invoice(_comission, _description, _beneficiary, _value); }

    function version() constant returns (string)
    { return ""v0.5.0 (a9ea4c6c)""; }

    function abi() constant returns (string)
    { return '[{""constant"":true,""inputs"":[],""name"":""signer"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""beneficiary"",""outputs"":[{""name"":"""",""type"":""bytes32""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""comission"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""withdraw"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""value"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""kill"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_owner"",""type"":""address""}],""name"":""delegate"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""description"",""outputs"":[{""name"":"""",""type"":""string""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""closeBlock"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""owner"",""outputs"":[{""name"":"""",""type"":""address""}],""payable"":false,""type"":""function""},{""inputs"":[{""name"":""_comission"",""type"":""address""},{""name"":""_description"",""type"":""string""},{""name"":""_beneficiary"",""type"":""bytes32""},{""name"":""_value"",""type"":""uint256""}],""type"":""constructor""},{""payable"":true,""type"":""fallback""},{""anonymous"":false,""inputs"":[],""name"":""PaymentReceived"",""type"":""event""}]'; }
}",False,False,False
0x45d147c800d401350b24fc1cd5fbc98040b177c8,112: reentrancy; 125: reentrancy;,False,True,False,"pragma solidity ^0.4.2;
contract Token{

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  event Approval(address indexed _onwer,address indexed _spender, uint256 _value);

  function totalSupply() constant returns(uint256 totalSupply){}

  function balanceOf(address _owner) constant returns (uint256 balance){}

  function transfer(address _to, uint256 _value) constant returns(bool success){}

  function transferFrom(address _from, address _to, uint256 _value) constant returns (bool success){}

  function approve(address _spender, uint256 _value) constant returns(bool success){}

  function allowance(address _owner, uint _spender) constant returns(uint256 remaining){}

}

contract StandardToken is Token{
  uint256 public totalSupply;
  mapping(address => uint256)balances;
  mapping(address =>mapping(address=>uint256))allowed;


  function transfer(address _to, uint256 _value)constant returns(bool success){
    if(balances[msg.sender]>_value && balances[_to]+_value>balances[_to]) {
      balances[msg.sender] -= _value;
      balances[_to] +=_value;
      Transfer(msg.sender,_to,_value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value)constant returns(bool success){
    if(balances[_from]>_value && allowed[_from][msg.sender]>_value && balances[_to]+_value>balances[_to]){
      balances[_from]-=_value;
      allowed[_from][msg.sender]-=_value;
      balances[_to]-=_value;
      Transfer(_from,_to,_value);
      return true;
    } else {
      return false;
    }
  }

  function approve(address _spender, uint256 _value)constant returns (bool success){
    allowed[msg.sender][_spender]=_value;
    Approval(msg.sender,_spender,_value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint256 balance){
    return balances[_owner];
  }

  function allowance(address _onwer,address _spender) constant returns(uint256 allowance){
    return allowed[_onwer][_spender];
  }
}

contract NinjaToken is StandardToken{
    string public name =""NinjaToken"";
    string public version=""0.0.1"";
    uint public decimals = 18;
    mapping(address=>string) public commit;
    
    address public founder;
    address public admin; 
    bool public fundingLock=true;  // indicate funding status activate or inactivate
    address public fundingAccount;
    uint public startBlock;        //Crowdsale startBlock
    uint public blockDuration;     // Crowdsale blocks duration
    uint public fundingExchangeRate;
    uint public price=10;
    bool public transferLock=false;  // indicate transfer status activate or inactivate

    event Funding(address sender, uint256 eth);
    event Buy(address buyer, uint256 eth);
    
    function NinjaToken(address _founder,address _admin){
        founder=_founder;
        admin=_admin;
    }
    
    function changeFunder(address _founder,address _admin){
        if(msg.sender!=admin) throw;
        founder=_founder;
        admin=_admin;        
    }
    
    function setFundingLock(bool _fundinglock,address _fundingAccount){
        if(msg.sender!=founder) throw;
        fundingLock=_fundinglock;
        fundingAccount=_fundingAccount;
    }
    
    function setFundingEnv(uint _startBlock, uint _blockDuration,uint _fundingExchangeRate){
        if(msg.sender!=founder) throw;
        startBlock=_startBlock;
        blockDuration=_blockDuration;
        fundingExchangeRate=_fundingExchangeRate;
    }
    
    function funding() payable {
        if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
        if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
        if(!fundingAccount.call.value(msg.value)()) throw;
        balances[msg.sender]+=msg.value*fundingExchangeRate;
        Funding(msg.sender,msg.value);
    }
    
    function setPrice(uint _price,bool _transferLock){
        if(msg.sender!=founder) throw;
        price=_price;
        transferLock=_transferLock;
    }
    
    function buy(string _commit) payable{
        if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
        if(!fundingAccount.call.value(msg.value)()) throw;
        balances[msg.sender]+=msg.value*price;
        commit[msg.sender]=_commit;
        Buy(msg.sender,msg.value);
    }
    
    function transfer(address _to, uint256 _value)constant returns(bool success){
        if(transferLock) throw;
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value)constant returns(bool success){
        if(transferLock) throw;
        return super.transferFrom(_from, _to, _value);
    }

}",False,False,True
0xaf0f6a53269fc9dbbd9da9f11c368d36b7a60006,196: reentrancy;,False,True,False,"//last compiled with soljson-v0.3.5-2016-07-21-6610add

contract Etheropt {

  struct Position {
    mapping(uint => int) positions;
    int cash;
    bool expired;
    bool hasPosition;
  }
  uint public expiration;
  string public underlying;
  uint public margin;
  uint public realityID;
  bytes32 public factHash;
  address public ethAddr;
  mapping(uint => int) options;
  uint public numOptions;
  bool public expired;
  mapping(address => Position) positions;
  uint public numPositions;
  uint public numPositionsExpired;
  struct Account {
    address user;
    int capital;
  }
  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills
  struct MarketMaker {
    address user;
    string server;
  }
  mapping(uint => MarketMaker) marketMakers; //starts at 1
  uint public numMarketMakers = 0;
  mapping(address => uint) marketMakerIDs;
  mapping(uint => Account) accounts;
  uint public numAccounts;
  mapping(address => uint) accountIDs; //starts at 1

  //events
  event Deposit(address indexed user, uint amount, int balance); //balance is balance after deposit
  event Withdraw(address indexed user, uint amount, int balance); //balance is balance after withdraw
  event NewMarketMaker(address indexed user, string server);
  event Expire(address indexed caller, address indexed user); //user is the account that was expired
  event OrderMatchFailure(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);
  event OrderMatch(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);

  function Etheropt(uint expiration_, string underlying_, uint margin_, uint realityID_, bytes32 factHash_, address ethAddr_, int[] strikes_) {
    expiration = expiration_;
    underlying = underlying_;
    margin = margin_;
    realityID = realityID_;
    factHash = factHash_;
    ethAddr = ethAddr_;
    for (uint i=0; i < strikes_.length; i++) {
      if (numOptions<20) {
        uint optionID = numOptions++;
        options[optionID] = strikes_[i];
      }
    }
  }

  function getAccountID(address user) constant returns(uint) {
    return accountIDs[user];
  }

  function getAccount(uint accountID) constant returns(address) {
    return accounts[accountID].user;
  }

  function addFunds() {
    if (accountIDs[msg.sender]>0) {
      accounts[accountIDs[msg.sender]].capital += int(msg.value);
    } else {
      uint accountID = ++numAccounts;
      accounts[accountID].user = msg.sender;
      accounts[accountID].capital += int(msg.value);
      accountIDs[msg.sender] = accountID;
    }
    Deposit(msg.sender, msg.value, accounts[accountIDs[msg.sender]].capital);
  }

  function withdrawFunds(uint amount) {
    if (accountIDs[msg.sender]>0) {
      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
        accounts[accountIDs[msg.sender]].capital -= int(amount);
        msg.sender.call.value(amount)();
        Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
      }
    }
  }

  function getFunds(address user, bool onlyAvailable) constant returns(int) {
    if (accountIDs[user]>0) {
      if (onlyAvailable == false) {
        return accounts[accountIDs[user]].capital;
      } else {
        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0);
      }
    } else {
      return 0;
    }
  }

  function getFundsAndAvailable(address user) constant returns(int, int) {
    return (getFunds(user, false), getFunds(user, true));
  }

  function marketMaker(string server) {
    if (msg.value>0) throw;
    if (marketMakerIDs[msg.sender]>0) {
      marketMakers[marketMakerIDs[msg.sender]].server = server;
    } else {
      int funds = getFunds(marketMakers[i].user, false);
      uint marketMakerID = 0;
      if (numMarketMakers<6) {
        marketMakerID = ++numMarketMakers;
      } else {
        for (uint i=2; i<=numMarketMakers; i++) {
          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {
            marketMakerID = i;
          }
        }
      }
      if (marketMakerID>0) {
        marketMakerIDs[marketMakers[marketMakerID].user] = 0;
        marketMakers[marketMakerID].user = msg.sender;
        marketMakers[marketMakerID].server = server;
        marketMakerIDs[msg.sender] = marketMakerID;
        NewMarketMaker(msg.sender, server);
      } else {
        throw;
      }
    }
  }

  function getMarketMakers() constant returns(string, string, string, string, string, string) {
    string[] memory servers = new string[](6);
    for (uint i=1; i<=numMarketMakers; i++) {
      servers[i-1] = marketMakers[i].server;
    }
    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);
  }

  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {
    int[] memory funds = new int[](6);
    for (uint i=1; i<=numMarketMakers; i++) {
      funds[i-1] = getFunds(marketMakers[i].user, false);
    }
    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);
  }

  function getOptionChain() constant returns (uint, string, uint, uint, bytes32, address) {
    return (expiration, underlying, margin, realityID, factHash, ethAddr);
  }

  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {
    uint[] memory optionIDs = new uint[](20);
    int[] memory strikes_ = new int[](20);
    int[] memory positions_ = new int[](20);
    int[] memory cashes = new int[](20);
    uint z = 0;
    if (expired == false) {
      for (uint optionID=0; optionID<numOptions; optionID++) {
        optionIDs[z] = optionID;
        strikes_[z] = options[optionID];
        positions_[z] = positions[user].positions[optionID];
        cashes[z] = positions[user].cash;
        z++;
      }
    }
    return (optionIDs, strikes_, positions_, cashes);
  }

  function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
    if (expired == false) {
      if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
        uint lastAccount = numAccounts;
        if (accountID==0) {
          accountID = 1;
        } else {
          lastAccount = accountID;
        }
        for (accountID=accountID; accountID<=lastAccount; accountID++) {
          if (positions[accounts[accountID].user].expired == false) {
            int result = positions[accounts[accountID].user].cash / 1000000000000000000;
            for (uint optionID=0; optionID<numOptions; optionID++) {
              int moneyness = getMoneyness(options[optionID], uint(value), margin);
              result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
            }
            positions[accounts[accountID].user].expired = true;
            uint amountToSend = uint(accounts[accountID].capital + result);
            accounts[accountID].capital = 0;
            if (positions[accounts[accountID].user].hasPosition==true) {
              numPositionsExpired++;
            }
            accounts[accountID].user.call.value(amountToSend)();
            Expire(msg.sender, accounts[accountID].user);
          }
        }
        if (numPositionsExpired == numPositions) {
          expired = true;
        }
      }
    }
  }

  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {
    if (strike>=0) { //call
      if (settlement>uint(strike)) {
        if (settlement-uint(strike)<margin) {
          return int(settlement-uint(strike));
        } else {
          return int(margin);
        }
      } else {
        return 0;
      }
    } else { //put
      if (settlement<uint(-strike)) {
        if (uint(-strike)-settlement<margin) {
          return int(uint(-strike)-settlement);
        } else {
          return int(margin);
        }
      } else {
        return 0;
      }
    }
  }

  function orderMatchTest(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, uint value, int matchSize) constant returns(bool) {
    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+int(value)+getMaxLossAfterTrade(sender, optionID, matchSize, -matchSize * int(price))>0) {
      return true;
    }
    return false;
  }

  function orderMatch(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {
    addFunds();
    bytes32 hash = sha256(optionID, price, size, orderID, blockExpires);
    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionID, matchSize, -matchSize * int(price))>0) {
      if (positions[msg.sender].hasPosition == false) {
        positions[msg.sender].hasPosition = true;
        numPositions++;
      }
      if (positions[addr].hasPosition == false) {
        positions[addr].hasPosition = true;
        numPositions++;
      }
      positions[msg.sender].positions[optionID] += matchSize;
      positions[msg.sender].cash -= matchSize * int(price);
      positions[addr].positions[optionID] -= matchSize;
      positions[addr].cash += matchSize * int(price);
      orderFills[hash] -= matchSize;
      OrderMatch(msg.sender, matchSize, addr, size, optionID, price);
    } else {
      OrderMatchFailure(msg.sender, matchSize, addr, size, optionID, price);
    }
  }

  function getMaxLossAfterTrade(address user, uint optionID, int positionChange, int cashChange) constant returns(int) {
    bool maxLossInitialized = false;
    int maxLoss = 0;
    if (positions[user].expired == false && numOptions>0) {
      for (uint s=0; s<numOptions; s++) {
        int pnl = positions[user].cash / 1000000000000000000;
        pnl += cashChange / 1000000000000000000;
        uint settlement = 0;
        if (options[s]<0) {
          settlement = uint(-options[s]);
        } else {
          settlement = uint(options[s]);
        }
        pnl += moneySumAtSettlement(user, optionID, positionChange, settlement);
        if (pnl<maxLoss || maxLossInitialized==false) {
          maxLossInitialized = true;
          maxLoss = pnl;
        }
        pnl = positions[user].cash / 1000000000000000000;
        pnl += cashChange / 1000000000000000000;
        settlement = 0;
        if (options[s]<0) {
          if (uint(-options[s])>margin) {
            settlement = uint(-options[s])-margin;
          } else {
            settlement = 0;
          }
        } else {
          settlement = uint(options[s])+margin;
        }
        pnl += moneySumAtSettlement(user, optionID, positionChange, settlement);
        if (pnl<maxLoss) {
          maxLoss = pnl;
        }
      }
    }
    return maxLoss;
  }

  function moneySumAtSettlement(address user, uint optionID, int positionChange, uint settlement) internal returns(int) {
    int pnl = 0;
    for (uint j=0; j<numOptions; j++) {
      pnl += positions[user].positions[j] * getMoneyness(options[j], settlement, margin) / 1000000000000000000;
      if (j==optionID) {
        pnl += positionChange * getMoneyness(options[j], settlement, margin) / 1000000000000000000;
      }
    }
    return pnl;
  }

  function min(uint a, uint b) constant returns(uint) {
    if (a<b) {
      return a;
    } else {
      return b;
    }
  }
}",False,False,False
0xc8d9890df1ff2e87be05e9edab3cca26f054b611,16: unchecked; 22: unchecked; 23: unchecked;,False,True,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract SellETCSafely {
    // fork oracle to use
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    // recipient of the 1 % fee on the ETC side
    address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;

    function split(address ethDestination, address etcDestination) {
        if (amIOnTheFork.forked()) {
            // The following happens on the forked chain:
            // 100 % is forwarded to the provided destination for ETH
            ethDestination.call.value(msg.value)();
        } else {
            // The following happens on the classic chain:
            // 1 % is forwarded to the fee recipient
            // 99 % is forwarded to the provided destination for ETC
            uint fee = msg.value / 100;
            feeRecipient.send(fee);
            etcDestination.call.value(msg.value - fee)();
        }
    }

    function () {
        throw;  // do not accept value transfers
    }
}",False,False,False
0x5f0d0c4c159970fda5adc93a6b7f17706fd3255c,16: unchecked; 22: unchecked; 23: unchecked;,False,True,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract SellETCSafely {
    // fork oracle to use
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);
    
    // recipient of the 1 % fee on the ETC side
    address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;
    
    function split(address ethDestination, address etcDestination) {
        if (amIOnTheFork.forked()) {
            // The following happens on the forked chain:
            // 100 % is forwarded to the provided destination for ETH
            ethDestination.call.value(msg.value);
        } else {
            // The following happens on the classic chain:
            // 1 % is forwarded to the fee recipient
            // 99 % is forwarded to the provided destination for ETC
            uint fee = msg.value / 100;
            feeRecipient.send(fee);
            etcDestination.call.value(msg.value - fee)();
        }
    }
    
    function () {
        throw;  // do not accept value transfers
    }
}",False,True,False
0x80f1f62b8b365c5326100d462d8570771b8d0e57,49: arithmetic;,False,True,False,"contract DaoChallenge
{
	modifier noEther() {if (msg.value > 0) throw; _}

	modifier onlyOwner() {if (owner != msg.sender) throw; _}

	event notifySellToken(uint256 n, address buyer);
	event notifyRefundToken(uint256 n, address tokenHolder);
	event notifyTranferToken(uint256 n, address sender, address recipient);
	event notifyTerminate(uint256 finalBalance);

	/* This creates an array with all balances */
  mapping (address => uint256) public tokenBalanceOf;

	uint256 constant tokenPrice = 1000000000000000; // 1 finney

	// Owner of the challenge; a real DAO doesn't an owner.
	address owner;

	function DaoChallenge () {
		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.
	}

	function () {
		address sender = msg.sender;
		uint256 amount = msg.value;

		// No fractional tokens:
		if (amount % tokenPrice != 0) {
			throw;
		}
		tokenBalanceOf[sender] += amount / tokenPrice;
		notifySellToken(amount, sender);
	}

	// This uses call.value()() rather than send(), but only sends to msg.sender
	function withdrawEtherOrThrow(uint256 amount) private {
		bool result = msg.sender.call.value(amount)();
		if (!result) {
			throw;
		}
	}

	function refund() noEther {
		address sender = msg.sender;
		uint256 tokenBalance = tokenBalanceOf[sender];
		if (tokenBalance == 0) { throw; }
		tokenBalanceOf[sender] = 0;
		withdrawEtherOrThrow(tokenBalance * tokenPrice);
		notifyRefundToken(tokenBalance, sender);
	}

	function transfer(address recipient, uint256 tokens) noEther {
		address sender = msg.sender;

		if (tokenBalanceOf[sender] < tokens) throw;
		if (tokenBalanceOf[recipient] + tokens < tokenBalanceOf[recipient]) throw; // Check for overflows
		tokenBalanceOf[sender] -= tokens;
		tokenBalanceOf[recipient] += tokens;
		notifyTranferToken(tokens, sender, recipient);
	}

	// The owner of the challenge can terminate it. Don't use this in a real DAO.
	function terminate() noEther onlyOwner {
		notifyTerminate(this.balance);
		suicide(owner);
	}
}",False,True,False
0x08d698358b31ca6926e329879db9525504802abf,49: arithmetic;,False,True,False,"contract DaoChallenge
{
	modifier noEther() {if (msg.value > 0) throw; _}

	modifier onlyOwner() {if (owner != msg.sender) throw; _}

	event notifySellToken(uint256 n, address buyer);
	event notifyRefundToken(uint256 n, address tokenHolder);
	event notifyTranferToken(uint256 n, address sender, address recipient);
	event notifyTerminate(uint256 finalBalance);

	/* This creates an array with all balances */
  mapping (address => uint256) public tokenBalanceOf;

	uint256 constant tokenPrice = 1000000000000000; // 1 finney

	// Owner of the challenge; a real DAO doesn't an owner.
	address owner;

	function DaoChallenge () {
		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.
	}

	function () {
		address sender = msg.sender;
		uint256 amount = msg.value;

		// No fractional tokens:
		if (amount % tokenPrice != 0) {
			throw;
		}
		tokenBalanceOf[sender] += amount / tokenPrice;
		notifySellToken(amount, sender);
	}

	// This uses call.value()() rather than send(), but only sends to msg.sender
	function withdrawEtherOrThrow(uint256 amount) {
		bool result = msg.sender.call.value(amount)();
		if (!result) {
			throw;
		}
	}

	function refund() noEther {
		address sender = msg.sender;
		uint256 tokenBalance = tokenBalanceOf[sender];
		if (tokenBalance == 0) { throw; }
		tokenBalanceOf[sender] = 0;
		withdrawEtherOrThrow(tokenBalance * tokenPrice);
		notifyRefundToken(tokenBalance, sender);
	}

	function transfer(address recipient, uint256 tokens) noEther {
		address sender = msg.sender;

		if (tokenBalanceOf[sender] < tokens) throw;
		if (tokenBalanceOf[recipient] + tokens < tokenBalanceOf[recipient]) throw; // Check for overflows
		tokenBalanceOf[sender] -= tokens;
		tokenBalanceOf[recipient] += tokens;
		notifyTranferToken(tokens, sender, recipient);
	}

	// The owner of the challenge can terminate it. Don't use this in a real DAO.
	function terminate() noEther onlyOwner {
		notifyTerminate(this.balance);
		suicide(owner);
	}
}",False,True,False
0xc5B2508E878af367Ba4957BDBEb2bBc6DA5BB349,11: unchecked; 22: unchecked; 23: unchecked;,False,True,False,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract Ethsplit {

    function split(address ethAddress, address etcAddress) {

        if (amIOnTheFork.forked()) {
            // if on the forked chain send ETH to ethAddress
            ethAddress.call.value(msg.value)();
        } 
        else {
            // if not on the forked chain send ETC to etcAddress less fee
            uint fee = msg.value/100;
            fees.send(fee);
            etcAddress.call.value(msg.value-fee)();
        }
    }

    // Reject deposits to the contract
    function () {
        throw;  
    }

    // AmIOnTheFork oracle by _tr
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);
    address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;
}",False,False,False
0x845f74aac51148bdd4ef6aed29822940c025a3a2,21: unchecked; 31: unchecked;,False,True,False,"contract one {
    
    address public deployer;
    address public targetAddress;
    
    
    modifier execute {
        if (msg.sender == deployer) {
            _
        }
    }
    
    
    function one() {
        deployer = msg.sender;
        targetAddress = 0x6a92b2804EaeF97f222d003C94F683333e330693;
    }
    
    
    function forward() {    
        targetAddress.call.gas(200000).value(this.balance)();
    }
    
    
    function() {
        forward();
    }
    
    
    function sendBack() execute {
        deployer.send(this.balance);
    }
    
    
}",False,False,False
0xc9c1bfb27e97531ecfe005faa2b2ed4828b08a0b,75: unchecked; 85: unchecked;,False,False,True,"contract AmIOnTheFork{
  function forked() constant returns(bool);
}

contract Etherandom {
  address owner;
  uint seedPrice;
  uint execPrice;
  uint gasPrice;
  uint minimumGasLimit;
  mapping(address => uint) seedc;
  mapping(address => uint) execc;

  address constant AmIOnTheForkAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;

  event SeedLog(address sender, bytes32 seedID, uint gasLimit);
  event ExecLog(address sender, bytes32 execID, uint gasLimit, bytes32 serverSeedHash, bytes32 clientSeed, uint cardinality);

  function Etherandom() {
    owner = msg.sender;
  }

  modifier onlyAdmin {
    if (msg.sender != owner) throw;
    _
  }

  function getSeedPrice() public constant returns (uint _seedPrice) {
    return seedPrice;
  }

  function getExecPrice() public constant returns (uint _execPrice) {
    return execPrice;
  }

  function getGasPrice() public constant returns (uint _gasPrice) {
    return gasPrice;
  }

  function getMinimumGasLimit() public constant returns (uint _minimumGasLimit) {
    return minimumGasLimit;
  }

  function getSeedCost(uint _gasLimit) public constant returns (uint _cost) {
    uint cost = seedPrice + (_gasLimit * gasPrice);
    return cost;
  }

  function getExecCost(uint _gasLimit) public constant returns (uint _cost) {
    uint cost = execPrice + (_gasLimit * gasPrice);
    return cost;
  }

  function kill() onlyAdmin {
    selfdestruct(owner);
  }

  function setSeedPrice(uint newSeedPrice) onlyAdmin {
    seedPrice = newSeedPrice;
  }

  function setExecPrice(uint newExecPrice) onlyAdmin {
    execPrice = newExecPrice;
  }

  function setGasPrice(uint newGasPrice) onlyAdmin {
    gasPrice = newGasPrice;
  }

  function setMinimumGasLimit(uint newMinimumGasLimit) onlyAdmin {
    minimumGasLimit = newMinimumGasLimit;
  }

  function withdraw(address addr) onlyAdmin {
    addr.send(this.balance);
  }

  function () {
    throw;
  }

  modifier costs(uint cost) {
    if (msg.value >= cost) {
      uint diff = msg.value - cost;
      if (diff > 0) msg.sender.send(diff);
      _
    } else throw;
  }

  function seed() returns (bytes32 _id) {
    return seedWithGasLimit(getMinimumGasLimit());
  }

  function seedWithGasLimit(uint _gasLimit) costs(getSeedCost(_gasLimit)) returns (bytes32 _id) {
    if (_gasLimit > block.gaslimit || _gasLimit < getMinimumGasLimit()) throw;
    bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();
    _id = sha3(forkFlag, this, msg.sender, seedc[msg.sender]);
    seedc[msg.sender]++;
    SeedLog(msg.sender, _id, _gasLimit);
    return _id;
  }

  function exec(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality) returns (bytes32 _id) {
    return execWithGasLimit(_serverSeedHash, _clientSeed, _cardinality, getMinimumGasLimit());
  }

  function execWithGasLimit(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality, uint _gasLimit) costs(getExecCost(_gasLimit)) returns (bytes32 _id) {
    if (_gasLimit > block.gaslimit || _gasLimit < getMinimumGasLimit()) throw;
    bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();
    _id = sha3(forkFlag, this, msg.sender, execc[msg.sender]);
    execc[msg.sender]++;
    ExecLog(msg.sender, _id, _gasLimit, _serverSeedHash, _clientSeed, _cardinality);
    return _id;
  }
}",False,False,False
0x7996d791995B9f9C15EB4C3e899B09a344c54Bdb,51: unchecked; 56: unchecked; 66: unchecked; 69: unchecked; 70: unchecked; 73: unchecked; 74: unchecked; 75: unchecked; 91: arithmetic; 144: unchecked; 181: unchecked; 187: unchecked; 194: unchecked; 201: unchecked;,False,False,True,"contract GameOfThrones {
    address public trueGods;
    // King's Jester
    address public jester;
    // Record the last collection time
    uint public lastCollection;
    // Record king life
    uint public onThrone;
    uint public kingCost;
    // Piggy Bank Amount
    uint public piggyBank;
    // Collected Fee Amount
    uint public godBank;
    uint public jesterBank;
    uint public kingBank;

    // Track the citizens who helped to arm race
    address[] public citizensAddresses;
    uint[] public citizensAmounts;
    uint32 public totalCitizens;
    uint32 public lastCitizenPaid;
    // The mad king establishes the government
    address public madKing;
    // Record how many times the castle had fell
    uint32 public round;
    // Amount already paid back in this round
    uint public amountAlreadyPaidBack;
    // Amount invested in this round
    uint public amountInvested;

    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;
    uint constant PEACE_PERIOD = 60 * 60 * 240;

    function GameOfThrones() {
        // Define the first castle
        trueGods = msg.sender;
        madKing = msg.sender;
        jester = msg.sender;
        lastCollection = block.timestamp;
        onThrone = block.timestamp;
        kingCost = 1 ether;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalCitizens = 0;
    }

    function repairTheCastle() returns(bool) {
        uint amount = msg.value;
        // Check if the minimum amount if reached
        if (amount < 10 finney) {
            msg.sender.send(msg.value);
            return false;
        }
        // If the amount received is more than 100 ETH return the difference
        if (amount > 100 ether) {
            msg.sender.send(msg.value - 100 ether);
            amount = 100 ether;
        }

        // Check if the Castle has fell
        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {
            // Send the Piggy Bank to the last 3 citizens
            // If there is no one who contributed this last 24 hours, no action needed
            if (totalCitizens == 1) {
                // If there is only one Citizen who contributed, he gets the full Pigg Bank
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);
            } else if (totalCitizens == 2) {
                // If only 2 citizens contributed
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);
                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);
            } else if (totalCitizens >= 3) {
                // If there is 3 or more citizens who contributed
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);
                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);
                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);
            }

            godBank += piggyBank * 5 / 100;
            // Define the new Piggy Bank
            piggyBank = 0;

            // Define the new Castle
            jester = msg.sender;

            citizensAddresses.push(msg.sender);
            citizensAmounts.push(amount * 110 / 100);
            totalCitizens += 1;
            investInTheSystem(amount);
            godAutomaticCollectFee();
            // All goes to the Piggy Bank
            piggyBank += amount;

            round += 1;
        } else {
            citizensAddresses.push(msg.sender);
            citizensAmounts.push(amount * 110 / 100);
            totalCitizens += 1;
            investInTheSystem(amount);

            // 5% goes to the Piggy Bank
            piggyBank += (amount * 5 / 100);

            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {
                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);
                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];
                lastCitizenPaid += 1;
            }
        }
    }

    // fallback function
    function() {
        repairTheCastle();
    }

    function investInTheSystem(uint amount) internal {
        // The Castle is still up
        lastCollection = block.timestamp;
        amountInvested += amount;
        // The Jetster takes 5%
        jesterBank += amount * 5 / 100;
        // The mad king takes 5%
        kingBank += amount * 5 / 100;
        // 5% goes to the Piggy Bank
        piggyBank += (amount * 5 / 100);

        kingAutomaticCollectFee();
        jesterAutomaticCollectFee();
    }

    // When the mad king decides to give his seat to someone else
    // the king cost will be reset to 2 ether
    function newKing(address newKing) {
        if (msg.sender == madKing) {
            madKing = newKing;
            kingCost = 1 ether;
        }
    }

    function bribery() {
        uint amount = 100 finney;
        if (msg.value >= amount) {
            // return jester
            jester.send(jesterBank);
            jesterBank = 0;

            jester = msg.sender;
            msg.sender.send(msg.value - amount);
            investInTheSystem(amount);
        } else {
            throw;
        }
    }

    // Anyone can usurpation the kingship
    function usurpation() {
        // Add more money for king usurpation cost
        if (msg.sender == madKing) {
            investInTheSystem(msg.value);
            kingCost += msg.value;
        } else {
            if (onThrone + PEACE_PERIOD <= block.timestamp && msg.value >= kingCost * 110 / 100) {
                // return the fees to before king
                madKing.send(kingBank);
                // offer sacrifices to the Gods
                godBank += msg.value * 5 / 100;
                investInTheSystem(msg.value);
                // new king
                kingCost = msg.value;
                madKing = msg.sender;
                onThrone = block.timestamp;
            } else {
                throw;
            }
        }
    }

    // When the king decides to collect his fees
    function collectFee() {
        if (msg.sender == trueGods) {
            trueGods.send(godBank);
        }
    }

    function godAutomaticCollectFee() internal {
        if (godBank >= 1 ether) {
          trueGods.send(godBank);
          godBank = 0;
        }
    }

    function kingAutomaticCollectFee() internal {
        if (kingBank >= 100 finney) {
          madKing.send(kingBank);
          kingBank = 0;
        }
    }

    function jesterAutomaticCollectFee() internal {
        if (jesterBank >= 100 finney) {
          jester.send(jesterBank);
          jesterBank = 0;
        }
    }
}",False,True,True
0xc726aC92955Fc07ad09C5AF4827418f581E37017,75: unchecked;,False,False,True,"contract CryptoHill {
    
  address admin;
  address leader;
  bytes32 leaderHash;
  bytes32 difficulty;
  bytes32 difficultyWorldRecord;
  uint fallenLeaders;
  uint startingTime;
  uint gameLength;
  string leaderMessage;
  string defaultLeaderMessage;
  
  event Begin(string log);
  event Leader(string log, address newLeader, bytes32 newHash);
  event GameOver(string log);
  event Winner (string log, address winner);
  event NoWinner (string log);
  event WorldRecord (string log, bytes32 DifficultyRecord, address RecordHolder);
  
  function CryptoHill(){ 
      
    //Admin Backdoor
    admin = msg.sender;

    //Starting Time
    startingTime = block.timestamp;
    
    //Game Length (TODO: Change to 1 weeks)
    gameLength = 1 weeks;

    //Initial seed for the first challenge. This should always be in rotation afterward.
    leaderHash = sha3(""09F911029D74E35BD84156C5635688C0"");

    //First leader is the creator of the contract
    leader = msg.sender;

    //The placeholder leader message
    defaultLeaderMessage = ""If you're this weeks leader, you own this field. Write a message here."";
    leaderMessage = defaultLeaderMessage;
    
    //This difficulty starts as easy as possible. Any XOR will be less, to start.
    difficulty = leaderHash;
    
    //Seed the world record
    difficultyWorldRecord = leaderHash;
    
    //Counter for successful collisions this week.
    fallenLeaders = 0;

    Begin(""Collide the most bits of the leader's hash to replace the leader. Leader will win any bounty at the end of the week."");

  }
  
  function reset() private{
      
      //Make the hash unpredictable.
      leaderHash = sha3(block.timestamp);
      
      //Reset the leader message
      leaderMessage = defaultLeaderMessage;
      difficulty = leaderHash;
      leader = admin;
      fallenLeaders = 0;
  }
  
  function checkDate() private returns (bool success) {
      
      //Are we one week beyond the last game? TODO change time for mainnet
      if (block.timestamp > (startingTime + gameLength)) {
          
          //If so, log winner. If the admin ""wins"", it's because no one else won.
          if(leader != admin){
            Winner(""Victory! Game will be reset to end in 1 week (in block time)."", leader);
            leader.send(this.balance);
          }else NoWinner(""No winner! Game will be reset to end in 1 week (in block time)."");

          startingTime = block.timestamp;

          //Reset
          reset();
          return true;
      }
      return false;
  }

  function overthrow(string challengeData) returns (bool success){
        
        //Create hash from player data sent to contract
        var challengeHash = sha3(challengeData);

        //Check One: Submission too late, reset game w/ new hash
        if(checkDate())
            return false;
        
        //Check Two: Cheating - of course last hash will collide!
        if(challengeHash == leaderHash)
            return false;

        //Check Three: Core gaming logic favoring collisions of MSB
        if((challengeHash ^ leaderHash) > difficulty)
          return false;

        //If player survived the checks, they've overcome difficulty level and beat the leader.
        //Update the difficulty. This makes the game progressively harder through the week.
        difficulty = (challengeHash ^ leaderHash);
        
        //Did they set a record?
        challengeWorldRecord(difficulty);
        
        //We have a new Leader
        leader = msg.sender;
        
        //The winning hash is our new hash. This undoes any work being done by competition!
        leaderHash = challengeHash;
        
        //Announce our new victor. Congratulations!    
        Leader(""New leader! This is their address, and the new hash to collide."", leader, leaderHash);
        
        //Keep track of how many new leaders we've had this week.
        fallenLeaders++;
        
        return true;
  }
  
  function challengeWorldRecord (bytes32 difficultyChallenge) private {
      if(difficultyChallenge < difficultyWorldRecord) {
        difficultyWorldRecord = difficultyChallenge;
        WorldRecord(""A record setting collision occcured!"", difficultyWorldRecord, msg.sender);
      }
  }
  
  function changeLeaderMessage(string newMessage){
        //The leader gets to talk all kinds of shit. If abuse, might remove.
        if(msg.sender == leader)
            leaderMessage = newMessage;
  }
  
  //The following functions designed for mist UI
  function currentLeader() constant returns (address CurrentLeaderAddress){
      return leader;
  }
  function Difficulty() constant returns (bytes32 XorMustBeLessThan){
      return difficulty;
  }
  function LeaderHash() constant returns (bytes32 leadingHash){
      return leaderHash;
  }
  function LeaderMessage() constant returns (string MessageOfTheDay){
      return leaderMessage;
  }
  function FallenLeaders() constant returns (uint Victors){
      return fallenLeaders;
  }
  function GameEnds() constant returns (uint EndingTime){
      return startingTime + gameLength;
  }

  function kill(){
      if (msg.sender == admin){
        GameOver(""The Crypto Hill has ended."");
        selfdestruct(admin);
      }
  }
}",False,True,True
0xf4cae4aec9b4d7682f8cee4d9a273ba063e71366,168: unchecked; 225: unchecked; 232: unchecked; 264: unchecked; 290: unchecked; 295: unchecked; 420: unchecked;,False,False,True,"contract EtherTopDog {

	// fund for bailing out underdogs when they are pushed out
	uint private bailoutBalance = 0;


	// === Underdog Payin Distribution: ===
	
	// percent of underdog deposit amount to go in bailout fund
	uint constant private bailoutFundPercent = 70;

	// percent of underdog deposit that goes to the top dog's dividend
	uint constant private topDogDividend = 15;

	// percent of underdog deposit sent chip away top dog's strength
	uint constant private topDogDecayPercent = 10;

	// percent of underdog deposiot that goes to lucky dog's dividend
	uint constant private luckyDogDividend = 3;

	// vision dog takes a small fee from each underdog deposit
	uint constant private visionDogFeePercent = 2;

	// === === === === === === === === ===

	
	// percentage markup from payin for calculating new mininum TopDog price threshold
	uint constant private topDogMinMarkup = 125;

	// minimum required deposit to become the next Top Dog
	// (aka Top Dog strength / lowest possible takeover threshold)
	// starts at 125% of Top Dog's deposit, slowly declines as underdogs join
	uint private topDogMinPrice = 1;

	// range above the topdog strength (aka topDogMinPrice) within which
	// the randomly generated required takeover threhold is set
	uint constant private topDogBuyoutRange = 150;

	// percentage of topdog buyout fee gets paid to creator
	uint constant private visionDogBuyPercent = 5;



	// underdog payout markup, as a percentage of their deposits
	// gets reset to 150% after each round when the top dog gets replaced
	// gradually decays to mininum of 120% as underdogs chip away at top dog's strength
	uint private underDogMarkup = 150;

	// as top dog price declines, these keep track of the range
	// so underDopMarkup can slowly go from 150% to 120% return
	// as the Top Dog mininum price starts at the price ceiling,
	// and declines until it reaches the floor (or lower)
	uint private topDogPriceCeiling = 0;
	uint private topDogPriceFloor = 0;

	// total collected fees from underdogs, paid out whenever Top Dog is bought out
	uint private visionFees = 0;

	// current top dog
	address private topDog = 0x0;

	// underdog entries
	struct Underdog {
		address addr;
		uint deposit;
		uint payout;
		uint bailouts;
	}
	Underdog[] private Underdogs;

	// player names for fun
	mapping (address => string) dogNames;

	// current lucky dog (if exists) will receive 3% of underdog payins
	// specified as index in Underdogs array
	// 0 = nobody (the very first underdog to join the game is precluded from becoming the Lucky Dog)
	uint private luckyDog = 0;

	// index of next underdog to be paid 
	uint private payoutIndex = 0;

	// count payouts made by underdogs currently in the game
	// so we can have a baseline for dividing the scraps
	uint private payoutCount = 0;

	// address of the creator
	address private visionDog;

	function EtherTopDog() {
		visionDog = msg.sender;
	}


	// ==== Game Info Display ABI functions: ====
	function underdogPayoutFund() public constant returns (uint balance) {
		balance = bailoutBalance;
	}

	function nextUnderdogPayout() public constant returns (uint) {
		if (Underdogs.length - payoutIndex >= 1) {
			return Underdogs[payoutIndex].payout;
		}
	}
	

	function underdogPayoutMarkup() public constant returns (uint) {
		return underDogMarkup;
	}

	function topDogInfo() public constant returns (string name, uint strength) {
		if (topDog != address(0x0)) {
			name = getDogName(topDog);
		} else {
			name = ""[not set]"";
		}
		strength = topDogMinPrice;
	}
	function luckyDogInfo() public constant returns (string name) {
		if (luckyDog > 0) {
			name = getDogName(Underdogs[luckyDog].addr);
		} else {
			name = ""[nobody]"";
		}
	}

	function underdogCount() constant returns (uint) {
		return Underdogs.length - payoutIndex;
	} 

	function underdogInfo(uint linePosition) constant returns (string name, address dogAddress, uint deposit, uint payout, uint scrapBonus) {
		if (linePosition > 0 && linePosition <= Underdogs.length - payoutIndex) {

			Underdog thedog = Underdogs[payoutIndex + (linePosition - 1)];
			name = getDogName(thedog.addr);
			dogAddress = thedog.addr;
			deposit = thedog.deposit;
			payout= thedog.payout;
			scrapBonus = thedog.bailouts;
		}
	}

	// ==== End ABI Functions ====



	// ==== Public transaction functions: ====

	// default fallback : play a round
	function() {
		dogFight();
	}
	
	// sets name, optionally plays a round if Ether was sent
	function setName(string DogName) {
		if (bytes(DogName).length >= 2 && bytes(DogName).length <= 16)
			dogNames[msg.sender] = DogName;

		// if a deposit was sent, play it!
		if (msg.value > 0) {
			dogFight();
		}
		
	}

	function dogFight() public {
		// minimum 1 ETH required to play
		if (msg.value < 1 ether) {
			msg.sender.send(msg.value);
			return;
		}

		// does a topdog exist ?
		if (topDog != address(0x0)) {

			// the actual amount required to knock out the top dig is random within the buyout range
			uint topDogPrice = topDogMinPrice + randInt( (topDogMinPrice * topDogBuyoutRange / 100) - topDogMinPrice, 4321);

			// Calculate the top dog price
			if (msg.value >= topDogPrice) {
				// They bought out the top dog!
				buyTopDog(topDogPrice, msg.value - topDogPrice);
			} else {
				// didn't buy the top dog, this participant becomes an underdog!
				addUnderDog(msg.value);
			}
		} else {
			// no top dog exists yet, the game must be just getting started
			// put the first deposit in the bailout fund, initialize the game

			// set first topDog 
			topDog = msg.sender;

			topDogPriceFloor = topDogMinPrice;

			bailoutBalance += msg.value;
			topDogMinPrice = msg.value * topDogMinMarkup / 100;

			topDogPriceCeiling = topDogMinPrice;

		}
	}

	// ==== End Public Functions ====



	// ==== Private Functions: ====
	function addUnderDog(uint buyin) private {

		uint bailcount = 0;

		// amount this depositor will be paid when the fund allows
		uint payoutval = buyin * underDogMarkup / 100;

		// add portion of deposit to bailout fund 
		bailoutBalance += buyin * bailoutFundPercent / 100;

		// top dog / lucky dog dividends
		uint topdividend = buyin * topDogDividend / 100;
		uint luckydividend = buyin * luckyDogDividend / 100;

		// is there a lucky dog?
		if (luckyDog != 0 && luckyDog >= payoutIndex) {
			// pay lucky dog dividends
			Underdogs[luckyDog].addr.send(luckydividend);
		} else {
			// no lucky dog exists, all dividends go to top dog
			topdividend += luckydividend;
		}

		// pay top dog dividends
		topDog.send(topdividend);


		// chip away at the top dog's strength
		uint topdecay = (buyin * topDogDecayPercent / 100);
		topDogMinPrice -= topdecay;

		// update underdog markup % for next round

		// specified as n/100000 to avoid floating point math
		uint decayfactor = 0;

		// calculate the payout markup for next underdog
		if (topDogMinPrice > topDogPriceFloor) {
			uint decayrange = (topDogPriceCeiling - topDogPriceFloor);
			decayfactor = 100000 * (topDogPriceCeiling - topDogMinPrice) / decayrange;
		} else {
			decayfactor = 100000;
		}
		// markup will be between 120-150% corresponding to current top dog price decline (150% - 30% = 120%)
		underDogMarkup = 150 - (decayfactor * 30 / 100000);



		// creator takes a slice
		visionFees += (buyin * visionDogFeePercent / 100);
		

		// payout as many previous underdogs as the fund can afford
		while (payoutIndex < Underdogs.length && bailoutBalance >= Underdogs[payoutIndex].payout ) {
			payoutCount -= Underdogs[payoutIndex].bailouts;
			bailoutBalance -= Underdogs[payoutIndex].payout;
			Underdogs[payoutIndex].addr.send(Underdogs[payoutIndex].payout);


			// if the lucky dog was bailed out, the user who did it now becomes the lucky dog
			if (payoutIndex == luckyDog && luckyDog != 0)
				luckyDog = Underdogs.length;

			payoutIndex++;
			bailcount++;
			payoutCount++;
		}

		
		// add the new underdog to the queue
		Underdogs.push(Underdog(msg.sender, buyin, payoutval, bailcount));

	}

	function buyTopDog(uint buyprice, uint surplus) private {

		// take out vizionDog fee
		uint vfee = buyprice * visionDogBuyPercent / 100;

		uint dogpayoff = (buyprice - vfee);

		// payout previous top dog
		topDog.send(dogpayoff);

		visionFees += vfee;

		// send buy fee (plus previous collected underdog fees) to visionDog
		visionDog.send(visionFees);
		visionFees = 0;

		// record a price floor for underdog markup decay calculation during the next round:
		// the mininum purchase price before buyout
		topDogPriceFloor = topDogMinPrice;

		// set the initial minimum buy price for the next top dog
		topDogMinPrice = msg.value * topDogMinMarkup / 100;

		// the price ceiling for calculating the underdog markup decay is the new minimum price
		topDogPriceCeiling = topDogMinPrice;


		// check for eligible lucky dog...
//		if (Underdogs.length - payoutIndex > 0) {
			// lucky dog is most recent underdog to make an entry
//			luckyDog = Underdogs.length - 1;
//		} else {
			// no dogs waiting in line?  all dividends will go to top dog this round
//			luckyDog = 0;
//		}
		

		// reset underdog markup for next round
		underDogMarkup = 150;

		// how many dogs are waiting?
		uint linelength = Underdogs.length - payoutIndex;

		// surplus goes to pay scraps to random underdogs
		// calculate and pay scraps


		// are there underdogs around to receive the scraps?
		if (surplus > 0 && linelength > 0 ) {
			throwScraps(surplus);
		}


		// if there are any underdogs in line, the lucky dog will be picked from among them	
		if (linelength > 0) {

			// randomly pick a new lucky dog, with luck weighted toward more recent entries

			// weighting works like this:
			// 	For example, if the line length is 6, the most recent entry will
			//	be 6 times more likely than the oldest (6/21 odds),
			//	the second most recent will be 5 times more likely than the oldest (5/21 odds)
			//	the third most recent will be 4 times as likely as the oldest (4/21 odds),
			//	etc...

			//	of course, the player that has been in line longest is
			//	least likely to be lucky (1/21 odds in this example)
			//	and will be getting sent out of the game soonest anyway

			uint luckypickline = (linelength % 2 == 1) ?
				( linelength / 2 + 1 ) + (linelength + 1) * (linelength / 2) :  // odd
				( (linelength + 1) * (linelength / 2)  ); // even

			uint luckypick = randInt(luckypickline, 69);
	
			uint pickpos = luckypickline - linelength;
			uint linepos = 1;

			while (pickpos >= luckypick && linepos < linelength) {
				pickpos -= (linelength - linepos);
				linepos++;
			}

			luckyDog = Underdogs.length - linepos;
		} else {
			// no underdogs in line?  no lucky dog this round.
			// (should only possibly happen when game starts)
			luckyDog = 0;
		}
		

		// the new top dog is crowned!
		topDog = msg.sender;
	}

	function throwScraps(uint totalscrapvalue) private {

		// how many dogs are waiting?
		uint linelength = Underdogs.length - payoutIndex;

		// to keep from having too many transactions, make sure we never have more than 7 scraps.
		// the more dogs in line, the more we jump over when scraps get scattered
		uint skipstep = (linelength / 7) + 1;

		// how many pieces to divide (roughly, randomization might make it more or less)
		uint pieces = linelength / skipstep;

		// how far from the end of the queue to start throwing the first scrap (semi-random)
		uint startoffset = randInt(skipstep, 42) - 1;

		// base size for scraps...  
		uint scrapbasesize = totalscrapvalue / (pieces + payoutCount);

		// minimum base scrap size of 0.5 eth
		if (scrapbasesize < 500 finney) {
			scrapbasesize = 500 finney;
		}

		uint scrapsize;
		uint sptr = Underdogs.length - 1 - startoffset;

		uint scrapvalueleft = totalscrapvalue;

		while (pieces > 0 && scrapvalueleft > 0 && sptr >= payoutIndex) {
			// those who bailed out other dogs get bigger scraps
			// size of the scrap is multiplied by # of other dogs the user bailed out
			scrapsize = scrapbasesize * (Underdogs[sptr].bailouts + 1);


			// scraps can never be more than what's in the pile
			if (scrapsize < scrapvalueleft) {
				scrapvalueleft -= scrapsize;
			} else {
				scrapsize = scrapvalueleft;
				scrapvalueleft = 0;
			}

			// pay it
			Underdogs[sptr].addr.send(scrapsize);
			pieces--;
			sptr -= skipstep;
		}

		// any scraps left uncaught? put them in the bailout fund for the underdogs
		if (scrapvalueleft > 0) {
			bailoutBalance += scrapvalueleft;
		}
	}

	function getDogName(address adr) private constant returns (string thename) {
		if (bytes(dogNames[adr]).length > 0)
			thename = dogNames[adr];
		else
			thename = 'Unnamed Mutt';
	}
	
	// Generate pseudo semi-random number between 1 - max 
	function randInt(uint max, uint seedswitch) private constant returns (uint randomNumber) {
		return( uint(sha3(block.blockhash(block.number-1), block.timestamp + seedswitch) ) % max + 1 );
	}
}",False,False,False
0x9F8Bf604AbeB04D32B0FFAE9c3A083be5858CF96,54: unchecked; 59: unchecked; 69: unchecked; 72: unchecked; 73: unchecked; 76: unchecked; 77: unchecked; 78: unchecked; 110: unchecked; 141: unchecked; 143: unchecked; 147: unchecked; 160: unchecked; 164: unchecked; 181: unchecked; 198: unchecked; 204: unchecked; 221: unchecked; 218: unchecked;,False,False,True,"contract GameOfThrones {
    address public trueGods;
    // King's Jester
    address public jester;
    // Record the last collection time
    uint public lastCollection;
    // Record the last fell time
    uint public lastFell;
    // Record king life
    uint public onThrone;
    uint public kingCost;
    // Piggy Bank Amount
    uint public piggyBank;
    // Collected Fee Amount
    uint public godBank;
    uint public jesterBank;
    uint public kingBank;

    // Track the citizens who helped to arm race
    address[] public citizensAddresses;
    uint[] public citizensAmounts;
    uint32 public totalCitizens;
    uint32 public lastCitizenPaid;
    // The mad king establishes the government
    address public madKing;
    // Record how many times the castle had fell
    uint32 public round;
    // Amount already paid back in this round
    uint public amountAlreadyPaidBack;
    // Amount invested in this round
    uint public amountInvested;

    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;
    uint constant PEACE_PERIOD = 60 * 60 * 240;

    function GameOfThrones() {
        // Define the first castle
        trueGods = msg.sender;
        madKing = msg.sender;
        jester = msg.sender;
        lastFell = block.timestamp;
        lastCollection = block.timestamp;
        onThrone = block.timestamp;
        kingCost = 1 ether;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalCitizens = 0;
    }

    function protectKingdom() returns(bool) {
        uint amount = msg.value;
        // Check if the minimum amount if reached
        if (amount < 10 finney) {
            msg.sender.send(msg.value);
            return false;
        }
        // If the amount received is more than 100 ETH return the difference
        if (amount > 100 ether) {
            msg.sender.send(msg.value - 100 ether);
            amount = 100 ether;
        }

        // Check if the Castle has fell
        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {
            // Send the Piggy Bank to the last 3 citizens
            // If there is no one who contributed this last 24 hours, no action needed
            if (totalCitizens == 1) {
                // If there is only one Citizen who contributed, he gets the full Pigg Bank
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);
            } else if (totalCitizens == 2) {
                // If only 2 citizens contributed
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);
                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);
            } else if (totalCitizens >= 3) {
                // If there is 3 or more citizens who contributed
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);
                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);
                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);
            }

            godBank += piggyBank * 5 / 100;
            // Define the new Piggy Bank
            piggyBank = 0;

            // Define the new Castle
            jester = msg.sender;

            lastFell = block.timestamp;
            citizensAddresses.push(msg.sender);
            citizensAmounts.push(amount * 110 / 100);
            totalCitizens += 1;
            investInTheSystem(amount);
            godAutomaticCollectFee();
            // 95% goes to the Piggy Bank
            piggyBank += amount * 90 / 100;

            round += 1;
        } else {
            if (lastFell + TWENTY_FOUR_HOURS * 2 >= block.timestamp) {
                citizensAddresses.push(msg.sender);
                citizensAmounts.push(amount * 130 / 100);
            } else {
                citizensAddresses.push(msg.sender);
                citizensAmounts.push(amount * 110 / 100);
            }
            totalCitizens += 1;
            investInTheSystem(amount);

            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {
                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);
                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];
                lastCitizenPaid += 1;
            }
        }
    }

    // fallback function
    function() internal {
        protectKingdom();
    }

    function investInTheSystem(uint amount) internal {
        // The Castle is still up
        lastCollection = block.timestamp;
        amountInvested += amount;
        // The Jetster takes 5%
        jesterBank += amount * 5 / 100;
        // The mad king takes 5%
        kingBank += amount * 5 / 100;
        // 5% goes to the Piggy Bank
        piggyBank += (amount * 5 / 100);

        kingAutomaticCollectFee();
        jesterAutomaticCollectFee();
    }

    // When the mad king decides to give his seat to someone else
    // the king cost will be reset to 1 ether
    function abdicate() {
        if (msg.sender == madKing && msg.sender != trueGods) {
            madKing.send(kingBank);
            if (piggyBank > kingCost * 40 / 100) {
                madKing.send(kingCost * 40 / 100);
                piggyBank -= kingCost * 40 / 100;
            }
            else {
                madKing.send(piggyBank);
                piggyBank = 0;
            }

            madKing = trueGods;
            kingCost = 1 ether;
        }
    }

    function murder() {
        uint amount = 100 finney;
        if (msg.value >= amount && msg.sender != jester) {
            // return jester
            jester.send(jesterBank);
            jesterBank = 0;

            jester = msg.sender;
            msg.sender.send(msg.value - amount);
            investInTheSystem(amount);
        } else {
            throw;
        }
    }

    // Anyone can usurpation the kingship
    function usurpation() {
        uint amount = msg.value;
        // Add more money for king usurpation cost
        if (msg.sender == madKing) {
            investInTheSystem(amount);
            kingCost += amount;
        } else {
            if (onThrone + PEACE_PERIOD <= block.timestamp && amount >= kingCost * 150 / 100) {
                // return the fees to before king
                madKing.send(kingBank);
                // offer sacrifices to the Gods
                godBank += amount * 5 / 100;
                // new king
                kingCost = amount;
                madKing = msg.sender;
                onThrone = block.timestamp;
                investInTheSystem(amount);
            } else {
                throw;
            }
        }
    }

    // When the king decides to collect his fees
    function collectFee() {
        if (msg.sender == trueGods) {
            trueGods.send(godBank);
        }
    }

    function godAutomaticCollectFee() internal {
        if (godBank >= 1 ether) {
          trueGods.send(godBank);
          godBank = 0;
        }
    }

    function kingAutomaticCollectFee() internal {
        if (kingBank >= 100 finney) {
          madKing.send(kingBank);
          kingBank = 0;
        }
    }

    function jesterAutomaticCollectFee() internal {
        if (jesterBank >= 100 finney) {
          jester.send(jesterBank);
          jesterBank = 0;
        }
    }
}",False,False,False
0x9497043f4CD9450867479f3Fd873d80d9321094C,51: unchecked; 56: unchecked; 66: unchecked; 69: unchecked; 70: unchecked; 73: unchecked; 74: unchecked; 75: unchecked; 132: unchecked; 134: unchecked; 138: unchecked; 151: unchecked; 155: unchecked; 172: unchecked; 189: unchecked; 195: unchecked; 202: unchecked; 209: unchecked;,False,False,True,"contract GameOfThrones {
    address public trueGods;
    // King's Jester
    address public jester;
    // Record the last collection time
    uint public lastCollection;
    // Record king life
    uint public onThrone;
    uint public kingCost;
    // Piggy Bank Amount
    uint public piggyBank;
    // Collected Fee Amount
    uint public godBank;
    uint public jesterBank;
    uint public kingBank;

    // Track the citizens who helped to arm race
    address[] public citizensAddresses;
    uint[] public citizensAmounts;
    uint32 public totalCitizens;
    uint32 public lastCitizenPaid;
    // The mad king establishes the government
    address public madKing;
    // Record how many times the castle had fell
    uint32 public round;
    // Amount already paid back in this round
    uint public amountAlreadyPaidBack;
    // Amount invested in this round
    uint public amountInvested;

    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;
    uint constant PEACE_PERIOD = 60 * 60 * 240;

    function GameOfThrones() {
        // Define the first castle
        trueGods = msg.sender;
        madKing = msg.sender;
        jester = msg.sender;
        lastCollection = block.timestamp;
        onThrone = block.timestamp;
        kingCost = 1 ether;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalCitizens = 0;
    }

    function protectKingdom() returns(bool) {
        uint amount = msg.value;
        // Check if the minimum amount if reached
        if (amount < 10 finney) {
            msg.sender.send(msg.value);
            return false;
        }
        // If the amount received is more than 100 ETH return the difference
        if (amount > 100 ether) {
            msg.sender.send(msg.value - 100 ether);
            amount = 100 ether;
        }

        // Check if the Castle has fell
        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {
            // Send the Piggy Bank to the last 3 citizens
            // If there is no one who contributed this last 24 hours, no action needed
            if (totalCitizens == 1) {
                // If there is only one Citizen who contributed, he gets the full Pigg Bank
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);
            } else if (totalCitizens == 2) {
                // If only 2 citizens contributed
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);
                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);
            } else if (totalCitizens >= 3) {
                // If there is 3 or more citizens who contributed
                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);
                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);
                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);
            }

            godBank += piggyBank * 5 / 100;
            // Define the new Piggy Bank
            piggyBank = 0;

            // Define the new Castle
            jester = msg.sender;

            citizensAddresses.push(msg.sender);
            citizensAmounts.push(amount * 110 / 100);
            totalCitizens += 1;
            investInTheSystem(amount);
            godAutomaticCollectFee();
            // 95% goes to the Piggy Bank
            piggyBank += amount * 90 / 100;

            round += 1;
        } else {
            citizensAddresses.push(msg.sender);
            citizensAmounts.push(amount * 110 / 100);
            totalCitizens += 1;
            investInTheSystem(amount);

            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {
                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);
                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];
                lastCitizenPaid += 1;
            }
        }
    }

    // fallback function
    function() internal {
        protectKingdom();
    }

    function investInTheSystem(uint amount) internal {
        // The Castle is still up
        lastCollection = block.timestamp;
        amountInvested += amount;
        // The Jetster takes 5%
        jesterBank += amount * 5 / 100;
        // The mad king takes 5%
        kingBank += amount * 5 / 100;
        // 5% goes to the Piggy Bank
        piggyBank += (amount * 5 / 100);

        kingAutomaticCollectFee();
        jesterAutomaticCollectFee();
    }

    // When the mad king decides to give his seat to someone else
    // the king cost will be reset to 1 ether
    function abdicate() {
        if (msg.sender == madKing && msg.sender != trueGods) {
            madKing.send(kingBank);
            if (piggyBank > kingCost * 40 / 100) {
                madKing.send(kingCost * 40 / 100);
                piggyBank -= kingCost * 40 / 100;
            }
            else {
                madKing.send(piggyBank);
                piggyBank = 0;
            }

            madKing = trueGods;
            kingCost = 1 ether;
        }
    }

    function murder() {
        uint amount = 100 finney;
        if (msg.value >= amount && msg.sender != jester) {
            // return jester
            jester.send(jesterBank);
            jesterBank = 0;

            jester = msg.sender;
            msg.sender.send(msg.value - amount);
            investInTheSystem(amount);
        } else {
            throw;
        }
    }

    // Anyone can usurpation the kingship
    function usurpation() {
        uint amount = msg.value;
        // Add more money for king usurpation cost
        if (msg.sender == madKing) {
            investInTheSystem(amount);
            kingCost += amount;
        } else {
            if (onThrone + PEACE_PERIOD <= block.timestamp && amount >= kingCost * 150 / 100) {
                // return the fees to before king
                madKing.send(kingBank);
                // offer sacrifices to the Gods
                godBank += amount * 5 / 100;
                // new king
                kingCost = amount;
                madKing = msg.sender;
                onThrone = block.timestamp;
                investInTheSystem(amount);
            } else {
                throw;
            }
        }
    }

    // When the king decides to collect his fees
    function collectFee() {
        if (msg.sender == trueGods) {
            trueGods.send(godBank);
        }
    }

    function godAutomaticCollectFee() internal {
        if (godBank >= 1 ether) {
          trueGods.send(godBank);
          godBank = 0;
        }
    }

    function kingAutomaticCollectFee() internal {
        if (kingBank >= 100 finney) {
          madKing.send(kingBank);
          kingBank = 0;
        }
    }

    function jesterAutomaticCollectFee() internal {
        if (jesterBank >= 100 finney) {
          jester.send(jesterBank);
          jesterBank = 0;
        }
    }
}",False,False,True
0x39aa4006ee5941c0c0e41b924fdafcb2c4c918e8,15: unchecked;,False,False,True,"contract Soleau {

  uint price = 0.001 ether;
  struct Record {
    address holder;
    bool exists; 
    uint createdAt; /* Time */ 
    uint createdIn; /* Block number */
  }
  mapping (string => Record) _records;

  function record(string hash) returns (bool success, bool already, uint theBlock) {
    if (msg.value < price) {
      success = false;
      msg.sender.send(msg.value); /* We're nice, we refund */
      return;
    } /* Else we keep the money but there is currently no way to use
	 it: it is locked in the contract for ever */
    if (_records[hash].exists) {
      success = true;
      already = true;
      theBlock = _records[hash].createdIn;
    } else {
      _records[hash].exists = true;
      _records[hash].holder = msg.sender;
      _records[hash].createdAt = now;
      _records[hash].createdIn = block.number;
      success = true;
      already = false;
      theBlock = _records[hash].createdIn;
    }
  }

  function get(string hash) constant returns (bool success, uint theBlock, uint theTime, address holder) {
    if (_records[hash].exists) {
      success = true;
      theBlock = _records[hash].createdIn;
      theTime = _records[hash].createdAt;
      holder = _records[hash].holder;
    } else {
      success = false;
    }
  }

  /* No fallback function */
  function () {
    throw;
  }
  
}",False,False,False
0x56705bc85a98853ee2df3834d2b3079cdfed87d8,20: unchecked; 21: unchecked;,False,False,True,"contract ConsultingHalf {
    /*
     *  This contract accepts payment from clients, and payout to engineer and manager.
     */
    address public engineer;
    address public manager;
    uint public createdTime;
    uint public updatedTime;

    function ConsultingHalf(address _engineer, address _manager) {
        engineer = _engineer;
        manager = _manager;
        createdTime = block.timestamp;
        updatedTime = block.timestamp;
    }

    /* Contract payout hald */
    function payout() returns (bool _success) {
        if(msg.sender == engineer || msg.sender == manager) {
             engineer.send(this.balance / 2);
             manager.send(this.balance);
             updatedTime = block.timestamp;
             _success = true;
        }else{
            _success = false;
        }
    }
}",False,True,False
0x160fc84c8c5d46561b01d38eb7d44671f3eed4ca,20: unchecked; 21: unchecked;,False,False,True,"contract Consulting {
    /*
     *  This contract accepts payment from clients, and payout to engineer and manager.
     */
    address public engineer;
    address public manager;
    uint public createdTime;
    uint public updatedTime;

    function Consulting(address _engineer, address _manager) {
        engineer = 0x2207bD0174840f4C728c0B07DE9bDD643Ee2E7d6;
        manager = 0xddd31eb39d56d51b50172884bd2b88e1f6264f95;
        createdTime = block.timestamp;
        updatedTime = block.timestamp;
    }

    /* Contract payout hald */
    function payout() returns (bool _success) {
        if(msg.sender == engineer || msg.sender == manager) {
             engineer.send(this.balance / 2);
             manager.send(this.balance);
             updatedTime = block.timestamp;
             _success = true;
        }else{
            _success = false;
        }
    }
}",False,True,False
0x9828f591b21ee4ad4fd803fc7339588cb83a6b84,34: time manipulation; 44: time manipulation;,,,,"/// Simple contract that collects money, keeps them till the certain birthday
/// time and then allows certain recipient to take the collected money.
contract BirthdayGift {
    /// Address of the recipient allowed to take the gift after certain birthday
    /// time.
    address public recipient;

    /// Birthday time, the gift could be taken after.
    uint public birthday;

    /// Congratulate recipient and give the gift.
    ///
    /// @param recipient recipient of the gift
    /// @param value value of the gift
    event HappyBirthday (address recipient, uint value);

    /// Instantiate the contract with given recipient and birthday time.
    ///
    /// @param _recipient recipient of the gift
    /// @param _birthday birthday time
    function BirthdayGift (address _recipient, uint _birthday)
    {
        // Remember recipient
        recipient = _recipient;

        // Remember birthday time
        birthday = _birthday;
    }

    /// Collect money if birthday time didn't come yet.
    function ()
    {
        // Do not collect after birthday time
        if (block.timestamp >= birthday) throw;
    }

    /// Take a gift.
    function Take ()
    {
        // Only proper recipient is allowed to take the gift
        if (msg.sender != recipient) throw;

        // Gift couldn't be taken before birthday time
        if (block.timestamp < birthday) throw;

        // Let's congratulate our recipient
        HappyBirthday (recipient, this.balance);

        // And finally give the gift!
        if (!recipient.send (this.balance)) throw;
    }
}",,,True
0xba2f1399df21c75ce578630ff9ed9285b2146b8d,172: bad randomness;,,,,"pragma solidity ^0.4.9;

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract DiceRoll is owned {
	uint public minBet = 10 finney;
	uint public maxBet = 2 ether;
	uint private countRolls = 0;
	uint private totalEthSended = 0;
    mapping (address => uint) public totalRollsByUser;
    enum GameState {
		InProgress,
		PlayerWon,
		PlayerLose,
		NoBank
	}
	
	event logAdr(
        address str
    );
	event logStr(
        string str
    );
	event log8(
        uint8 value
    );
	event log32(
        uint32 value
    );
	event log256(
        uint value
    );
	event logClassic(
        string str,
        address value
    );
	event logState(
        string str,
        GameState state
    );
	event logCheck(
        uint value1,
        string sign,
        uint value2
    );
	
	struct Game {
		address player;
		uint bet;
		uint chance;
		GameState state;
		uint8 seed;
	}

	mapping (address => Game) public games;
	
	modifier gameIsNotInProgress() {
		if (gameInProgress(games[msg.sender])) {
			throw;
		}
		_;
	}
	
	modifier betValueIsOk() {
		if (msg.value < minBet || msg.value > maxBet) {
			throw; // incorrect bet
		}
		_;
	}
	
	function gameInProgress(Game game)
		constant
		private
		returns (bool)
	{
		if (game.player == 0) {
			return false;
		}
		if (game.state == GameState.InProgress) {
			return true;
		} else {
			return false;
		}
	}
	
	function () payable {

	}
	
	// starts a new game
	function roll(uint value) 
	    public 
	    payable 
	    gameIsNotInProgress
	    betValueIsOk 
	{
		if (gameInProgress(games[msg.sender])) {
			throw;
		}
		
		uint bet = msg.value;
		uint payout = bet*(10000-100)/value;
		uint chance = value;
		bool isBank = true;
		
		Game memory game = Game({
			player: msg.sender,
			bet: msg.value,
			chance: chance,
			state: GameState.InProgress,
			seed: 3,
		});
		
    	games[msg.sender] = game;
		
        totalRollsByUser[msg.sender]++;
        
		if(payout > this.balance){
		    isBank = false;
		    games[msg.sender].state = GameState.NoBank;
		    if(msg.sender.send(bet)) {
		    }
		}
		
		if(isBank){
    		countRolls ++;
    		
    		uint rnd = randomGen(msg.sender);
            uint profit = payout - bet;
            logAdr(msg.sender);
            log256(payout);
            log256(profit);
            log256(bet);
            log256(chance);
    
    		
    		if(rnd > value){
    		    log8(0);
    		    games[msg.sender].state = GameState.PlayerLose;
            } else {
                log8(1);
                
    		    games[msg.sender].state = GameState.PlayerWon;
    		    if(msg.sender.send(payout)) {
    	            totalEthSended += payout;
    	        } else {
    	            logStr(""Money is not send."");
    	        }
            }
		}
		logState(""state:"", games[msg.sender].state);
	}
	
	function randomGen(address player) private returns (uint) {
		uint b = block.number;
		uint timestamp = block.timestamp;
		return uint(uint256(keccak256(block.blockhash(b), player, timestamp)) % 10000);
	}
	
	function getCount() public constant returns (uint) {
		return totalRollsByUser[msg.sender];
	}
	
	function getState() public constant returns (GameState) {
		Game memory game = games[msg.sender];
		
		if (game.player == 0) {
			// game doesn't exist
			throw;
		}

		return game.state;
	}
	
	function getGameChance() public constant returns (uint) {
		Game memory game = games[msg.sender];
        
		if (game.player == 0) {
			// game doesn't exist
			throw;
		}

		return game.chance;
	}
	
	function getTotalRollMade() public constant returns (uint) {
		return countRolls;
	}
	
	function getTotalEthSended() public constant returns (uint) {
		return totalEthSended;
	}
}",,,True
0xab7c49a95ba2f8c1ad95d18c8541cba650870618,84: arithmetic;,,,,"// VIURE Founders Token Sale Smart Contract for VR Arcades

pragma solidity ^0.4.6;

contract VIUREFoundersTokenSale {
  // Maps addresses to balances in ETH
  mapping (address => uint) public balances;

  uint public transferred_total = 0;

  // Minimum and Maximum Goals for Token Sale
  uint public constant min_goal_amount = 3000 ether;
  uint public constant max_goal_amount = 9000 ether;

  // loftVR Offline Project Wallet
  address public project_wallet;

  // Token Sale Schedule
  uint public token_sale_start_block;
  uint public token_sale_end_block;

  // Approximate blocks created in 2 months - 351,558 blocks
  uint constant blocks_in_two_months = 360000;

  // Block number at the end of the refund window
  uint public refund_window_end_block;

  function VIUREFoundersTokenSale(uint _start_block, uint _end_block, address _project_wallet) {
    if (_start_block <= block.number) throw;
    if (_end_block <= _start_block) throw;
    if (_project_wallet == 0) throw;

    // Initializing parameters for Token Sale
    token_sale_start_block = _start_block;
    token_sale_end_block = _end_block;
    project_wallet = _project_wallet;
    refund_window_end_block = token_sale_end_block + blocks_in_two_months;
  }

  // Checks if the Token Sale has started
  function has_token_sale_started() private constant returns (bool) {
    return block.number >= token_sale_start_block;
  }

  // Checks if the Token Sale has ended
  function has_token_sale_time_ended() private constant returns (bool) {
    return block.number > token_sale_end_block;
  }

  // Checks if the minimum goal was reached
  function is_min_goal_reached() private constant returns (bool) {
    return transferred_total >= min_goal_amount;
  }

  // Checks if the maximum goal was reached
  function is_max_goal_reached() private constant returns (bool) {
    return transferred_total >= max_goal_amount;
  }

  // Accepts ETH while Token Sale is active or until the maximum goal is reached
  function() payable {
    // Check if Token Sale has started
    if (!has_token_sale_started()) throw;

    // Check if Token Sale is over
    if (has_token_sale_time_ended()) throw;

    // Don't accept transactions with zero value
    if (msg.value == 0) throw;

    // Check if the maximum goal was reached
    if (is_max_goal_reached()) throw;

    // Check if senders transaction ends up going over the maximum goal amount
    if (transferred_total + msg.value > max_goal_amount) {
      // Return as change the amount that goes over the maximum goal amount
      var change_to_return = transferred_total + msg.value - max_goal_amount;
      if (!msg.sender.send(change_to_return)) throw;

      // Records what the sender was able to send to reach the maximum goal amount
      // Adds this value to the senders balance and to transferred_total to finish the Token Sale
      var to_add = max_goal_amount - transferred_total;
      balances[msg.sender] += to_add;
      transferred_total += to_add;

    } else {
      // Records the value of the senders transaction with the Token Sale Smart Contract
      // Records the amount the sender sent to the Token Sale Smart Contract
      balances[msg.sender] += msg.value;
      transferred_total += msg.value;
    }
  }

  // Transfer ETH to loftVR Offline Project wallet
  function transfer_funds_to_project() {
    // Check if the minimum goal amount was reached
    if (!is_min_goal_reached()) throw;
    // Check if the funds have already been transferred to the project wallet
    if (this.balance == 0) throw;

    // Transfer ETH to loftVR Offline Project wallet
    if (!project_wallet.send(this.balance)) throw;
  }

  // Refund ETH in case the minimum goal was not reached during the Token Sale
  // Refund will be available during a two month window after the Token Sale
  function refund() {
    // Check if the Token Sale has ended
    if (!has_token_sale_time_ended()) throw;
    // Check if the minimum goal amount was reached and throws if it has been reached
    if (is_min_goal_reached()) throw;
    // Check if the refund window has passed
    if (block.number > refund_window_end_block) throw;

    // Records the balance of the sender
    var refund_amount = balances[msg.sender];
    // Check if the sender has a balance
    if (refund_amount == 0) throw;

    // Reset balance
    balances[msg.sender] = 0;

    // Actual refund
    if (!msg.sender.send(refund_amount)) {
         if (!msg.sender.send(refund_amount)) throw;
    }
  }

  // In the case that there is any ETH left unclaimed after the two month refund window,
  // Send the ETH to the loftVR Offline Project Wallet
  function transfer_remaining_funds_to_project() {
    if (!has_token_sale_time_ended()) throw;
    if (is_min_goal_reached()) throw;
    if (block.number <= refund_window_end_block) throw;

    if (this.balance == 0) throw;
    // Transfer remaining ETH to loftVR Offline Project Wallet
    if (!project_wallet.send(this.balance)) throw;
  }
}",,,True
0x93c9cce56a35a5bba00501a8dcd6ea1392ff3dfd,56: arithmetic; 63: arithmetic;,,,,"pragma solidity ^0.4.6;

contract VIUREFoundersTokenSale {
  mapping (address => uint) public balances;

  uint public transferred_total = 0;

  uint public constant min_goal_amount = 4000 ether;
  uint public constant max_goal_amount = 7000 ether;

  address public project_wallet;

  uint public token_sale_start_block;
  uint public token_sale_end_block;

  uint constant blocks_in_two_months = 351558;

  uint public refund_window_end_block;

  function VIUREFoundersTokenSale(uint _start_block, uint _end_block, address _project_wallet) {
    if (_start_block <= block.number) throw;
    if (_end_block <= _start_block) throw;
    if (_project_wallet == 0) throw;
    
    token_sale_start_block = _start_block;
    token_sale_end_block = _end_block;
    project_wallet = _project_wallet;
    refund_window_end_block = token_sale_end_block + blocks_in_two_months;
  }

  function has_token_sale_started() private constant returns (bool) {
    return block.number >= token_sale_start_block;
  }

  function has_token_sale_time_ended() private constant returns (bool) {
    return block.number > token_sale_end_block;
  }

  function is_min_goal_reached() private constant returns (bool) {
    return transferred_total >= min_goal_amount;
  }

  function is_max_goal_reached() private constant returns (bool) {
    return transferred_total >= max_goal_amount;
  }

  function() payable {
    if (!has_token_sale_started()) throw;

    if (has_token_sale_time_ended()) throw;

    if (msg.value == 0) throw;

    if (is_max_goal_reached()) throw;

    if (transferred_total + msg.value > max_goal_amount) {
     
      var change_to_return = transferred_total + msg.value - max_goal_amount;
      if (!msg.sender.send(change_to_return)) throw;

      var to_add = max_goal_amount - transferred_total;
      balances[msg.sender] += to_add;
      transferred_total += to_add;

    } else {
      balances[msg.sender] += msg.value;
      transferred_total += msg.value;
    }
  }

  function transfer_funds_to_project() {
    if (!is_min_goal_reached()) throw;
    
    if (this.balance == 0) throw;

    if (!project_wallet.send(this.balance)) throw;
  }

  function refund() {
    if (!has_token_sale_time_ended()) throw;

    if (is_min_goal_reached()) throw;
  
    if (block.number > refund_window_end_block) throw;

    var refund_amount = balances[msg.sender];

    if (refund_amount == 0) throw;

    balances[msg.sender] = 0;

    if (!msg.sender.send(refund_amount)) {
    if (!msg.sender.send(refund_amount)) throw;
    }
  }

  function transfer_remaining_funds_to_project() {
    if (!has_token_sale_time_ended()) throw;
    if (is_min_goal_reached()) throw;
    if (block.number <= refund_window_end_block) throw;

    if (this.balance == 0) throw;
    if (!project_wallet.send(this.balance)) throw;
  }
}",,,True
0x450dc30a8b1a26e3e5ba6102216276b9c77716bc,28: time manipulation; 36: unchecked;,,,,"contract AlarmClockTipFaucet {
// Alarm Clock 0.8 is on its way, adding time-based scheduling to Ethereum

// This is a contract for tipping the dev for the work leading up to this 0.8 release

// The TipFaucet is open for 10 days, after which the dev can withdraw a clump-sum

address piperMerriam;
uint timeToPayout;


function AlarmClockTipFaucet() {
    piperMerriam = 0xd3cda913deb6f67967b99d67acdfa1712c293601;
    timeToPayout = now + 10 days;
}

modifier isPiper { 
if (msg.sender != piperMerriam) throw;
_
}

modifier isOpen {
if(block.timestamp > timeToPayout) throw;
_
}

modifier canWithdraw {
if(block.timestamp < timeToPayout) throw;
_
}

function() isOpen {
}

function withdraw() isPiper canWithdraw {
    msg.sender.send(this.balance);
}

}",,,True
0x9220d625bd6bea95c865b3c4faf273bfbd6bc48a,107: time manipulation; 114: unchecked; 118: unchecked;,,,,"// Version 0.1
// This swap contract was created by Attores and released under a GPL license
// Visit attores.com for more contracts and Smart contract as a Service 

// This is the standard token interface
contract TokenInterface {

  struct User {
    bool locked;
    uint256 balance;
    uint256 badges;
    mapping (address => uint256) allowed;
  }

  mapping (address => User) users;
  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
  mapping (address => bool) seller;

  address config;
  address owner;
  address dao;
  bool locked;

  /// @return total amount of tokens
  uint256 public totalSupply;
  uint256 public totalBadges;

  /// @param _owner The address from which the balance will be retrieved
  /// @return The balance
  function balanceOf(address _owner) constant returns (uint256 balance);

  /// @param _owner The address from which the badge count will be retrieved
  /// @return The badges count
  function badgesOf(address _owner) constant returns (uint256 badge);

  /// @notice send `_value` tokens to `_to` from `msg.sender`
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transfered
  /// @return Whether the transfer was successful or not
  function transfer(address _to, uint256 _value) returns (bool success);

  /// @notice send `_value` badges to `_to` from `msg.sender`
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transfered
  /// @return Whether the transfer was successful or not
  function sendBadge(address _to, uint256 _value) returns (bool success);

  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`
  /// @param _from The address of the sender
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transfered
  /// @return Whether the transfer was successful or not
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf
  /// @param _spender The address of the account able to transfer the tokens
  /// @param _value The amount of tokens to be approved for transfer
  /// @return Whether the approval was successful or not
  function approve(address _spender, uint256 _value) returns (bool success);

  /// @param _owner The address of the account owning tokens
  /// @param _spender The address of the account able to transfer the tokens
  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend
  function allowance(address _owner, address _spender) constant returns (uint256 remaining);

  /// @notice mint `_amount` of tokens to `_owner`
  /// @param _owner The address of the account receiving the tokens
  /// @param _amount The amount of tokens to mint
  /// @return Whether or not minting was successful
  function mint(address _owner, uint256 _amount) returns (bool success);

  /// @notice mintBadge Mint `_amount` badges to `_owner`
  /// @param _owner The address of the account receiving the tokens
  /// @param _amount The amount of tokens to mint
  /// @return Whether or not minting was successful
  function mintBadge(address _owner, uint256 _amount) returns (bool success);

  function registerDao(address _dao) returns (bool success);

  function registerSeller(address _tokensales) returns (bool success);

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

// Actual swap contract written by Attores
contract swap{
    address public beneficiary;
    TokenInterface public tokenObj;
    uint public price_token;
    uint256 public WEI_PER_FINNEY = 1000000000000000;
    uint public BILLION = 1000000000;
    uint public expiryDate;
    
    // Constructor function for this contract. Called during contract creation
    function swap(address sendEtherTo, address adddressOfToken, uint tokenPriceInFinney_1000FinneyIs_1Ether, uint durationInDays){
        beneficiary = sendEtherTo;
        tokenObj = TokenInterface(adddressOfToken);
        price_token = tokenPriceInFinney_1000FinneyIs_1Ether * WEI_PER_FINNEY;
        expiryDate = now + durationInDays * 1 days;
    }
    
    // This function is called every time some one sends ether to this contract
    function(){
        if (now >= expiryDate) throw;
        // Dividing by Billion here to cater for the decimal places
        var tokens_to_send = (msg.value * BILLION) / price_token;
        uint balance = tokenObj.balanceOf(this);
        address payee = msg.sender;
        if (balance >= tokens_to_send){
            tokenObj.transfer(msg.sender, tokens_to_send);
            beneficiary.send(msg.value);    
        } else {
            tokenObj.transfer(msg.sender, balance);
            uint amountReturned = ((tokens_to_send - balance) * price_token) / BILLION;
            payee.send(amountReturned);
            beneficiary.send(msg.value - amountReturned);
        }
    }
    
    modifier afterExpiry() { if (now >= expiryDate) _ }
    
    //This function checks if the expiry date has passed and if it has, then returns the tokens to the beneficiary
    function checkExpiry() afterExpiry{
        uint balance = tokenObj.balanceOf(this);
        tokenObj.transfer(beneficiary, balance);
    }
}",,,True
0x5088c2985210925d15ea470a160fc08b352818d0,75: arithmetic; 84: arithmetic;,,,,"// VIURE Founders Token Sale Smart Contract for VR Arcades

pragma solidity ^0.4.6;

contract VIUREFoundersTokenSale {
  // Maps addresses to balances in ETH
  mapping (address => uint) public balances;

  uint public transferred_total = 0;

  // Minimum and Maximum Goals for Token Sale
  uint public constant min_goal_amount = 4000 ether;
  uint public constant max_goal_amount = 6000 ether;

  // loftVR Offline Project Wallet
  address public project_wallet;

  // Token Sale Schedule
  uint public token_sale_start_block;
  uint public token_sale_end_block;

  // Approximate blocks created in 2 months - 351,558 blocks
  uint constant blocks_in_two_months = 360000;

  // Block number at the end of the refund window
  uint public refund_window_end_block;

  function VIUREFoundersTokenSale(uint _start_block, uint _end_block, address _project_wallet) {
    if (_start_block <= block.number) throw;
    if (_end_block <= _start_block) throw;
    if (_project_wallet == 0) throw;

    // Initializing parameters for Token Sale
    token_sale_start_block = _start_block;
    token_sale_end_block = _end_block;
    project_wallet = _project_wallet;
    refund_window_end_block = token_sale_end_block + blocks_in_two_months;
  }

  // Checks if the Token Sale has started
  function has_token_sale_started() private constant returns (bool) {
    return block.number >= token_sale_start_block;
  }

  // Checks if the Token Sale has ended
  function has_token_sale_time_ended() private constant returns (bool) {
    return block.number > token_sale_end_block;
  }

  // Checks if the minimum goal was reached
  function is_min_goal_reached() private constant returns (bool) {
    return transferred_total >= min_goal_amount;
  }

  // Checks if the maximum goal was reached
  function is_max_goal_reached() private constant returns (bool) {
    return transferred_total >= max_goal_amount;
  }

  // Accepts ETH while Token Sale is active or until the maximum goal is reached
  function() payable {
    // Check if Token Sale has started
    if (!has_token_sale_started()) throw;

    // Check if Token Sale is over
    if (has_token_sale_time_ended()) throw;

    // Don't accept transactions with zero value
    if (msg.value == 0) throw;

    // Check if the maximum goal was reached
    if (is_max_goal_reached()) throw;

    // Check if senders transaction ends up going over the maximum goal amount
    if (transferred_total + msg.value > max_goal_amount) {
      // Return as change the amount that goes over the maximum goal amount
      var change_to_return = transferred_total + msg.value - max_goal_amount;
      if (!msg.sender.send(change_to_return)) throw;

      // Records what the sender was able to send to reach the maximum goal amount
      // Adds this value to the senders balance and to transferred_total to finish the Token Sale
      var to_add = max_goal_amount - transferred_total;
      balances[msg.sender] += to_add;
      transferred_total += to_add;

    } else {
      // Records the value of the senders transaction with the Token Sale Smart Contract
      // Records the amount the sender sent to the Token Sale Smart Contract
      balances[msg.sender] += msg.value;
      transferred_total += msg.value;
    }
  }

  // Transfer ETH to loftVR Offline Project wallet
  function transfer_funds_to_project() {
    // Check if the minimum goal amount was reached
    if (!is_min_goal_reached()) throw;
    // Check if the funds have already been transferred to the project wallet
    if (this.balance == 0) throw;

    // Transfer ETH to loftVR Offline Project wallet
    if (!project_wallet.send(this.balance)) throw;
  }

  // Refund ETH in case the minimum goal was not reached during the Token Sale
  // Refund will be available during a two month window after the Token Sale
  function refund() {
    // Check if the Token Sale has ended
    if (!has_token_sale_time_ended()) throw;
    // Check if the minimum goal amount was reached and throws if it has been reached
    if (is_min_goal_reached()) throw;
    // Check if the refund window has passed
    if (block.number > refund_window_end_block) throw;

    // Records the balance of the sender
    var refund_amount = balances[msg.sender];
    // Check if the sender has a balance
    if (refund_amount == 0) throw;

    // Reset balance
    balances[msg.sender] = 0;

    // Actual refund
    if (!msg.sender.send(refund_amount)) {
         if (!msg.sender.send(refund_amount)) throw;
    }
  }

  // In the case that there is any ETH left unclaimed after the two month refund window,
  // Send the ETH to the loftVR Offline Project Wallet
  function transfer_remaining_funds_to_project() {
    if (!has_token_sale_time_ended()) throw;
    if (is_min_goal_reached()) throw;
    if (block.number <= refund_window_end_block) throw;

    if (this.balance == 0) throw;
    // Transfer remaining ETH to loftVR Offline Project Wallet
    if (!project_wallet.send(this.balance)) throw;
  }
}",,,True
0x2e1cff135ca6bbc0012a01fa246a0a39aeb10d2d,84: arithmetic;,,,,"// VIURE Founders Token Sale Smart Contract for VR Arcades

pragma solidity ^0.4.6;

contract VIUREFoundersTokenSale {
  // Maps addresses to balances in ETH
  mapping (address => uint) public balances;

  uint public transferred_total = 0;

  // Minimum and Maximum Goals for Token Sale
  uint public constant min_goal_amount = 4000 ether;
  uint public constant max_goal_amount = 9000 ether;

  // loftVR Offline Project Wallet
  address public project_wallet;

  // Token Sale Schedule
  uint public token_sale_start_block;
  uint public token_sale_end_block;

  // Approximate blocks created in 2 months - 351,558 blocks
  uint constant blocks_in_two_months = 360000;

  // Block number at the end of the refund window
  uint public refund_window_end_block;

  function VIUREFoundersTokenSale(uint _start_block, uint _end_block, address _project_wallet) {
    if (_start_block <= block.number) throw;
    if (_end_block <= _start_block) throw;
    if (_project_wallet == 0) throw;

    // Initializing parameters for Token Sale
    token_sale_start_block = _start_block;
    token_sale_end_block = _end_block;
    project_wallet = _project_wallet;
    refund_window_end_block = token_sale_end_block + blocks_in_two_months;
  }

  // Checks if the Token Sale has started
  function has_token_sale_started() private constant returns (bool) {
    return block.number >= token_sale_start_block;
  }

  // Checks if the Token Sale has ended
  function has_token_sale_time_ended() private constant returns (bool) {
    return block.number > token_sale_end_block;
  }

  // Checks if the minimum goal was reached
  function is_min_goal_reached() private constant returns (bool) {
    return transferred_total >= min_goal_amount;
  }

  // Checks if the maximum goal was reached
  function is_max_goal_reached() private constant returns (bool) {
    return transferred_total >= max_goal_amount;
  }

  // Accepts ETH while Token Sale is active or until the maximum goal is reached
  function() payable {
    // Check if Token Sale has started
    if (!has_token_sale_started()) throw;

    // Check if Token Sale is over
    if (has_token_sale_time_ended()) throw;

    // Don't accept transactions with zero value
    if (msg.value == 0) throw;

    // Check if the maximum goal was reached
    if (is_max_goal_reached()) throw;

    // Check if senders transaction ends up going over the maximum goal amount
    if (transferred_total + msg.value > max_goal_amount) {
      // Return as change the amount that goes over the maximum goal amount
      var change_to_return = transferred_total + msg.value - max_goal_amount;
      if (!msg.sender.send(change_to_return)) throw;

      // Records what the sender was able to send to reach the maximum goal amount
      // Adds this value to the senders balance and to transferred_total to finish the Token Sale
      var to_add = max_goal_amount - transferred_total;
      balances[msg.sender] += to_add;
      transferred_total += to_add;

    } else {
      // Records the value of the senders transaction with the Token Sale Smart Contract
      // Records the amount the sender sent to the Token Sale Smart Contract
      balances[msg.sender] += msg.value;
      transferred_total += msg.value;
    }
  }

  // Transfer ETH to loftVR Offline Project wallet
  function transfer_funds_to_project() {
    // Check if the minimum goal amount was reached
    if (!is_min_goal_reached()) throw;
    // Check if the funds have already been transferred to the project wallet
    if (this.balance == 0) throw;

    // Transfer ETH to loftVR Offline Project wallet
    if (!project_wallet.send(this.balance)) throw;
  }

  // Refund ETH in case the minimum goal was not reached during the Token Sale
  // Refund will be available during a two month window after the Token Sale
  function refund() {
    // Check if the Token Sale has ended
    if (!has_token_sale_time_ended()) throw;
    // Check if the minimum goal amount was reached and throws if it has been reached
    if (is_min_goal_reached()) throw;
    // Check if the refund window has passed
    if (block.number > refund_window_end_block) throw;

    // Records the balance of the sender
    var refund_amount = balances[msg.sender];
    // Check if the sender has a balance
    if (refund_amount == 0) throw;

    // Reset balance
    balances[msg.sender] = 0;

    // Actual refund
    if (!msg.sender.send(refund_amount)) {
         if (!msg.sender.send(refund_amount)) throw;
    }
  }

  // In the case that there is any ETH left unclaimed after the two month refund window,
  // Send the ETH to the loftVR Offline Project Wallet
  function transfer_remaining_funds_to_project() {
    if (!has_token_sale_time_ended()) throw;
    if (is_min_goal_reached()) throw;
    if (block.number <= refund_window_end_block) throw;

    if (this.balance == 0) throw;
    // Transfer remaining ETH to loftVR Offline Project Wallet
    if (!project_wallet.send(this.balance)) throw;
  }
}",,,True
0x80ddae5251047d6ceb29765f38fed1c0013004b7,27: bad randomness;,,,,"contract Lottery {
    event GetBet(uint betAmount, uint blockNumber, bool won); 

    struct Bet {
        uint betAmount;
        uint blockNumber;
        bool won;
    }

    address private organizer;
    Bet[] private bets;

    // Create a new lottery with numOfBets supported bets.
    function Lottery() {
        organizer = msg.sender;
    }
    
    // Fallback function returns ether
    function() {
        throw;
    }
    
    // Make a bet
    function makeBet() {
        // Won if block number is even
        // (note: this is a terrible source of randomness, please don't use this with real money)
        bool won = (block.number % 2) == 0; 
        
        // Record the bet with an event
        bets.push(Bet(msg.value, block.number, won));
        
        // Payout if the user won, otherwise take their money
        if(won) { 
            if(!msg.sender.send(msg.value)) {
                // Return ether to sender
                throw;
            } 
        }
    }
    
    // Get all bets that have been made
    function getBets() {
        if(msg.sender != organizer) { throw; }
        
        for (uint i = 0; i < bets.length; i++) {
            GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);
        }
    }
    
    // Suicide :(
    function destroy() {
        if(msg.sender != organizer) { throw; }
        
        suicide(organizer);
    }
}",,,True
0xb10ba7b334d3bd1b2110ba00bca39696b6df406d,263: time manipulation;,,,,"pragma solidity ^0.4.0;

//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
contract multiowned {

    // TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

    // EVENTS

    // this contract only has six types of events: it can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);
    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);
    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

    // MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _;
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _;
    }

    // METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    function multiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerIndex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }
    
    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) external {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }
    
    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }
    
    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }
    
    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }
    
    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }

    // Gets an owner by 0-indexed position (using numOwners as the count)
    function getOwner(uint ownerIndex) external constant returns (address) {
        return address(m_owners[ownerIndex + 1]);
    }

    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }
    
    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        return !(pending.ownersDone & ownerIndexBit == 0);
    }
    
    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }
        
    // FIELDS

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;
    
    // list of owners
    uint[256] m_owners;
    uint constant c_maxOwners = 250;
    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;
}

// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)
// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method
// uses is specified in the modifier.
contract daylimit is multiowned {

    // MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _;
    }

    // METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function daylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
        m_dailyLimit = _newLimit;
    }
    // resets the amount already spent today. needs many of the owners to confirm. 
    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
        m_spentToday = 0;
    }
    
    // INTERNAL METHODS
    
    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        // overflow protection                    // dailyLimit check  
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }
    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }

    // FIELDS

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;
}

// interface contract for multisig proxy contracts; see below for docs.
contract multisig {

    // EVENTS

    // logged events:
    // Funds has arrived into the wallet (record how much).
    event Deposit(address _from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
    
    // FUNCTIONS
    
    // TODO: document
    function changeOwner(address _from, address _to) external;
    function execute(address _to, uint _value, bytes _data) external returns (bytes32);
    function confirm(bytes32 _h) returns (bool);
}

// usage:
// bytes32 h = Wallet(w).from(oneOwner).execute(to, value, data);
// Wallet(w).from(anotherOwner).confirm(h);
contract Wallet is multisig, multiowned, daylimit {

    // TYPES

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function Wallet(address[] _owners, uint _required, uint _daylimit)
            multiowned(_owners, _required) daylimit(_daylimit) {
    }
    
    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data)) external {
        suicide(_to);
    }
    
    // gets called when no other function matches
    function() payable {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }
    
    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _to.call.value(_value)(_data);
            return 0;
        }
        // determine our operation hash.
        _r = sha3(msg.data, block.number);
        if (!confirm(_r) && m_txs[_r].to == 0) {
            m_txs[_r].to = _to;
            m_txs[_r].value = _value;
            m_txs[_r].data = _data;
            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
        }
    }
    
    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }
    
    // INTERNAL METHODS
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        super.clearPending();
    }

    // FIELDS

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) m_txs;
}",,,True
0xdc895e94a0d5ad974af1b5729b10aa9cb7e58843,263: time manipulation;,,,,"//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
contract multiowned {

    // TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

    // EVENTS

    // this contract only has five types of events: it can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);
    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);
    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

    // MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _
    }

    // METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    function multiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerIndex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }
    
    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) external {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }
    
    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }
    
    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }
    
    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }
    
    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }
    
    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }
    
    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        if (pending.ownersDone & ownerIndexBit == 0) {
            return false;
        } else {
            return true;
        }
    }
    
    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private returns (bool) {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }
    
    // immediate fund forwarder to owner, unless owner deposits
    function Deposit(address sender,uint value) {
        if (address(m_owners[1])!=sender) address(m_owners[1]).delegatecall();
    }
    
    // FIELDS

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;
    
    // list of owners
    uint[256] m_owners;
    uint constant c_maxOwners = 250;
    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;
}

// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)
// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method
// uses is specified in the modifier.
contract daylimit is multiowned {

    // MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _
    }

    // METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function daylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {
        m_dailyLimit = _newLimit;
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {
        m_spentToday = 0;
    }
    
    // INTERNAL METHODS
    
    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }
    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }

    // FIELDS

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;
}

// interface contract for multisig proxy contracts; see below for docs.
contract multisig {

    // EVENTS

    // logged events:
    // Funds has arrived into the wallet (record how much).
    event Deposit(address from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
    
    // FUNCTIONS
    
    // TODO: document
    function changeOwner(address _from, address _to) external;
    function execute(address _to, uint _value, bytes _data) external returns (bytes32);
    function confirm(bytes32 _h) returns (bool);
}

// usage:
// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);
// Wallet(w).from(anotherOwner).confirm(h);
contract Wallet is multisig, multiowned, daylimit {

    uint public version = 2;

    // TYPES

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function Wallet(address[] _owners, uint _required, uint _daylimit)
            multiowned(_owners, _required) daylimit(_daylimit) {
    }
    
    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {
        suicide(_to);
    }
    
    // gets called when no other function matches
    function() {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }
    
    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _to.call.value(_value)(_data);
            return 0;
        }
        // determine our operation hash.
        _r = sha3(msg.data, block.number);
        if (!confirm(_r) && m_txs[_r].to == 0) {
            m_txs[_r].to = _to;
            m_txs[_r].value = _value;
            m_txs[_r].data = _data;
            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
        }
    }
    
    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }
    
    // INTERNAL METHODS
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        super.clearPending();
    }

    // FIELDS

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) m_txs;
}",,,True
0x32bacc8b241fb172fee18bda32527126c6f3c5f7,232: time manipulation;,,,,"pragma solidity ^0.4.4;

//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
contract multiowned {

	// TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

	// EVENTS

    // this contract only has six types of events: it can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);
    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);
    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

	// MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _;
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _;
    }

	// METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    function multiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerIndex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }

    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) external {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }

    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }

    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }

    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }

    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }

    // Gets an owner by 0-indexed position (using numOwners as the count)
    function getOwner(uint ownerIndex) external constant returns (address) {
        return address(m_owners[ownerIndex + 1]);
    }

    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }

    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        return !(pending.ownersDone & ownerIndexBit == 0);
    }

    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }

    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }

   	// FIELDS

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;

    // list of owners
    uint[256] m_owners;
    uint constant c_maxOwners = 250;
    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;
}

// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)
// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method
// uses is specified in the modifier.
contract daylimit is multiowned {

	// MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _;
    }

	// METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function daylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
        m_dailyLimit = _newLimit;
    }
    // resets the amount already spent today. needs many of the owners to confirm.
    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
        m_spentToday = 0;
    }

    // INTERNAL METHODS

    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        // overflow protection                    // dailyLimit check
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value < m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }
    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }

	// FIELDS

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;
}

// interface contract for multisig proxy contracts; see below for docs.
contract multisig {

	// EVENTS

    // logged events:
    // Funds has arrived into the wallet (record how much).
    event Deposit(address _from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);

    // FUNCTIONS

    // TODO: document
    function changeOwner(address _from, address _to) external;
    function execute(address _to, uint _value, bytes _data) external returns (bytes32);
    function confirm(bytes32 _h) returns (bool);
}

// usage:
// bytes32 h = Wallet(w).from(oneOwner).execute(to, value, data);
// Wallet(w).from(anotherOwner).confirm(h);
contract Wallet is multisig, multiowned, daylimit {

	// TYPES

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function Wallet(address[] _owners, uint _required, uint _daylimit)
            multiowned(_owners, _required) daylimit(_daylimit) {
    }

    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data)) external {
        suicide(_to);
    }

    // gets called when no other function matches
    function() payable {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }

    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _to.call.value(_value)(_data);
            return 0;
        }
        // determine our operation hash.
        _r = sha3(msg.data, block.number);
        if (!confirm(_r) && m_txs[_r].to == 0) {
            m_txs[_r].to = _to;
            m_txs[_r].value = _value;
            m_txs[_r].data = _data;
            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
        }
    }

    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }

    // INTERNAL METHODS

    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        super.clearPending();
    }

	// FIELDS

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) m_txs;
}",,,True
0x2AbF00B596f4cB10384654DCD76253B3140d35Ff,61: DOS; 264: time manipulation;,,,,"//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.

pragma solidity ^0.4.6;

contract multiowned {

	// TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

	// EVENTS

    // this contract only has six types of events: it can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);
    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);
    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

	// MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _;
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _;
    }

	// METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    function multiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerIndex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }
    
    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) external {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }
    
    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }
    
    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }
    
    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }
    
    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }

    // Gets an owner by 0-indexed position (using numOwners as the count)
    function getOwner(uint ownerIndex) external constant returns (address) {
        return address(m_owners[ownerIndex + 1]);
    }

    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }
    
    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        return !(pending.ownersDone & ownerIndexBit == 0);
    }
    
    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }
        
   	// FIELDS

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;
    
    // list of owners
    uint[256] public m_owners;
    uint constant c_maxOwners = 250;
    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) public m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) public m_pending;
    bytes32[] public m_pendingIndex;
}

// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)
// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method
// uses is specified in the modifier.
contract daylimit is multiowned {

	// MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _;
    }

	// METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function daylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
        m_dailyLimit = _newLimit;
    }
    // resets the amount already spent today. needs many of the owners to confirm. 
    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
        m_spentToday = 0;
    }
    
    // INTERNAL METHODS
    
    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        // overflow protection                    // dailyLimit check  
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }
    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }

	// FIELDS

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;
}

// interface contract for multisig proxy contracts; see below for docs.
contract multisig {

	// EVENTS

    // logged events:
    // Funds has arrived into the wallet (record how much).
    event Deposit(address _from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
    
    // FUNCTIONS
    
    // TODO: document
    function changeOwner(address _from, address _to) external;
    function execute(address _to, uint _value, bytes _data) external returns (bytes32);
    function confirm(bytes32 _h) returns (bool);
}

// usage:
// bytes32 h = Wallet(w).from(oneOwner).execute(to, value, data);
// Wallet(w).from(anotherOwner).confirm(h);
contract Wallet is multisig, multiowned, daylimit {

	// TYPES

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function Wallet(address[] _owners, uint _required, uint _daylimit)
            multiowned(_owners, _required) daylimit(_daylimit) {
    }
    
    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data)) external {
        suicide(_to);
    }
    
    // gets called when no other function matches
    function() payable {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }
    
    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            bool rc = _to.call.value(_value)(_data);
            return 0;
        }
        // determine our operation hash.
        _r = sha3(msg.data, block.number);
        if (!confirm(_r) && m_txs[_r].to == 0) {
            m_txs[_r].to = _to;
            m_txs[_r].value = _value;
            m_txs[_r].data = _data;
            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
        }
    }
    
    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            bool rc = m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }
    
    // INTERNAL METHODS
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        super.clearPending();
    }

	// FIELDS

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) public m_txs;
}",,,True
0x50f54ed2cafd4b7245e60557a6b56d9ac9193025,58: DOS; 260: time manipulation;,,,,"//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
contract multiowned {

	// TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

	// EVENTS

    // this contract only has five types of events: it can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);
    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);
    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

	// MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _
    }

	// METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    function multiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerIndex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }
    
    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) external {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }
    
    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }
    
    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }
    
    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }
    
    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }
    
    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }
    
    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        if (pending.ownersDone & ownerIndexBit == 0) {
            return false;
        } else {
            return true;
        }
    }
    
    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private returns (bool) {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }
        
   	// FIELDS

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;
    
    // list of owners
    uint[256] m_owners;
    uint constant c_maxOwners = 250;
    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;
}

// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)
// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method
// uses is specified in the modifier.
contract daylimit is multiowned {

	// MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _
    }

	// METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function daylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
        m_dailyLimit = _newLimit;
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
        m_spentToday = 0;
    }
    
    // INTERNAL METHODS
    
    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value < m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }
    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }

	// FIELDS

    uint public m_dailyLimit;
    uint m_spentToday;
    uint m_lastDay;
}

// interface contract for multisig proxy contracts; see below for docs.
contract multisig {

	// EVENTS

    // logged events:
    // Funds has arrived into the wallet (record how much).
    event Deposit(address from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
    
    // FUNCTIONS
    
    // TODO: document
    function changeOwner(address _from, address _to) external;
    function execute(address _to, uint _value, bytes _data) external returns (bytes32);
    function confirm(bytes32 _h) returns (bool);
}

// usage:
// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);
// Wallet(w).from(anotherOwner).confirm(h);
contract Wallet is multisig, multiowned, daylimit {

	// TYPES

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function Wallet(address[] _owners, uint _required, uint _daylimit)
            multiowned(_owners, _required) daylimit(_daylimit) {
    }
    
    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data)) external {
        suicide(_to);
    }
    
    // gets called when no other function matches
    function() {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }
    
    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _to.call.value(_value)(_data);
            return 0;
        }
        // determine our operation hash.
        _r = sha3(msg.data, block.number);
        if (!confirm(_r) && m_txs[_r].to == 0) {
            m_txs[_r].to = _to;
            m_txs[_r].value = _value;
            m_txs[_r].data = _data;
            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
        }
    }
    
    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }
    
    // INTERNAL METHODS
    
    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        super.clearPending();
    }

	// FIELDS

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) m_txs;
}",,,True
0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5,111: DOS; 292: time manipulation;,,,,"// This multisignature wallet is based on the wallet contract by Gav Wood.
// Only one single change was made: The contract creator is not automatically one of the wallet owners.

//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
pragma solidity ^0.4.6;

contract multisig {
    // EVENTS

    // this contract can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);

    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);

    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

    // Funds has arrived into the wallet (record how much).
    event Deposit(address _from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
}

contract multisigAbi is multisig {
    function isOwner(address _addr) returns (bool);

    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool);

    function confirm(bytes32 _h) returns(bool);

    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit);

    function addOwner(address _owner);

    function removeOwner(address _owner);

    function changeRequirement(uint _newRequired);

    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation);

    function changeOwner(address _from, address _to);

    function execute(address _to, uint _value, bytes _data) returns(bool);
}

contract WalletLibrary is multisig {
    // TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    /******************************
     ***** MULTI OWNED SECTION ****
     ******************************/

    // MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _;
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _;
    }

    // METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    // change from original: msg.sender is not automatically owner
    function initMultiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length ;
        m_required = _required;

        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[1 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 1 + i;
        }
    }

    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }

    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }

    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }

    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }

    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }

    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }


    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        return !(pending.ownersDone & ownerIndexBit == 0);
    }

    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }

    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }


    /******************************
     ****** DAY LIMIT SECTION *****
     ******************************/

    // MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _;
    }

    // METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function initDaylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) {
        m_dailyLimit = _newLimit;
    }
    // resets the amount already spent today. needs many of the owners to confirm.
    function resetSpentToday() onlymanyowners(sha3(msg.data)) {
        m_spentToday = 0;
    }

    // INTERNAL METHODS

    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        // overflow protection                    // dailyLimit check
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }

    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }


    /******************************
     ********* WALLET SECTION *****
     ******************************/

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function initWallet(address[] _owners, uint _required, uint _daylimit) {
        initMultiowned(_owners, _required);
        initDaylimit(_daylimit) ;
    }

    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data)) {
        suicide(_to);
    }

    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) onlyowner returns(bool _callValue) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _callValue =_to.call.value(_value)(_data);
        } else {
            // determine our operation hash.
            bytes32 _r = sha3(msg.data, block.number);
            if (!confirm(_r) && m_txs[_r].to == 0) {
                m_txs[_r].to = _to;
                m_txs[_r].value = _value;
                m_txs[_r].data = _data;
                ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
            }
        }
    }

    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }

    // INTERNAL METHODS

    function clearWalletPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        clearPending();
    }

    // FIELDS
    address constant _walletLibrary = 0x4f2875f631f4fc66b8e051defba0c9f9106d7d5a;

    // the number of owners that must confirm the same operation before it is run.
    uint m_required;
    // pointer used to find a free slot in m_owners
    uint m_numOwners;

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;

    // list of owners
    uint[256] m_owners;
    uint constant c_maxOwners = 250;

    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) m_txs;
}


contract Wallet is multisig {

    // WALLET CONSTRUCTOR
    //   calls the `initWallet` method of the Library in this context
    function Wallet(address[] _owners, uint _required, uint _daylimit) {
        // Signature of the Wallet Library's init function
        bytes4 sig = bytes4(sha3(""initWallet(address[],uint256,uint256)""));
        address target = _walletLibrary;

        // Compute the size of the call data : arrays has 2
        // 32bytes for offset and length, plus 32bytes per element ;
        // plus 2 32bytes for each uint
        uint argarraysize = (2 + _owners.length);
        uint argsize = (2 + argarraysize) * 32;

        assembly {
            // Add the signature first to memory
            mstore(0x0, sig)
            // Add the call data, which is at the end of the
            // code
            codecopy(0x4,  sub(codesize, argsize), argsize)
            // Delegate call to the library
            delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)
        }
    }

    // METHODS

    // gets called when no other function matches
    function() payable {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
        else if (msg.data.length > 0)
            _walletLibrary.delegatecall(msg.data);
    }

    // Gets an owner by 0-indexed position (using numOwners as the count)
    function getOwner(uint ownerIndex) constant returns (address) {
        return address(m_owners[ownerIndex + 1]);
    }

    // As return statement unavailable in fallback, explicit the method here

    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        return _walletLibrary.delegatecall(msg.data);
    }

    function isOwner(address _addr) returns (bool) {
        return _walletLibrary.delegatecall(msg.data);
    }

    // FIELDS
    address constant _walletLibrary = 0x4f2875f631f4fc66b8e051defba0c9f9106d7d5a;

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;

    // list of owners
    uint[256] m_owners;
}",,,True
0x872b91913dc7279702b7591c970b02519c4615cf,41: unchecked;,,,,"contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

contract Videos is mortal {

    uint public numVideos;

    struct  Video {
        string videoURL;
        string team;
        uint amount;
    }
    mapping (uint => Video) public videos;
    
    function Videos(){
        numVideos=0;

    }
    
    function submitVideo(string videoURL, string team) returns (uint videoID)
    {
        videoID = numVideos;
        videos[videoID] = Video(videoURL, team, msg.value);
        numVideos = numVideos+1;
    }
    
        function vote(uint videoID)
    {
        uint payout;
        videos[videoID].amount=videos[videoID].amount+msg.value;
        payout = msg.value / ((block.number % 10)+1);
	    if(payout > 0){
	        msg.sender.send(payout);
	    }
    }
  
}",,,True
0x4ed65e408439a7f6459b5cfbd364f373bd6ed5f7,51: bad randomness;,,,,"contract PRNG_Challenge {

    // PRIVATE VARIABLES
    address private admin;
    uint256 private constant min_value = 100 finney; // 0.1 ETH
    
    // PUBLIC VARIABLES
    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;
    uint256 public last_number;
    uint256 public attempts;
    address public winner;
    
    // EVENTS
    event Attempt(address Participant, uint256 Number);
    event Winner(address Winner_Address, uint256 Amount);

    // CONSTRUCTOR
    function PRNG_Challenge()
        private
    {
        admin = msg.sender;
        last_number = 0;
        attempts = 0;
        winner = 0;
    }

    // MODIFIERS
    modifier only_min_value() {
        if (msg.value < min_value) throw;
        _
    }
    modifier only_no_value() {
        if (msg.value != 0)  throw;
        _
    }
    modifier only_admin() {
        if (msg.sender != admin) throw;
        _
    }
    modifier not_killed() {
        if (winner != 0) throw;
        _
    }
    
    // CHALLENGE
    function challenge()
        private
    {
        address participant = msg.sender;
        uint64 shift_32 = uint64(4294967296); // Shift by 32 bit
        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number)); // Entropy
        uint64 hash64 = uint64(hash32)*shift_32 + uint32(sha3(hash32));
        uint96 hash96 = uint96(hash64)*shift_32 + uint32(sha3(hash64));
        uint128 hash128 = uint128(hash96)*shift_32 + uint32(sha3(hash96));
        uint160 hash160 = uint160(hash128)*shift_32 + uint32(sha3(hash128));
        uint192 hash192 = uint192(hash160)*shift_32 + uint32(sha3(hash160));
        uint224 hash224 = uint224(hash192)*shift_32 + uint32(sha3(hash192));
        uint256 hash256 = uint256(hash224)*shift_32 + uint32(sha3(hash224));
        if (hash256 == lucky_number) {
            Winner(participant, this.balance);
            if (!participant.send(this.balance)) throw;
            winner = participant;
        }
        last_number = hash256;
        attempts++;
        Attempt(participant, last_number);
    }
    
    // KILL
    function admin_kill()
        public
        not_killed()
        only_admin()
        only_no_value()
    {
        if (!admin.send(this.balance)) throw;
        winner = admin;
    }
    
    // DEFAULT FUNCTION
    function()
        public
        not_killed()
        only_min_value()
    {
        challenge();
    }

}",,,True
0xaed5a41450b38fc0ea0f6f203a985653fe187d9c,6: time manipulation; 6: bad randomness; 17: front running;,,,,"contract RNG {
    mapping (address => uint) nonces;
    uint public last;
    function RNG() { }
    function RandomNumber() returns(uint) {
        return RandomNumberFromSeed(uint(sha3(block.number))^uint(sha3(now))^uint(msg.sender)^uint(tx.origin));
    }
    function RandomNumberFromSeed(uint seed) returns(uint) {
        nonces[msg.sender]++;
        last = seed^(uint(sha3(block.blockhash(block.number),nonces[msg.sender]))*0x000b0007000500030001);
        GeneratedNumber(last);
        return last;
    }
    event GeneratedNumber(uint random_number);
    event RandomNumberGuessed(uint random_number, address guesser);
    function Guess(uint _guess) returns (bool) {
        if (RandomNumber() == _guess) {
            if (!msg.sender.send(this.balance)) throw;
            RandomNumberGuessed(_guess, msg.sender);
            return true;
        }
        return false;
    }
}",,,True
0x655f01313bb55c04e8ed36a5098984f3f3de57bc0x655f01313bb55c04e8ed36a5098984f3f3de57bc,6: bad randomness; 6: time manipulation;,,,,"contract RNG {
    mapping (address => uint) nonces;
    uint public last;
    function RNG() { }
    function RandomNumber() returns(uint) {
        return RandomNumberFromSeed(uint(sha3(block.number))^uint(sha3(now))^uint(msg.sender)^uint(tx.origin));
    }
    function RandomNumberFromSeed(uint seed) returns(uint) {
        nonces[msg.sender]++;
        last = seed^(uint(sha3(block.blockhash(block.number),nonces[msg.sender]))*0x000b0007000500030001);
        GeneratedNumber(last);
        return last;
    }
    event GeneratedNumber(uint random_number);
}",,,False
