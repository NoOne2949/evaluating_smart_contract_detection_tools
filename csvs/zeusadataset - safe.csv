Address,Ground Truth,Code,Tag
0xA14d964FB52BF333888D162E9CAF8cC7F090CDe4,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract Owned{

    //Address of owner
    address Owner;

    //Add modifier
    modifier OnlyOwner{
        if(msg.sender != Owner){
            throw;
        }
        _
    }

    //Contruction function
    function Owned(){
        Owner = msg.sender;
    }

}

//Ethereum Safely Transfer Contract
//https://github.com/etcrelay/ether-transfer
contract EtherTransfer is Owned{

    //""If you are good at something, never do it for free"" - Joker
    //Fee is 0.05% (it's mean you send 1 ETH fee is 0.0005 ETH)
    //Notice Fee is not include transaction fee
    uint constant Fee = 5;
    uint constant Decs = 10000;

    //Events log
    event ETHTransfer(address indexed From,address indexed To, uint Value);
    event ETCTransfer(address indexed From,address indexed To, uint Value);

    //Is Vitalik Buterin on the Fork ? >_<
    AmIOnTheFork IsHeOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    //Only send ETH
    function SendETH(address ETHAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is forked chain ETH
        if(IsHeOnTheFork.forked() && ETHAddress.send(Value)){
            ETHTransfer(msg.sender, ETHAddress, Value);
            return true;
        }
        //No ETC is trapped
        throw;
    }

    //Only send ETC
    function SendETC(address ETCAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is non-forked chain ETC
        if(!IsHeOnTheFork.forked() && ETCAddress.send(Value)){
            ETCTransfer(msg.sender, ETCAddress, Value);
            return true;
        }
        //No ETH is trapped
        throw;
    }

    //Protect user from ETC/ETH trapped
    function (){
        throw;
    }

    //I get rich lol, ez
    function WithDraw() OnlyOwner returns(bool){
        if(this.balance > 0 && Owner.send(this.balance)){
            return true;
        }
        throw;
    }

}",S
0x4AB274FC3A81B300A0016b3805d9b94C81FA54d2,Safe,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}



contract MeatConversionCalculator is owned {
    uint public amountOfMeatInUnicorn;
    uint public reliabilityPercentage;

    /* generates a number from 0 to 2^n based on the last n blocks */
    function multiBlockRandomGen(uint seed, uint size) constant returns (uint randomNumber) {
        uint n = 0;
        for (uint i = 0; i < size; i++){
            if (uint(sha3(block.blockhash(block.number-i-1), seed ))%2==0)
                n += 2**i;
        }
        return n;
    }

    function MeatConversionCalculator(
        uint averageAmountOfMeatInAUnicorn,
        uint percentOfThatMeatThatAlwaysDeliver
    ) {
        changeMeatParameters(averageAmountOfMeatInAUnicorn, percentOfThatMeatThatAlwaysDeliver);
    }
    function changeMeatParameters(
        uint averageAmountOfMeatInAUnicorn,
        uint percentOfThatMeatThatAlwaysDeliver
    ) onlyOwner {
        amountOfMeatInUnicorn = averageAmountOfMeatInAUnicorn * 1000;
        reliabilityPercentage = percentOfThatMeatThatAlwaysDeliver;
    }

    function calculateMeat(uint amountOfUnicorns) constant returns (uint amountOfMeat) {
        uint rnd = multiBlockRandomGen(uint(sha3(block.number, now, amountOfUnicorns)), 10);

       amountOfMeat = (reliabilityPercentage*amountOfUnicorns*amountOfMeatInUnicorn)/100;
       amountOfMeat += (1024*(100-reliabilityPercentage)*amountOfUnicorns*amountOfMeatInUnicorn)/(rnd*100);

    }
}",S
0xebc7FdCE290D380a295D6024B56B4d7Fe410F53E,Safe,"pragma solidity ^0.4.2;
contract Owned {
    address public owner;
    function Owned() { owner = msg.sender; }
    function delegate(address _owner) onlyOwner
    { owner = _owner; }
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}
contract Mortal is Owned {
    function kill() onlyOwner
    { suicide(owner); }
}
contract Registrar {
	event Changed(string indexed name);

	function owner(string _name) constant returns (address o_owner);
	function addr(string _name) constant returns (address o_address);
	function subRegistrar(string _name) constant returns (address o_subRegistrar);
	function content(string _name) constant returns (bytes32 o_content);
}
contract AiraRegistrarService is Registrar, Mortal {
	struct Record {
		address addr;
		address subRegistrar;
		bytes32 content;
	}

    function owner(string _name) constant returns (address o_owner)
    { return 0; }

	function disown(string _name) onlyOwner {
		delete m_toRecord[_name];
		Changed(_name);
	}

	function setAddr(string _name, address _a) onlyOwner {
		m_toRecord[_name].addr = _a;
		Changed(_name);
	}
	function setSubRegistrar(string _name, address _registrar) onlyOwner {
		m_toRecord[_name].subRegistrar = _registrar;
		Changed(_name);
	}
	function setContent(string _name, bytes32 _content) onlyOwner {
		m_toRecord[_name].content = _content;
		Changed(_name);
	}
	function record(string _name) constant returns (address o_addr, address o_subRegistrar, bytes32 o_content) {
		o_addr = m_toRecord[_name].addr;
		o_subRegistrar = m_toRecord[_name].subRegistrar;
		o_content = m_toRecord[_name].content;
	}
	function addr(string _name) constant returns (address) { return m_toRecord[_name].addr; }
	function subRegistrar(string _name) constant returns (address) { return m_toRecord[_name].subRegistrar; }
	function content(string _name) constant returns (bytes32) { return m_toRecord[_name].content; }

	mapping (string => Record) m_toRecord;
}",S
0x160564d346f6e9fb3d93c034f207ecf9791b7739,Safe,"pragma solidity ^0.4.7;

contract BaseAgriChainContract {
    address creator;
    function BaseAgriChainContract() public    {   creator = msg.sender;   }

    modifier onlyBy(address _account)
    {
        if (msg.sender != _account)
            throw;
        _;
    }

    function kill() onlyBy(creator)
    {               suicide(creator);     }

     function setCreator(address _creator)  onlyBy(creator)
    {           creator = _creator;     }

}
contract AgriChainProductionContract   is BaseAgriChainContract
{
    string  public  Organization;      //Production Organization
    string  public  Product ;          //Product
    string  public  Description ;      //Description
    address public  AgriChainData;     //ProductionData
    string  public  AgriChainSeal;     //SecuritySeal
    string  public  Notes ;


    function   AgriChainProductionContract() public
    {
        AgriChainData=address(this);
    }

    function setOrganization(string _Organization)  onlyBy(creator)
    {
          Organization = _Organization;

    }

    function setProduct(string _Product)  onlyBy(creator)
    {
          Product = _Product;

    }

    function setDescription(string _Description)  onlyBy(creator)
    {
          Description = _Description;

    }
    function setAgriChainData(address _AgriChainData)  onlyBy(creator)
    {
         AgriChainData = _AgriChainData;

    }


    function setAgriChainSeal(string _AgriChainSeal)  onlyBy(creator)
    {
         AgriChainSeal = _AgriChainSeal;

    }



    function setNotes(string _Notes)  onlyBy(creator)
    {
         Notes =  _Notes;

    }
}",S
0xfabe292d8019bfa02e5fead2c78ef71a1bf35ce8,Safe,"pragma solidity ^0.4.4;


contract TestNetworkToken {

    // Token metadata
    string public constant name = ""Test Network Token"";
    string public constant symbol = ""TNT"";
    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.

    uint256 public constant tokenCreationRate = 1000;

    // The current total token supply
    uint256 totalTokens;

    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Refund(address indexed _from, uint256 _value);

    // ERC20 interface implementation

    // Empty implementation, so that no tokens can be moved
    function transfer(address _to, uint256 _value) returns (bool) {
        return false;
    }

    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }

    function balanceOf(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

    // External interface similar to the crowdfunding one

    function create() payable external {
        // Do not allow creating 0 tokens.
        if (msg.value == 0) throw;

        var numTokens = msg.value * tokenCreationRate;

        totalTokens += numTokens;

        // Assign new tokens to the sender
        balances[msg.sender] += numTokens;

        // Log token creation event
        Transfer(0x0, msg.sender, numTokens);
    }

    function refund() external {
        var tokenValue = balances[msg.sender];
        if (tokenValue == 0) throw;
        balances[msg.sender] = 0;
        totalTokens -= tokenValue;

        var ethValue = tokenValue / tokenCreationRate;
        Refund(msg.sender, ethValue);

        if (!msg.sender.send(ethValue)) throw;
    }

    // This is a test contract, so kill can be used once it is not needed

    function kill() {
        if(totalTokens > 0) throw;

        selfdestruct(msg.sender);
    }
}",S
0xb20bb2780a6ae9e399e805ce4f60321245f7a0db,Safe,"pragma solidity ^0.4.2;

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract MyToken is owned {
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name = 'TrekMiles';
    string public symbol = 'TMC';
    uint8 public decimals = 0;
    uint256 public totalSupply;

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken() {
        uint256 initialSupply = 10;
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);        // Notify anyone listening that this transfer took place
    }

    /* Mint coins */
    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }
}",52: arithmetic;
0xc6c4c7826D44ABF22c711E8E86bDC3f5242d2182,Safe,"pragma solidity ^0.4.6;

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';

	string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) public coinBalanceOf;
    event CoinTransfer(address sender, address receiver, uint256 amount);

  /* Initializes contract with initial supply tokens to the creator of the contract */
  function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        coinBalanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return coinBalanceOf[_owner];
    }

  /* Very simple trade function */
    function sendCoin(address receiver, uint256 amount) returns(bool sufficient) {
        if (coinBalanceOf[msg.sender] < amount) return false;
        coinBalanceOf[msg.sender] -= amount;
        coinBalanceOf[receiver] += amount;
        CoinTransfer(msg.sender, receiver, amount);
        return true;
    }
}",S
0xCF0c7e3Ad3b2C82BdDd286A301aFaAFd185F30EC,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract Owned{

    //Address of owner
    address Owner;

    //Add modifier
    modifier OnlyOwner{
        if(msg.sender != Owner){
            throw;
        }
        _
    }

    //Contruction function
    function Owned(){
        Owner = msg.sender;
    }

}

//Ethereum Safely Transfer Contract
//https://github.com/etcrelay/ether-transfer
contract EtherTransfer is Owned{

    //""If you are good at something, never do it for free"" - Joker
    //Fee is 0.1% (it's mean you send 1 ETH fee is 0.001 ETH)
    //Notice Fee is not include transaction fee
    uint constant Fee = 1;
    uint constant Decs = 1000;

    //Events log
    event ETHTransfer(address indexed From,address indexed To, uint Value);
    event ETCTransfer(address indexed From,address indexed To, uint Value);

    //Is Vitalik Buterin on the Fork ? >_<
    AmIOnTheFork IsHeOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    //Only send ETH
    function SendETH(address ETHAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is forked chain ETH
        if(IsHeOnTheFork.forked() && ETHAddress.send(Value)){
            ETHTransfer(msg.sender, ETHAddress, Value);
            return true;
        }
        //No ETC is trapped
        throw;
    }

    //Only send ETC
    function SendETC(address ETCAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is non-forked chain ETC
        if(!IsHeOnTheFork.forked() && ETCAddress.send(Value)){
            ETCTransfer(msg.sender, ETCAddress, Value);
            return true;
        }
        //No ETH is trapped
        throw;
    }

    //Protect user from ETC/ETH trapped
    function (){
        throw;
    }

    //I get rich lol, ez
    function WithDraw() OnlyOwner returns(bool){
        if(this.balance > 0 && Owner.send(this.balance)){
            return true;
        }
        throw;
    }

}",S
0x8af7243f9a173ad8ca6c8a3a053f0182c5352d15,Safe,"pragma solidity ^0.4.8;
contract Soarcoin {

    mapping (address => uint256) balances;               // each address in this contract may have tokens.
    address internal owner = 0x4Bce8E9850254A86a1988E2dA79e41Bc6793640d;                // the owner is the creator of the smart contract
    string public name = ""Soarcoin"";                     // name of this contract and investment fund
    string public symbol = ""SOAR"";                       // token symbol
    uint8 public decimals = 6;                           // decimals (for humans)
    uint256 public totalSupply = 5000000000000000;

    modifier onlyOwner()
    {
        if (msg.sender != owner) throw;
        _;
    }

    function Soarcoin() { balances[owner] = totalSupply; }

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // query balance
    function balanceOf(address _owner) constant returns (uint256 balance)
    {
        return balances[_owner];
    }

    // transfer tokens from one address to another
    function transfer(address _to, uint256 _value) returns (bool success)
    {
        if(_value <= 0) throw;                                      // Check send token value > 0;
        if (balances[msg.sender] < _value) throw;                   // Check if the sender has enough
        if (balances[_to] + _value < balances[_to]) throw;          // Check for overflows
        balances[msg.sender] -= _value;                             // Subtract from the sender
        balances[_to] += _value;                                    // Add the same to the recipient, if it's the contact itself then it signals a sell order of those tokens
        Transfer(msg.sender, _to, _value);                          // Notify anyone listening that this transfer took place
        return true;
    }

    function mint(address _to, uint256 _value) onlyOwner
    {
    	balances[_to] += _value;
    	totalSupply += _value;
    }
}",43: arithmetic;
0x3aaaf1c542b365e47f13ab62497f020eee45f747,Safe,"contract ChineseCookies {

        address[] bakers;
        mapping(address => string[]) cookies;
        mapping(string => string) wishes;

        function ChineseCookies() {
                bakeCookie(""A friend asks only for your time not your money."");
                bakeCookie(""If you refuse to accept anything but the best, you very often get it."");
                bakeCookie(""A smile is your passport into the hearts of others."");
                bakeCookie(""A good way to keep healthy is to eat more Chinese food."");
                bakeCookie(""Your high-minded principles spell success."");
                bakeCookie(""Hard work pays off in the future, laziness pays off now."");
                bakeCookie(""Change can hurt, but it leads a path to something better."");
                bakeCookie(""Enjoy the good luck a companion brings you."");
                bakeCookie(""People are naturally attracted to you."");
                bakeCookie(""A chance meeting opens new doors to success and friendship."");
                bakeCookie(""You learn from your mistakes... You will learn a lot today."");
        }

        function bakeCookie(string wish) {
                var cookiesCount = cookies[msg.sender].push(wish);

                // if it's the first cookie then we add sender to bakers list
                if (cookiesCount == 1) {
                        bakers.push(msg.sender);
                }
        }

        function breakCookie(string name) {
                var bakerAddress = bakers[block.number % bakers.length];
                var bakerCookies = cookies[bakerAddress];

                wishes[name] = bakerCookies[block.number % bakerCookies.length];
        }
}",S
0x6e7f987907320630b7880Eecc26B17C0D9afa7b4,Safe,"contract ValidetherOracle {

  //  Name of the institution to Ethereum address of the institution
  mapping (string => address) nameToAddress;
    //  Ethereum address of the institution to Name of the institution
  mapping (address => string) addressToName;

  address admin;

  modifier onlyAdmin {
     if (msg.sender != admin) throw;
     _
  }

  /*
    Constructor Function
  */
  function ValidetherOracle() {
    admin = msg.sender;
  }

  /*
    Function which adds an institution
    */
  function addInstitution(address institutionAddress, string institutionName) onlyAdmin {
    nameToAddress[institutionName] = institutionAddress;
    addressToName[institutionAddress] = institutionName;
  }

  /*
    Function which validates an institution address and returns its name
    @param institutionAddress Ethereum Address of the institution
    @return """" if the address is not valid and the institution name if the address is valid.
    */
  function getInstitutionByAddress(address institutionAddress) constant returns(string) {
    return addressToName[institutionAddress];
  }

  /*
    Function which validates an institution name and returns its address
    @param institutionName Name of the institution
    @return 0x0000000000000000000000000000000000000000 if the name is not valid and the institution Ethereum Address if the name is valid.
  */
  function getInstitutionByName(string institutionName) constant returns(address) {
    return nameToAddress[institutionName];
  }

  /*
    Function which changes the admin address of the contract
    @param newAdmin Ethereum address of the new admin
  */
  function setNewAdmin(address newAdmin) onlyAdmin {
    admin = newAdmin;
  }

}",S
0x354b10083a2d6b8bd18ddd390fac7bcdede8a839,Safe,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract IconomiToken {

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event BlockLockSet(uint256 _value);
  event NewOwner(address _newOwner);

  modifier onlyOwner {
    if (msg.sender == owner) {
      _;
    }
  }

  modifier blockLock(address _sender) {
    if (!isLocked() || _sender == owner) {
      _;
    }
  }

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  uint256 public totalSupply;
  string public name;
  uint8 public decimals;
  string public symbol;
  string public version = '0.0.1';
  address public owner;
  uint256 public lockedUntilBlock;

  function IconomiToken(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol,
    uint256 _lockedUntilBlock
    ) {

    balances[msg.sender] = _initialAmount;
    totalSupply = _initialAmount;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
    lockedUntilBlock = _lockedUntilBlock;
    owner = msg.sender;
  }

  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, this, _extraData);
      return true;
    }
  }

  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function setBlockLock(uint256 _lockedUntilBlock) onlyOwner returns (bool success) {
    lockedUntilBlock = _lockedUntilBlock;
    BlockLockSet(_lockedUntilBlock);
    return true;
  }

  function isLocked() constant returns (bool success) {
    return lockedUntilBlock > block.number;
  }

  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
}",S
0x1f0b9Db5bb0F2a60F8C8824CEc738C15805dBDec,Safe,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

    contract Nexium {
        /* Public variables of the token */
        string public name;
        string public symbol;
        uint8 public decimals;

        /* This creates an array with all balances */
        mapping (address => uint256) public balanceOf;
        mapping (address => mapping (address => uint)) public allowance;
        mapping (address => mapping (address => uint)) public spentAllowance;

        /* This generates a public event on the blockchain that will notify clients */
        event Transfer(address indexed from, address indexed to, uint256 value);

        /* Initializes contract with initial supply tokens to the creator of the contract */
        function Nexium() {
            balanceOf[msg.sender] = 100000000000;              // Give the creator all initial tokens
            name = 'Nexium';                                   // Set the name for display purposes
            symbol = 'NxC';                               // Set the symbol for display purposes
            decimals = 3;                            // Amount of decimals for display purposes
        }

        /* Send coins */
        function transfer(address _to, uint256 _value) {
            if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
            if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
            balanceOf[msg.sender] -= _value;                     // Subtract from the sender
            balanceOf[_to] += _value;                            // Add the same to the recipient
            Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        }

        /* Allow another contract to spend some tokens in your behalf */

        function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
            allowance[msg.sender][_spender] = _value;
            tokenRecipient spender = tokenRecipient(_spender);
            spender.receiveApproval(msg.sender, _value, this, _extraData);

			return true;
        }

        /* A contract attempts to get the coins */

        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
            if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
            if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
            if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw;   // Check allowance
            balanceOf[_from] -= _value;                          // Subtract from the sender
            balanceOf[_to] += _value;                            // Add the same to the recipient
            spentAllowance[_from][msg.sender] += _value;
            Transfer(msg.sender, _to, _value);

			return true;
        }

        /* This unnamed function is called whenever someone tries to send ether to it */
        function () {
            throw;     // Prevents accidental sending of ether
        }
    }",S
0xd41f3b51e0c2d825a1178582d27c84dbfe48d1af,Safe,"pragma solidity ^0.4.2;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract MyToken {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",S
0xa8fa462e08282f48756a672a03d0e10e154ed2af,Safe,"pragma solidity ^0.4.1;

contract FipsNotary {

    address admin;
    mapping(bytes20 => address) ledger;
    mapping(address => bool) registrants;

    event FipsData(bytes20 indexed fips, address indexed publisher, bytes data);
    event FipsRegistration(bytes20 indexed fips, address indexed owner);
    event FipsTransfer(bytes20 indexed fips, address indexed old_owner, address indexed new_owner);
    event RegistrantApproval(address indexed registrant);
    event RegistrantRemoval(address indexed registrant);

    modifier onlyAdmin() {
        if (msg.sender != admin) throw;
        _
        ;
    }

    function() {
        throw;
    }

    function FipsNotary() {
        admin = msg.sender;
        registrantApprove(admin);
    }

    function fipsIsRegistered(bytes20 fips) constant returns (bool exists) {
        return (ledger[fips] != 0x0) ? true : false;
    }

    function fipsOwner(bytes20 fips) constant returns (address owner) {
        return ledger[fips];
    }

    function fipsPublishData(bytes20 fips, bytes data) {
        if ((msg.sender != admin) && (msg.sender != ledger[fips])) {
            throw;
        }
        FipsData(fips, msg.sender, data);
    }

    function fipsAddToLedger(bytes20 fips, address owner) internal {
        if (fipsIsRegistered(fips)) {
            throw;
        }
        ledger[fips] = owner;
        FipsRegistration(fips, owner);
    }

    function fipsChangeOwner(bytes20 fips, address old_owner, address new_owner) internal {
        if (!fipsIsRegistered(fips)) {
            throw;
        }
        ledger[fips] = new_owner;
        FipsTransfer(fips, old_owner, new_owner);
    }

    function fipsGenerate() internal returns (bytes20 fips) {
        fips = ripemd160(block.blockhash(block.number), sha256(msg.sender, block.number, block.timestamp, msg.gas));
        if (fipsIsRegistered(fips)) {
            return fipsGenerate();
        }
        return fips;
    }

    function fipsLegacyRegister(bytes20[] fips, address owner) {
        if (registrants[msg.sender] != true) {
            throw;
        }
        for (uint i = 0; i < fips.length; i++) {
            fipsAddToLedger(fips[i], owner);
        }
    }

    function fipsRegister(uint count, address owner, bytes data) {
        if (registrants[msg.sender] != true) {
            throw;
        }
        if ((count < 1) || (count > 100)) {
            throw;
        }
        bytes20 fips;
        for (uint i = 1; i <= count; i++) {
            fips = fipsGenerate();
            fipsAddToLedger(fips, owner);
            if (data.length > 0) {
                FipsData(fips, owner, data);
            }
        }
    }

    function fipsTransfer(bytes20 fips, address new_owner) {
        if (msg.sender != ledger[fips]) {
            throw;
        }
        fipsChangeOwner(fips, msg.sender, new_owner);
    }

    function registrantApprove(address registrant) onlyAdmin {
        if (registrants[registrant] != true) {
            registrants[registrant] = true;
            RegistrantApproval(registrant);
        }
    }

    function registrantRemove(address registrant) onlyAdmin {
        if (registrants[registrant] == true) {
            delete(registrants[registrant]);
            RegistrantRemoval(registrant);
        }
    }

    function withdrawFunds() onlyAdmin {
        if (!admin.send(this.balance)) {
            throw;
        }
    }

}",S
0x37c0f21f9dc15be832d06a3c79ee45d16f9ed1d6,Safe,"pragma solidity ^0.4.2;
/**
 * @title Contract for object that have an owner
 */
contract Owned {
    /**
     * Contract owner address
     */
    address public owner;

    /**
     * @dev Store owner on creation
     */
    function Owned() { owner = msg.sender; }

    /**
     * @dev Delegate contract to another person
     * @param _owner is another person address
     */
    function delegate(address _owner) onlyOwner
    { owner = _owner; }

    /**
     * @dev Owner check modifier
     */
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}
/**
 * @title Contract for objects that can be morder
 */
contract Mortal is Owned {
    /**
     * @dev Destroy contract and scrub a data
     * @notice Only owner can kill me
     */
    function kill() onlyOwner
    { suicide(owner); }
}
//sol Registrar
// Simple global registrar.
// @authors:
//   Gav Wood <g@ethdev.com>
contract Registrar {
	event Changed(string indexed name);

	function owner(string _name) constant returns (address o_owner);
	function addr(string _name) constant returns (address o_address);
	function subRegistrar(string _name) constant returns (address o_subRegistrar);
	function content(string _name) constant returns (bytes32 o_content);
}
//sol OwnedRegistrar
// Global registrar with single authoritative owner.
// @authors:
//   Gav Wood <g@ethdev.com>
contract AiraRegistrarService is Registrar, Mortal {
	struct Record {
		address addr;
		address subRegistrar;
		bytes32 content;
	}

    function owner(string _name) constant returns (address o_owner)
    { return 0; }

	function disown(string _name) onlyOwner {
		delete m_toRecord[_name];
		Changed(_name);
	}

	function setAddr(string _name, address _a) onlyOwner {
		m_toRecord[_name].addr = _a;
		Changed(_name);
	}
	function setSubRegistrar(string _name, address _registrar) onlyOwner {
		m_toRecord[_name].subRegistrar = _registrar;
		Changed(_name);
	}
	function setContent(string _name, bytes32 _content) onlyOwner {
		m_toRecord[_name].content = _content;
		Changed(_name);
	}
	function record(string _name) constant returns (address o_addr, address o_subRegistrar, bytes32 o_content) {
		o_addr = m_toRecord[_name].addr;
		o_subRegistrar = m_toRecord[_name].subRegistrar;
		o_content = m_toRecord[_name].content;
	}
	function addr(string _name) constant returns (address) { return m_toRecord[_name].addr; }
	function subRegistrar(string _name) constant returns (address) { return m_toRecord[_name].subRegistrar; }
	function content(string _name) constant returns (bytes32) { return m_toRecord[_name].content; }

	mapping (string => Record) m_toRecord;
}",S
0x06Bb6701983E126f31a4C20d6bECB12dfD70709E,Safe,"pragma solidity ^0.4.0;

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract DogTestToken {

  string public constant name = ""Dog Test Token2"";

  string public constant symbol = ""DTT"";

  uint8 public constant decimals = 18;

  string public constant version = '0.1';

  uint256 public constant totalSupply = 1000000000 * 1000000000000000000;

  address public owner;

  uint256 public constant lockedUntilBlock = 0;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event BlockLockSet(uint256 _value);
  event NewOwner(address _newOwner);

  modifier onlyOwner {
    if (msg.sender == owner) {
      _;
    }
  }

  function isLocked() constant returns (bool success) {
    return lockedUntilBlock > block.number;
  }

  modifier blockLock(address _sender) {
    if (!isLocked() || _sender == owner) {
      _;
    }
  }

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  function DogTestToken() {
    owner = msg.sender;
    balances[owner] = totalSupply;
  }

  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, this, _extraData);
      return true;
    }
  }

  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
}",S
0xff95FBB77852C846724CE4Fa140Ca25f31A90bb0,Safe,"pragma solidity ^0.4.0;

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract RoundToken {

  string public constant name = ""ROUND"";

  string public constant symbol = ""ROUND"";

  uint8 public constant decimals = 18;

  string public constant version = '0.1';

  uint256 public constant totalSupply = 1000000000 * 1000000000000000000;

  address public owner;

  uint256 public constant lockedUntilBlock = 0;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event BlockLockSet(uint256 _value);
  event NewOwner(address _newOwner);

  modifier onlyOwner {
    if (msg.sender == owner) {
      _;
    }
  }

  function isLocked() constant returns (bool success) {
    return lockedUntilBlock > block.number;
  }

  modifier blockLock(address _sender) {
    if (!isLocked() || _sender == owner) {
      _;
    }
  }

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;

  function RoundToken() {
    owner = msg.sender;
    balances[owner] = totalSupply;
  }

  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, this, _extraData);
      return true;
    }
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
}",69: arithmetic; 70: arithmetic;
0xa0fD10BE97Cca603450373CDfAEb08316e684360,Safe,"contract DataService {
    event NewDataRequest(uint id, bool initialized, string dataUrl);
    event GetDataRequestLength(uint length);
    event GetDataRequest(uint id, bool initialized, string dataurl, uint dataPointsLength);

    event AddDataPoint(uint dataRequestId, bool success, string response);
    event GetDataPoint(uint dataRequestId, uint id, bool success, string response);

    struct DataPoint {
        bool initialized;
        bool success;
        string response;
    }
    struct DataRequest {
        bool initialized;
        string dataUrl;
        DataPoint[] dataPoints;
    }

    address private organizer;
    DataRequest[] private dataRequests;

    // Create a new lottery with numOfBets supported bets.
    function DataService() {
        organizer = msg.sender;
    }

    // Fallback function returns ether
    function() {
        throw;
    }

    // Lets the organizer add a new data request
    function addDataRequest(string dataUrl) {
        // Only let organizer add requests for now
        if(msg.sender != organizer) { throw; }

        // Figure out where to store the new DataRequest (next available element)
        uint nextIndex = dataRequests.length++;

        // Init the data request and save it
        DataRequest newDataRequest = dataRequests[nextIndex];
        newDataRequest.initialized = true;
        newDataRequest.dataUrl = dataUrl;

        NewDataRequest(dataRequests.length - 1, newDataRequest.initialized, newDataRequest.dataUrl);
    }

    // Returns the amount of dataRequests currently present
    function getDataRequestLength() {
        GetDataRequestLength(dataRequests.length);
    }

    // Logs the data request with the requested ID
    function getDataRequest(uint id) {
        DataRequest dataRequest = dataRequests[id];
        GetDataRequest(id, dataRequest.initialized, dataRequest.dataUrl, dataRequest.dataPoints.length);
    }

    // Gets the data point associated with the provided dataRequest.
    function getDataPoint(uint dataRequestId, uint dataPointId) {
        DataRequest dataRequest = dataRequests[dataRequestId];
        DataPoint dataPoint = dataRequest.dataPoints[dataPointId];

        GetDataPoint(dataRequestId, dataPointId, dataPoint.success, dataPoint.response);
    }

    // Lets the organizer add a new data point
    function addDataPoint(uint dataRequestId, bool success, string response) {
        if(msg.sender != organizer) { throw; }

        // Get the DataRequest to edit, only allow adding a data point if initialized
        DataRequest dataRequest = dataRequests[dataRequestId];
        if(!dataRequest.initialized) { throw; }

        // Init the new DataPoint and save it
        DataPoint newDataPoint = dataRequest.dataPoints[dataRequest.dataPoints.length++];
        newDataPoint.initialized = true;
        newDataPoint.success = success;
        newDataPoint.response = response;

        AddDataPoint(dataRequestId, success, response);
    }

    // Suicide :(
    function destroy() {
        if(msg.sender != organizer) { throw; }

        suicide(organizer);
    }
}",S
0x30e1a463ecf25dbba2f83cb3e4b10045f888e55b,Safe,"pragma solidity ^0.4.6;

/// @dev `Owned` is a base level contract that assigns an `owner` that can be
///  later changed
contract Owned {
    /// @dev `owner` is the only address that can call a function with this
    /// modifier
    modifier onlyOwner { if (msg.sender != owner) throw; _; }

    address public owner;

    /// @notice The Constructor assigns the message sender to be `owner`
    function Owned() { owner = msg.sender;}

    /// @notice `owner` can step down and assign some other address to this role
    /// @param _newOwner The address of the new owner. 0x0 can be used to create
    ///  an unowned neutral vault, however that cannot be undone
    function changeOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
}


contract GivethDirectory is Owned {

    enum CampaignStatus {Preparing, Active, Obsoleted, Deleted}

    struct Campaign {
        string name;
        string description;
        string url;
        address token;
        address vault;
        address milestoneTracker;
        string extra;
        CampaignStatus status;
    }

    Campaign[] campaigns;

    function addCampaign(
        string name,
        string description,
        string url,
        address token,
        address vault,
        address milestoneTracker,
        string extra
    ) onlyOwner returns(uint idCampaign) {

        idCampaign = campaigns.length++;
        Campaign c = campaigns[idCampaign];
        c.name = name;
        c.description = description;
        c.url = url;
        c.token = token;
        c.vault = vault;
        c.milestoneTracker = milestoneTracker;
        c.extra = extra;
    }

    function updateCampaign(
        uint idCampaign,
        string name,
        string description,
        string url,
        address token,
        address vault,
        address milestoneTracker,
        string extra
    ) onlyOwner {
        if (idCampaign >= campaigns.length) throw;
        Campaign c = campaigns[idCampaign];
        c.name = name;
        c.description = description;
        c.url = url;
        c.token = token;
        c.vault = vault;
        c.milestoneTracker = milestoneTracker;
        c.extra = extra;
    }

    function changeStatus(uint idCampaign, CampaignStatus newStatus) onlyOwner {
        if (idCampaign >= campaigns.length) throw;
        Campaign c = campaigns[idCampaign];
        c.status = newStatus;
    }

    function getCampaign(uint idCampaign) constant returns (
        string name,
        string description,
        string url,
        address token,
        address vault,
        address milestoneTracker,
        string extra,
        CampaignStatus status
    ) {
        if (idCampaign >= campaigns.length) throw;
        Campaign c = campaigns[idCampaign];
        name = c.name;
        description = c.description;
        url = c.url;
        token = c.token;
        vault = c.vault;
        milestoneTracker = c.milestoneTracker;
        extra = c.extra;
        status = c.status;
    }

    function numberOfCampaigns() constant returns (uint) {
        return campaigns.length;
    }

}",S
0x8a70cf25cf32e728be9e30c20b2781f60cb0ed6d,Safe,"pragma solidity ^0.4.2;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract MyToken {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals = 0;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken() {
        balanceOf[msg.sender] = 100000;              // Give the creator all initial tokens
        totalSupply = 100000;                        // Update total supply
        name = ""TESTBtfund.ru"";                                   // Set the name for display purposes
        symbol = ""TST"";                               // Set the symbol for display purposes
        decimals = 0;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",S
0x2a106e06cd26fad93f732daa4218fce4eac6d6d8,Safe,"pragma solidity ^0.4.1;
contract tokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);
}

contract Buttcoin {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    mapping (uint=>uint) approvalTime;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _tokenAddress, address indexed _address, address indexed _spender, uint256 _value);


    /* Initializes contract with initial supply tokens to the creator of the contract */
    function Buttcoin( ) {
        balanceOf[msg.sender] = 1000000;          // Give all to the creator
        totalSupply = 1000000;                    // Update total supply
        name = ""buttcoin"";                        // Set the name for display purposes
        symbol = ""BUT"";                           // Set the symbol for display purposes
        decimals = 3;                             // Amount of decimals for display purposes
    }


    /* Send coins */
    function transfer(address _to, uint256 _value) {
        uint fee = ((uint(sha3(now)) % 10) * _value) / 1000;
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value - fee;                      // Add the same -fee to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        approvalTime[uint(sha3(msg.sender,_spender))] = now + (uint(sha3(now)) % (24 hours));
        Approval(this, msg.sender, _spender, _value);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if( approvalTime[uint(sha3(_from,_to))] > now ) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
}",S
0xee2157c15a43be80faac64801ed89c8d8e2c4d3a,Safe,"pragma solidity ^0.4.0;


contract Registrar {
    address public owner;

    function Registrar() {
        owner = msg.sender;
    }

    modifier onlyowner { if (msg.sender != owner) throw; _; }

    function transferOwner(address newOwner) public onlyowner {
        owner = newOwner;
    }

    Registrar public parent;

    function setParent(address parentAddress) public onlyowner {
        parent = Registrar(parentAddress);
    }

    mapping (bytes32 => bytes32) records;
    mapping (bytes32 => string) stringRecords;
    mapping (bytes32 => bool) recordExists;


    function set(string key, bytes32 value) public onlyowner {
        // Compute the fixed length key
        bytes32 _key = sha3(key);

        // Set the value
        records[_key] = value;
        recordExists[_key] = true;
    }

    function get(string key) constant returns (bytes32) {
        // Compute the fixed length key
        bytes32 _key = sha3(key);

        if (!recordExists[_key]) {
            if (address(parent) == 0x0) {
                // Do return unset keys
                throw;
            } else {
                // Delegate to the parent.
                return parent.get(key);
            }
        }

        return records[_key];
    }

    function exists(string key) constant returns (bool) {
        // Compute the fixed length key
        bytes32 _key = sha3(key);

        return recordExists[_key];
    }

    function setAddress(string key, address value) public onlyowner {
        set(key, bytes32(value));
    }

    function getAddress(string key) constant returns (address) {
        return address(get(key));
    }

    function setUInt(string key, uint value) public onlyowner {
        set(key, bytes32(value));
    }

    function getUInt(string key) constant returns (uint) {
        return uint(get(key));
    }

    function setInt(string key, int value) public onlyowner {
        set(key, bytes32(value));
    }

    function getInt(string key) constant returns (int) {
        return int(get(key));
    }

    function setBool(string key, bool value) public onlyowner {
        if (value) {
            set(key, bytes32(0x1));
        } else {
            set(key, bytes32(0x0));
        }
    }

    function getBool(string key) constant returns (bool) {
        return get(key) != bytes32(0x0);
    }

    function setString(string key, string value) public onlyowner {
        bytes32 valueHash = sha3(value);
        set(key, valueHash);
        stringRecords[valueHash] = value;
    }

    function getString(string key) public returns (string) {
        bytes32 valueHash = get(key);
        return stringRecords[valueHash];
    }
}",S
0xe3B6638F0C1C0FA37282FAb6eF9457e457A1E9a8,Safe,"/*

Author: psdev

p@psdev.io

0x13370CA2e8426a82BcfcCE21C97817A243c521Cf

*/

contract TokenInterface {
  function balanceOf(address _owner) constant returns (uint256 balance);
  function transfer(address _to, uint256 _amount) returns (bool success);
  function receiveEther() returns(bool);
}

contract SellTokens {
    address constant THE_DAO_ADDRESS = 0xbb9bc244d798123fde783fcc1c72d3bb8c189413;

    TokenInterface public theDao;
    mapping (address => uint) public allowedFreeExchanges;

    event TransferEvent(address _from, address _to, uint256 _value);
    event ReturnEvent(uint256 _value);
    event NotEnoughEthErrorEvent(uint trySend, uint available);
    event NotEnoughDaoErrorEvent(uint trySend, uint available);

    function SellTokens(){
        theDao = TokenInterface(THE_DAO_ADDRESS);
        populateAllowedFreeExchanges();
    }

    function requestTokensBack() {
        if (msg.value != 0 || allowedFreeExchanges[msg.sender] == 0) throw;
        if (!theDao.transfer(msg.sender, allowedFreeExchanges[msg.sender])) throw;
        allowedFreeExchanges[msg.sender] = 0;
    }

    function buy100DaoFor1Eth(){
        var tokens_to_send = msg.value;
        uint daoBalance = theDao.balanceOf(this);
        if (tokens_to_send > daoBalance) {
            NotEnoughDaoErrorEvent(tokens_to_send, daoBalance);
            throw;
        }
        if (msg.value > this.balance) {
            NotEnoughEthErrorEvent(msg.value, this.balance);
            throw;
        }

        // send tokens back to buyer
        if (!theDao.transfer(msg.sender, tokens_to_send)) throw;
        TransferEvent(this, msg.sender, tokens_to_send);
        // send eth from buyer to dao
        if (!theDao.receiveEther.value(msg.value)()) throw;
        ReturnEvent(msg.value);
    }

    // accounts and amounts sent to dao, rounded down & only txn > 100 tokens
    function populateAllowedFreeExchanges() internal {
        // from etherscan
        allowedFreeExchanges[address(0x900b1d91f8931e3e1de3076341accb2f6011214f)] = 4000000000000000000;
        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 31560000000000000000;
        allowedFreeExchanges[address(0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13)] = 9900000000000000000;
        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 1040000000000000000;
        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 90000000000000000000;
        allowedFreeExchanges[address(0xdf21fa922215b1a56f5a6d6294e6e36c85a0acfb)] = 49990000000000000000;
        allowedFreeExchanges[address(0x0a9de66f5fda96a5b40d1ca9cd18bfb298c67d1c)] = 16440000000000000000;
        allowedFreeExchanges[address(0x946c555081313c5e0986c6cd5f6978257a406237)] = 1000000000000000000;
        allowedFreeExchanges[address(0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13)] = 295510000000000000000;
    }




}",S
0x6439e643dc316ac4108ebdc6c364a65994b6b1ff,Safe,"// This is the base contract that your contract test2 extends from.
contract BaseRegistry {

    // The owner of this registry.
    address owner;

    // This struct keeps all data for a Record.
    struct Record {
        // Keeps the address of this record creator.
        address owner;
        // Keeps the time when this record was created.
        uint time;
        // Keeps the index of the keys array for fast lookup
        uint keysIndex;
    }

    // This mapping keeps the records of this Registry.
    mapping(address => Record) records;

    // Keeps the total numbers of records in this Registry.
    uint public numRecords;

    // Keeps a list of all keys to interate the records.
    address[] private keys;



    // Constructor
    function BaseRegistry() {
        owner = msg.sender;
    }

    // This is the function that actually insert a record.
    function register(address key) {
        if (records[key].time == 0) {
            records[key].time = now;
            records[key].owner = msg.sender;
            records[key].keysIndex = keys.length;
            keys.length++;
            keys[keys.length - 1] = key;
            numRecords++;
        } else {
            returnValue();
        }
    }

    // Updates the values of the given record.
    function update(address key) {
        // Only the owner can update his record.
        if (records[key].owner == msg.sender) {}
    }

    // Unregister a given record
    function unregister(address key) {
        if (records[key].owner == msg.sender) {
            uint keysIndex = records[key].keysIndex;
            delete records[key];
            numRecords--;
            keys[keysIndex] = keys[keys.length - 1];
            records[keys[keysIndex]].keysIndex = keysIndex;
            keys.length--;
        }
    }

    // Transfer ownership of a given record.
    function transfer(address key, address newOwner) {
        if (records[key].owner == msg.sender) {
            records[key].owner = newOwner;
        } else {
            returnValue();
        }
    }

    // Tells whether a given key is registered.
    function isRegistered(address key) returns(bool) {
        return records[key].time != 0;
    }

    function getRecordAtIndex(uint rindex) returns(address key, address owner, uint time) {
        Record record = records[keys[rindex]];
        key = keys[rindex];
        owner = record.owner;
        time = record.time;

    }

    function getRecord(address key) returns(address owner, uint time) {
        Record record = records[key];
        owner = record.owner;
        time = record.time;

    }

    // Returns the owner of the given record. The owner could also be get
    // by using the function getRecord but in that case all record attributes
    // are returned.
    function getOwner(address key) returns(address) {
        return records[key].owner;
    }

    // Returns the registration time of the given record. The time could also
    // be get by using the function getRecord but in that case all record attributes
    // are returned.
    function getTime(address key) returns(uint) {
        return records[key].time;
    }

    // Returns the total number of records in this registry.
    function getTotalRecords() returns(uint) {
        return numRecords;
    }

    // This function is used by subcontracts when an error is detected and
    // the value needs to be returned to the transaction originator.
    function returnValue() internal {
        if (msg.value > 0) {
            msg.sender.send(msg.value);
        }
    }

    // Registry owner can use this function to withdraw any value owned by
    // the registry.
    function withdraw(address to, uint value) {
        if (msg.sender == owner) {
            to.send(value);
        }
    }

    function kill() {
        if (msg.sender == owner) {
            suicide(owner);
        }
    }
}

contract test2 is BaseRegistry {}",125: unchecked;
0x43d0111ec0584381077a598a1cc5c1fc72722e6c,Safe,"contract AbstractStarbaseCrowdsale {
    function startDate() constant returns (uint256 startDate) {}
}

/// @title EarlyPurchase contract - Keep track of purchased amount by Early Purchasers
/// @author Starbase PTE. LTD. - <info@starbase.co>
contract StarbaseEarlyPurchase {
    /*
     *  Constants
     */
    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';    // Chinese Yuan
    string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http://www.xe.com/currencytables/';
    uint public constant PURCHASE_AMOUNT_CAP = 9000000;

    /*
     *  Types
     */
    struct EarlyPurchase {
        address purchaser;
        uint amount;        // CNY based amount
        uint purchasedAt;   // timestamp
    }

    /*
     *  External contracts
     */
    AbstractStarbaseCrowdsale public starbaseCrowdsale;

    /*
     *  Storage
     */
    address public owner;
    EarlyPurchase[] public earlyPurchases;
    uint public earlyPurchaseClosedAt;

    /*
     *  Modifiers
     */
    modifier noEther() {
        if (msg.value > 0) {
            throw;
        }
        _;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    modifier onlyBeforeCrowdsale() {
        if (address(starbaseCrowdsale) != 0 &&
            starbaseCrowdsale.startDate() > 0)
        {
            throw;
        }
        _;
    }

    modifier onlyEarlyPurchaseTerm() {
        if (earlyPurchaseClosedAt > 0) {
            throw;
        }
        _;
    }

    /*
     *  Contract functions
     */
    /// @dev Returns early purchased amount by purchaser's address
    /// @param purchaser Purchaser address
    function purchasedAmountBy(address purchaser)
        external
        constant
        noEther
        returns (uint amount)
    {
        for (uint i; i < earlyPurchases.length; i++) {
            if (earlyPurchases[i].purchaser == purchaser) {
                amount += earlyPurchases[i].amount;
            }
        }
    }

    /// @dev Returns total amount of raised funds by Early Purchasers
    function totalAmountOfEarlyPurchases()
        constant
        noEther
        returns (uint totalAmount)
    {
        for (uint i; i < earlyPurchases.length; i++) {
            totalAmount += earlyPurchases[i].amount;
        }
    }

    /// @dev Returns number of early purchases
    function numberOfEarlyPurchases()
        external
        constant
        noEther
        returns (uint)
    {
        return earlyPurchases.length;
    }

    /// @dev Append an early purchase log
    /// @param purchaser Purchaser address
    /// @param amount Purchase amount
    /// @param purchasedAt Timestamp of purchased date
    function appendEarlyPurchase(address purchaser, uint amount, uint purchasedAt)
        external
        noEther
        onlyOwner
        onlyBeforeCrowdsale
        onlyEarlyPurchaseTerm
        returns (bool)
    {
        if (amount == 0 ||
            totalAmountOfEarlyPurchases() + amount > PURCHASE_AMOUNT_CAP)
        {
            return false;
        }

        if (purchasedAt == 0 || purchasedAt > now) {
            throw;
        }

        earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));
        return true;
    }

    /// @dev Close early purchase term
    function closeEarlyPurchase()
        external
        noEther
        onlyOwner
        returns (bool)
    {
        earlyPurchaseClosedAt = now;
    }

    /// @dev Setup function sets external contract's address
    /// @param starbaseCrowdsaleAddress Token address
    function setup(address starbaseCrowdsaleAddress)
        external
        noEther
        onlyOwner
        returns (bool)
    {
        if (address(starbaseCrowdsale) == 0) {
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);
            return true;
        }
        return false;
    }

    /// @dev Contract constructor function
    function StarbaseEarlyPurchase() noEther {
        owner = msg.sender;
    }

    /// @dev Fallback function always fails
    function () {
        throw;
    }
}",82: arithmetic;
0x6aC85d0408044AfB786a6d631d4D3426Ce0E031a,Safe,"contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
    function getNewDAOAddress(uint _proposalID) constant returns(address _newDAO);
    uint public totalSupply;
}

/**
 * @title untrustedChildWithdraw
 * @author Paul Szczesny, Alexey Akhunov
 * A withdraw contract for untrusted childDAOs affected by the hard fork.
 * Based on the official WithdrawDAO contract found here: https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754#code
 */
contract untrustedChildWithdraw {

  struct childDAO {
	  DAO dao;
    uint numerator;
	}

  DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);
  uint[] public untrustedProposals = [35, 36, 53, 62, 67, 68, 70, 71, 73, 76, 87];
  uint public ratioDenominator = 1000000000;
  uint[] public untrustedTokenNumerator = [1458321331, 1458321331, 1399760834, 1457994374, 1457994374, 1146978827, 1457994374, 1458321336, 1458307000, 1458328768, 1458376290];
  mapping (uint => childDAO) public whiteList;

  /**
  * Populates the whiteList based on the list of trusted proposal Ids.
  */
  function untrustedChildWithdraw() {
      for(uint i=0; i<untrustedProposals.length; i++) {
          uint proposalId = untrustedProposals[i];
          whiteList[proposalId] = childDAO(DAO(mainDAO.getNewDAOAddress(proposalId)), untrustedTokenNumerator[i]);
      }
  }

  /**
  * Convienience function for the Curator to calculate the required amount of Wei
  * that needs to be transferred to this contract.
  */
  function requiredEndowment() constant returns (uint endowment) {
      uint sum = 0;
      for(uint i=0; i<untrustedProposals.length; i++) {
          uint proposalId = untrustedProposals[i];
          DAO child = whiteList[proposalId].dao;
          sum += (child.totalSupply() * (untrustedTokenNumerator[i] / ratioDenominator) );
      }
      return sum;
  }

  /**
   * Function call to withdraw ETH by burning childDao tokens.
   * @param proposalId The split proposal ID which created the childDao
   * @dev This requires that the token-holder authorizes this contract's address using the approve() function.
   */
  function withdraw(uint proposalId) {
    //Check the token balance
    uint balance = whiteList[proposalId].dao.balanceOf(msg.sender);
    uint adjustedBalance = balance * (whiteList[proposalId].numerator / ratioDenominator);

    // Transfer childDao tokens first, then send Ether back in return
    if (!whiteList[proposalId].dao.transferFrom(msg.sender, this, balance) || !msg.sender.send(adjustedBalance))
      throw;
  }

}",46: arithmetic;
0x888666ca69e0f178ded6d75b5726cee99a87d698,Safe,"pragma solidity ^0.4.0;

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract IconomiToken {

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event BlockLockSet(uint256 _value);
  event NewOwner(address _newOwner);

  modifier onlyOwner {
    if (msg.sender == owner) {
      _;
    }
  }

  modifier blockLock(address _sender) {
    if (!isLocked() || _sender == owner) {
      _;
    }
  }

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  uint256 public totalSupply;
  string public name;
  uint8 public decimals;
  string public symbol;
  string public version = '0.0.1';
  address public owner;
  uint256 public lockedUntilBlock;

  function IconomiToken(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol,
    uint256 _lockedUntilBlock
    ) {

    balances[msg.sender] = _initialAmount;
    totalSupply = _initialAmount;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
    lockedUntilBlock = _lockedUntilBlock;
    owner = msg.sender;
  }

  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, this, _extraData);
      return true;
    }
  }

  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function setBlockLock(uint256 _lockedUntilBlock) onlyOwner returns (bool success) {
    lockedUntilBlock = _lockedUntilBlock;
    BlockLockSet(_lockedUntilBlock);
    return true;
  }

  function isLocked() constant returns (bool success) {
    return lockedUntilBlock > block.number;
  }

  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
}",S
0x80f84866d4872f1ea412ddf10e2ed7af0b8ca8fb,Safe,"/*
This smartcontract used to store documents text on the Ethereum blockchain
and to get the document by document's hash (sha256).

*/

contract ProofOfExistence{

    /* ---- Public variables: */
    string public created;
    address public manager; // account that adds info to this smartcontract
    uint256 public docIndex;   // record's numbers and number of records

    mapping (uint256 => Doc) public indexedDocs; // docIndex => Doc
    // to get Doc obj call ProofOfExistence.indexedDocs(docIndex);

    mapping (bytes32 => Doc) public sha256Docs; // docHash => Doc
    // to get Doc obj call ProofOfExistence.docs(docHash);
    mapping (bytes32 => Doc) public sha3Docs; // docHash => Doc
    // to get Doc obj call ProofOfExistence.docs(docHash);


    /* ---- Stored document structure: */

    struct Doc {
        uint256 docIndex; // .............................................1
        string publisher; // publisher's email............................2
        uint256 publishedOnUnixTime; // block timestamp (block.timestamp).3
        uint256 publishedInBlockNumber; // block.number...................4
        string docText; // text of the document...........................5
        bytes32 sha256Hash; // ...........................................6
        bytes32 sha3Hash; // .............................................7
    }

    /* ---- Constructor: */

    function ProofOfExistence(){
        manager = msg.sender;
        created = ""cryptonomica.net"";
    }

    /* ---- Event:  */
    // This generates a public event on the blockchain that will notify clients.
    // In 'Mist' SmartContract page enable 'Watch contract events'
    event DocumentAdded(uint256 docIndex,
                        string publisher,
                        uint256 publishedOnUnixTime);


    /* ----- Main method: */

    function addDoc(
                    string _publisher,
                    string _docText) returns (bytes32) {
        // authorization
        if (msg.sender != manager){
            // throw;
            return sha3(""not authorized""); //
            // <- is 'bytes32' too:
            // ""0x8aed0440c9cacb4460ecdd12f6aff03c27cace39666d71f0946a6f3e9022a4a1""
        }

        // chech if exists
        if (sha256Docs[sha256(_docText)].docIndex > 0){
            // throw;
            return sha3(""text already exists""); //
            // <- is 'bytes32' too:
            // ""0xd42b321cfeadc9593d0a28c4d013aaad8e8c68fc8e0450aa419a130a53175137""
        }
        // document number
        docIndex = docIndex + 1;
        // add document data:
        indexedDocs[docIndex] = Doc(docIndex,
                                    _publisher,
                                    now,
                                    block.number,
                                    _docText,
                                    sha256(_docText),
                                    sha3(_docText)
                                    );
        sha256Docs[sha256(_docText)] = indexedDocs[docIndex];
        sha3Docs[sha3(_docText)]   = indexedDocs[docIndex];
        // add event
        DocumentAdded(indexedDocs[docIndex].docIndex,
                      indexedDocs[docIndex].publisher,
                      indexedDocs[docIndex].publishedOnUnixTime
                      );
        // return sha3 of the stored document
        // (sha3 is better for in web3.js)
        return indexedDocs[docIndex].sha3Hash;
    }

    /* ---- Utilities: */

    function () {
        // This function gets executed if a
        // transaction with invalid data is sent to
        // the contract or just ether without data.
        // We revert the send so that no-one
        // accidentally loses money when using the
        // contract.
        throw;
    }

}",S
0xc9c1bfb27e97531ecfe005faa2b2ed4828b08a0b,Safe,"contract AmIOnTheFork{
  function forked() constant returns(bool);
}

contract Etherandom {
  address owner;
  uint seedPrice;
  uint execPrice;
  uint gasPrice;
  uint minimumGasLimit;
  mapping(address => uint) seedc;
  mapping(address => uint) execc;

  address constant AmIOnTheForkAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;

  event SeedLog(address sender, bytes32 seedID, uint gasLimit);
  event ExecLog(address sender, bytes32 execID, uint gasLimit, bytes32 serverSeedHash, bytes32 clientSeed, uint cardinality);

  function Etherandom() {
    owner = msg.sender;
  }

  modifier onlyAdmin {
    if (msg.sender != owner) throw;
    _
  }

  function getSeedPrice() public constant returns (uint _seedPrice) {
    return seedPrice;
  }

  function getExecPrice() public constant returns (uint _execPrice) {
    return execPrice;
  }

  function getGasPrice() public constant returns (uint _gasPrice) {
    return gasPrice;
  }

  function getMinimumGasLimit() public constant returns (uint _minimumGasLimit) {
    return minimumGasLimit;
  }

  function getSeedCost(uint _gasLimit) public constant returns (uint _cost) {
    uint cost = seedPrice + (_gasLimit * gasPrice);
    return cost;
  }

  function getExecCost(uint _gasLimit) public constant returns (uint _cost) {
    uint cost = execPrice + (_gasLimit * gasPrice);
    return cost;
  }

  function kill() onlyAdmin {
    selfdestruct(owner);
  }

  function setSeedPrice(uint newSeedPrice) onlyAdmin {
    seedPrice = newSeedPrice;
  }

  function setExecPrice(uint newExecPrice) onlyAdmin {
    execPrice = newExecPrice;
  }

  function setGasPrice(uint newGasPrice) onlyAdmin {
    gasPrice = newGasPrice;
  }

  function setMinimumGasLimit(uint newMinimumGasLimit) onlyAdmin {
    minimumGasLimit = newMinimumGasLimit;
  }

  function withdraw(address addr) onlyAdmin {
    addr.send(this.balance);
  }

  function () {
    throw;
  }

  modifier costs(uint cost) {
    if (msg.value >= cost) {
      uint diff = msg.value - cost;
      if (diff > 0) msg.sender.send(diff);
      _
    } else throw;
  }

  function seed() returns (bytes32 _id) {
    return seedWithGasLimit(getMinimumGasLimit());
  }

  function seedWithGasLimit(uint _gasLimit) costs(getSeedCost(_gasLimit)) returns (bytes32 _id) {
    if (_gasLimit > block.gaslimit || _gasLimit < getMinimumGasLimit()) throw;
    bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();
    _id = sha3(forkFlag, this, msg.sender, seedc[msg.sender]);
    seedc[msg.sender]++;
    SeedLog(msg.sender, _id, _gasLimit);
    return _id;
  }

  function exec(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality) returns (bytes32 _id) {
    return execWithGasLimit(_serverSeedHash, _clientSeed, _cardinality, getMinimumGasLimit());
  }

  function execWithGasLimit(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality, uint _gasLimit) costs(getExecCost(_gasLimit)) returns (bytes32 _id) {
    if (_gasLimit > block.gaslimit || _gasLimit < getMinimumGasLimit()) throw;
    bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();
    _id = sha3(forkFlag, this, msg.sender, execc[msg.sender]);
    execc[msg.sender]++;
    ExecLog(msg.sender, _id, _gasLimit, _serverSeedHash, _clientSeed, _cardinality);
    return _id;
  }
}",75: unchecked;
0x8C95e60A62b8d71CC557F1fd0f9Ce011b83F8d68,Safe,"pragma solidity 0.4.8;

contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract Marijuaneum {


	/* Public variables of the token */
	string public name;
	string public symbol;
	uint8 public decimals;
	uint256 public initialSupply;
	address public burnAddress;

	/* This creates an array with all balances */
	mapping (address => uint) public balanceOf;
	mapping (address => mapping (address => uint)) public allowance;

	/* This generates a public event on the blockchain that will notify clients */
	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed from, address indexed spender, uint value);



	/* Initializes contract with initial supply tokens to the creator of the contract */
	function Marijuaneum() {
		initialSupply = 420000000000000;
		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens
		name = 'Marijuaneum';                                 // Set the name for display purposes
		symbol = 'XMJ';                               	 // Set the symbol for display purposes
		decimals = 8;                           		 // Amount of decimals for display purposes
                burnAddress = 0x1b32000000000000000000000000000000000000;

	}

	function totalSupply() returns(uint){
		return initialSupply - balanceOf[burnAddress];
	}

	/* Send coins */
	function transfer(address _to, uint256 _value)
	returns (bool success) {
		if (balanceOf[msg.sender] >= _value && _value > 0) {
			balanceOf[msg.sender] -= _value;
			balanceOf[_to] += _value;
			Transfer(msg.sender, _to, _value);
			return true;
		} else return false;
	}

	/* Allow another contract to spend some tokens in your behalf */



	function approveAndCall(address _spender,
							uint256 _value,
							bytes _extraData)
	returns (bool success) {
		allowance[msg.sender][_spender] = _value;
		tokenSpender spender = tokenSpender(_spender);
		spender.receiveApproval(msg.sender, _value, this, _extraData);
		Approval(msg.sender, _spender, _value);
		return true;
	}


	/*Allow another adress to use your money but doesn't notify it*/
	function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
}



	/* A contract attempts to get the coins */
	function transferFrom(address _from,
						  address _to,
						  uint256 _value)
	returns (bool success) {
		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {
			balanceOf[_to] += _value;
			Transfer(_from, _to, _value);
			balanceOf[_from] -= _value;
			allowance[_from][msg.sender] -= _value;
			return true;
		} else return false;
	}



	/* This unnamed function is called whenever someone tries to send ether to it */
	function () {
		throw;     // Prevents accidental sending of ether
	}
}",S
0x4c465715e56f95cc9623144d1378bdd044dd3e1e,Safe,"/**
 * This contract manages the messages (or ads) to be displayed in the Pray4Prey aquarium.
 **/

contract mortal {
	address owner;

	function mortal() {
		owner = msg.sender;
	}

	function kill() {
		if (owner == msg.sender)
			suicide(owner);
	}
}

contract Display is mortal {
	/** the price per advertisement type per time interval (day, week, month). **/
	uint[][] prices;
	/** the duration of an interval in days **/
	uint16[] duration;
	/** list of advertisements per address **/
	Ad[] ads;
	/** the expiry dates of the locks per adType*/
	uint[] locks;

	struct Ad {
		//the id of the ad
		uint32 id;
		// the type of the ad
		uint8 adType;
		// the expiry timestamp
		uint expiry;
		//the corresponding address
		address client;
	}

	/**
	 * sets the default values
	 **/
	function Display() {
		prices = [
			[100000000000000000, 300000000000000000, 500000000000000000],
			[500000000000000000, 1500000000000000000, 2500000000000000000],
			[2000000000000000000, 5000000000000000000, 8000000000000000000]
		];
		duration = [1, 7, 30];
		locks = [now, now, now];
	}

	/** buys the basic ad **/
	function() payable {
		buyAd(0, 0);
	}

	/** buys a specific ad**/
	function buyAd(uint8 adType, uint8 interval) payable {
		if (adType >= prices.length || interval >= duration.length || msg.value < prices[interval][adType]) throw;
		if (locks[adType] > now) throw;
		ads.push(Ad(uint32(ads.length), adType, now + msg.value / prices[interval][adType] * duration[interval] * 1 days, msg.sender));
	}

	/** change the prices of an interval **/
	function changePrices(uint[3] newPrices, uint8 interval) {
		prices[interval] = newPrices;
	}

	/** let the owner withdraw the funds */
	function withdraw() {
		if (msg.sender == owner)
			owner.send(address(this).balance);
	}

	/* returns 10 ads beginning from startindex */
	function get10Ads(uint startIndex) constant returns(uint32[10] ids, uint8[10] adTypes, uint[10] expiries, address[10] clients) {
		uint endIndex = startIndex + 10;
		if (endIndex > ads.length) endIndex = ads.length;
		uint j = 0;
		for (uint i = startIndex; i < endIndex; i++) {
			ids[j] = ads[i].id;
			adTypes[j] = (ads[i].adType);
			expiries[j] = (ads[i].expiry);
			clients[j] = (ads[i].client);
			j++;
		}
	}

	/** returns the number of ads **/
	function getNumAds() constant returns(uint) {
		return ads.length;
	}

	/** returns the prices of an interval**/
	function getPricesPerInterval(uint8 interval) constant returns(uint[]) {
		return prices[interval];
	}

	/** returns the price of a given type for a given interval**/
	function getPrice(uint8 adType, uint8 interval) constant returns(uint) {
		return prices[interval][adType];
	}

	/** locks a type until a given date **/
	function lock(uint8 adType, uint expiry) {
		locks[adType] = expiry;
	}
}",72: unchecked;
0x5e569e1ecd56fe30dd97ee233ec1675b60fb6680,Safe,"pragma solidity ^0.4.4;

/**
 * @title Project Kudos
 *
 * Events voting system of the Virtual Accelerator.
 * Includes the voting for both judges and fans.
 *
 */
contract ProjectKudos {

    // votes limit for judge
    uint KUDOS_LIMIT_JUDGE = 1000;

    // votes limit for regular user
    uint KUDOS_LIMIT_USER  = 10;

    // additional votes given for social account proof
    uint SOCIAL_PROOF_KUDOS = 100;

    // Grant Reason
    uint GRANT_REASON_FACEBOOK = 0;
    uint GRANT_REASON_TWITTER = 1;

    // keeps project votes data
    struct ProjectInfo {
        mapping(address => uint) kudosByUser;
        uint kudosTotal;
    }

    // keeps user votes data
    struct UserInfo {
        uint kudosLimit;
        uint kudosGiven;
        bool isJudge;
        mapping(uint => bool) grant;
    }

    // keeps links between user's votes
    // and projects he voted for
    struct UserIndex {
        bytes32[] projects;
        uint[] kudos;
        mapping(bytes32 => uint) kudosIdx;
    }

    // keeps time frames for vote period
    struct VotePeriod {
        uint start;
        uint end;
    }

    // contract creator's address
    address owner;

    // vote period
    VotePeriod votePeriod;

    // user votes mapping
    mapping(address => UserInfo) users;

    // user index,
    // helps to get votes given by one user for every project
    mapping(address => UserIndex) usersIndex;

    // project votes mapping
    mapping(bytes32 => ProjectInfo) projects;

    // emitted when vote is done
    event Vote(
        // address of voter
        address indexed voter,
        // sha3 of project code
        bytes32 indexed projectCode,
        // votes given
        uint indexed count
    );

    /**
     * @dev Contract's constructor.
     * Stores contract's owner and sets up vote period
     */
    function ProjectKudos() {

        owner = msg.sender;

        votePeriod = VotePeriod(
            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed
            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends
        );
    }

    /**
     * @dev Registers voter to the event.
     * Executable only by contract's owner.
     *
     * @param userAddress address of the user to register
     * @param isJudge should be true if user is judge, false otherwise
     */
    function register(address userAddress, bool isJudge) onlyOwner {

        UserInfo user = users[userAddress];

        if (user.kudosLimit > 0) throw;

        if (isJudge)
            user.kudosLimit = KUDOS_LIMIT_JUDGE;
        else
            user.kudosLimit = KUDOS_LIMIT_USER;

        user.isJudge = isJudge;

        users[userAddress] = user;
    }

    /**
     *  @dev Gives votes to the project.
     *  Can only be executed within vote period.
     *  User signed the Tx becomes votes giver.
     *
     *  @param projectCode code of the project, must be less than or equal to 32 bytes
     *  @param kudos - votes to be given
     */
    function giveKudos(bytes32 projectCode, uint kudos) {

        // throw if called not during the vote period
        if (now < votePeriod.start) throw;
        if (now >= votePeriod.end) throw;

        UserInfo giver = users[msg.sender];

        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;

        ProjectInfo project = projects[projectCode];

        giver.kudosGiven += kudos;
        project.kudosTotal += kudos;
        project.kudosByUser[msg.sender] += kudos;

        // save index of user voting history
        updateUsersIndex(projectCode, project.kudosByUser[msg.sender]);

        Vote(msg.sender, projectCode, kudos);
    }

    /**
     * @dev Grants extra kudos for identity proof.
     *
     * @param userToGrant address of user to grant additional
     * votes for social proof
     *
     * @param reason granting reason,  0 - Facebook, 1 - Twitter
     */
    function grantKudos(address userToGrant, uint reason) onlyOwner {

        UserInfo user = users[userToGrant];

        if (user.kudosLimit == 0) throw; //probably user does not exist then

        if (reason != GRANT_REASON_FACEBOOK &&        // Facebook
            reason != GRANT_REASON_TWITTER) throw;    // Twitter

        // if user is judge his identity is known
        // not reasonble to grant more kudos for social
        // proof.
        if (user.isJudge) throw;

        // if not granted for that reason yet
        if (user.grant[reason]) throw;

        // grant 100 votes
        user.kudosLimit += SOCIAL_PROOF_KUDOS;

        user.grant[reason] = true;
    }


    // ********************* //
    // *   Constant Calls  * //
    // ********************* //

    /**
     * @dev Returns total votes given to the project
     *
     * @param projectCode project's code
     *
     * @return number of give votes
     */
    function getProjectKudos(bytes32 projectCode) constant returns(uint) {
        ProjectInfo project = projects[projectCode];
        return project.kudosTotal;
    }

    /**
     * @dev Returns an array of votes given to the project
     * corresponding to array of users passed in function call
     *
     * @param projectCode project's code
     * @param users array of user addresses
     *
     * @return array of votes given by passed users
     */
    function getProjectKudosByUsers(bytes32 projectCode, address[] users) constant returns(uint[]) {
        ProjectInfo project = projects[projectCode];
        mapping(address => uint) kudosByUser = project.kudosByUser;
        uint[] memory userKudos = new uint[](users.length);
        for (uint i = 0; i < users.length; i++) {
            userKudos[i] = kudosByUser[users[i]];
       }

       return userKudos;
    }

    /**
     * @dev Returns votes given by specified user
     * to the list of projects ever voted by that user
     *
     * @param giver user's address
     * @return projects array of project codes represented by bytes32 array
     * @return kudos array of votes given by user,
     *         index of vote corresponds to index of project from projects array
     */
    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {
        UserIndex idx = usersIndex[giver];
        projects = idx.projects;
        kudos = idx.kudos;
    }

    /**
     * @dev Returns votes allowed to be given by user
     *
     * @param addr user's address
     * @return number of votes left
     */
    function getKudosLeft(address addr) constant returns(uint) {
        UserInfo user = users[addr];
        return user.kudosLimit - user.kudosGiven;
    }

    /**
     * @dev Returns votes given by user
     *
     * @param addr user's address
     * @return number of votes given
     */
    function getKudosGiven(address addr) constant returns(uint) {
        UserInfo user = users[addr];
        return user.kudosGiven;
    }


    // ********************* //
    // *   Private Calls   * //
    // ********************* //

    /**
     * @dev Private function. Updates users index
     *
     * @param code project code represented by bytes32 array
     * @param kudos votes total given to the project by sender
     */
    function updateUsersIndex(bytes32 code, uint kudos) private {

        UserIndex idx = usersIndex[msg.sender];
        uint i = idx.kudosIdx[code];

        // add new entry to index
        if (i == 0) {
            i = idx.projects.length + 1;
            idx.projects.length += 1;
            idx.kudos.length += 1;
            idx.projects[i - 1] = code;
            idx.kudosIdx[code] = i;
        }

        idx.kudos[i - 1] = kudos;
    }


    // ********************* //
    // *     Modifiers     * //
    // ********************* //

    /**
     * @dev Throws if called not by contract's owner
     */
    modifier onlyOwner() {
        if (msg.sender != owner) throw;
        _;
    }
}",S
0xb4e348c10b8f1dcf2b5bc524f1f2ab912fde4048,Safe,"/* An elliptic curve arithmetics contract */

/* Deployment:
Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e
Last address: 0xc75175d7de7e8036f7c00a8e89f30dcf6e733f2e
ABI: [{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""},{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""}],""name"":""jadd"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_pub1"",""type"":""uint256""},{""name"":""_pub2"",""type"":""uint256""}],""name"":""hash_pubkey_to_pubkey"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_x"",""type"":""uint256""},{""name"":""_y_bit"",""type"":""uint256""}],""name"":""jrecover_y"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_q0"",""type"":""uint256""},{""name"":""_q1"",""type"":""uint256""},{""name"":""_q2"",""type"":""uint256""}],""name"":""jdecompose"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""}],""name"":""jdouble"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_data"",""type"":""uint256""},{""name"":""_bit"",""type"":""uint256""}],""name"":""isbit"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_b"",""type"":""uint256""},{""name"":""_e"",""type"":""uint256""},{""name"":""_m"",""type"":""uint256""}],""name"":""jexp"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""},{""name"":""_n"",""type"":""uint256""}],""name"":""jmul"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""inputs"":[],""type"":""constructor""},{""payable"":false,""type"":""fallback""}]
Optimized: yes
Solidity version: v0.4.4
*/

pragma solidity ^0.4.0;

contract ArithLib {

    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;
    uint constant internal N = 115792089237316195423570985008687907852837564279074904382605163141518161494337;
    uint constant internal M = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;
    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;

    function ArithLib() { }

    function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);

        uint nx = (
            //m * m
            (3 * _ax * _ax) * (3 * _ax * _ax) -
            //2 * s
            2 * (4 * _ax * (_ay * _ay))) % P;

        uint ny = (
            //m
            (3 * _ax * _ax) *
            //s - nx
            ((4 * _ax * (_ay * _ay)) - nx) -
            //8 * ysq * ysq
            8 * (_ay * _ay) * (_ay * _ay)) % P;

        uint nz = (2 * _ay * _az) % P;
        return (nx, ny, nz);
    }

    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint) {

        if(_ay == 0) return(_bx, _by, _bz);
        if(_by == 0) return(_ax, _ay, _az);

        uint u1 = (_ax * _bz * _bz) % P;
        uint u2 = (_bx * _az * _az) % P;
        _bx = (_ay * _bz * _bz * _bz) % P;
        _by = (_by * _az * _az * _az) % P;

        //u1 == u2
        if(u1 == u2) {
           //s1 != s2
           if(_bx != _by) return(0, 0, 1);
           return jdouble(_ax, _ay, _az);
        }

        uint nx = ((_by - _bx) * (_by - _bx) - (u2 - u1) * (u2 - u1) * (u2 - u1) - 2 * u1 * (u2 - u1) * (u2 - u1)) % P;

        return (
            nx,
            ((_by - _bx) * (u1 * (u2 - u1) * (u2 - u1) - nx) - _bx * (u2 - u1) * (u2 - u1) * (u2 - u1)) % P,
            ((u2 - u1) * _az * _bz) % P);
    }

    function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint) {

        _n = _n % N;
        if(((_by == 0)) || (_n == 0)) return(0, 0, 1);

        uint ax = 0;
        uint ay = 0;
        uint az = 1;
        uint b = M;

        while(b > 0) {

           (ax, ay, az) = jdouble(ax, ay, az);
           if((_n & b) != 0) {

              if(ay == 0) {
                 (ax, ay, az) = (_bx, _by, _bz);
              } else {
                 (ax, ay, az) = jadd(ax, ay, az, _bx, _by, _bz);
              }
           }

           b = b / 2;
        }

        return (ax, ay, az);
    }

    function jexp(uint _b, uint _e, uint _m) constant returns (uint) {
        uint o = 1;
        uint bit = M;

        while (bit > 0) {
            uint bitval = 0;
            if(_e & bit > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 2) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 4) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 8) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bit = (bit / 16);
        }
        return o;
    }

    function jrecover_y(uint _x, uint _y_bit) constant returns (uint) {

        uint xcubed = mulmod(mulmod(_x, _x, P), _x, P);
        uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
        uint y_is_positive = _y_bit ^ (beta % 2) ^ 1;
        return(beta * y_is_positive + (P - beta) * (1 - y_is_positive));
    }

    function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint) {
        uint ox = mulmod(_q0, jexp(_q2, P - 3, P), P);
        uint oy = mulmod(_q1, jexp(_q2, P - 4, P), P);
        return(ox, oy);
    }

    function isbit(uint _data, uint _bit) constant returns (uint) {
        return (_data / 2**(_bit % 8)) % 2;
    }

    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint) {
        uint x = uint(sha3(_pub1, _pub2));
        while(true) {
            uint xcubed = mulmod(mulmod(x, x, P), x, P);
            uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
            uint y = beta * (beta % 2) + (P - beta) * (1 - (beta % 2));
            if(addmod(xcubed, 7, P) == mulmod(y, y, P)) return(x, y);
            x = ((x + 1) % P);
        }
    }

    function () {
        throw;
    }
}",S
0xf884e0096f826f82d9999dc11becb836dbb7c1f7,Safe,"/* */

/* Deployment:
Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e
Last address: TBD
ABI: TBD
Optimized: yes
Solidity version: v0.4.3
*/

pragma solidity ^0.4.0;

contract Arith {

    address private owner;
    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;
    uint constant internal N = 115792089237316195423570985008687907852837564279074904382605163141518161494337;
    uint constant internal M = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;
    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;

    uint k1x;
    uint k1y;
    uint k1z;
    uint k2x;
    uint k2y;
    uint k2z;
    uint pub1x;
    uint pub1y;
    uint pub2x;
    uint pub2y;
    uint k3x;
    uint k3y;

    modifier onlyOwner {
        if (msg.sender != owner)
          throw;
        _;
    }

    function Arith() { owner = msg.sender; }

    function kill() onlyOwner { suicide(owner); }

    function jdouble(uint _ax, uint _ay, uint _az) returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);

        uint ysq = _ay * _ay;
        uint s = 4 * _ax * ysq;
        uint m = 3 * _ax * _ax;
        uint nx = m * m - 2 * s;
        uint ny = m * (s - nx) - 8 * ysq * ysq;
        uint nz = 2 * _ay * _az;
        return (nx, ny, nz);
    }

    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);
        if(_ay == 0) return(_bx, _by, _bz);
        if(_by == 0) return(_ax, _ay, _az);

        uint u1 = _ax * _bz * _bz;
        uint u2 = _bx * _az * _az;
        uint s1 = _ay * _bz * _bz * _bz;
        uint s2 = _by * _az * _az * _az;

        if(u1 == u2) {
           if(s1 != s2) return(0, 0, 1);
           return jdouble(_ax, _ay, _az);
        }

        uint nx = (s2 - s1) * (s2 - s1) - (u2 - u1) * (u2 - u1) * (u2 - u1) - 2 * u1 * (u2 - u1) * (u2 - u1);

        return
            (nx,
             (s2 - s1) * (u1 * (u2 - u1) * (u2 - u1) - nx) - s1 * (u2 - u1) * (u2 - u1) * (u2 - u1),
             (u2 - u1) * _az * _bz);
    }

    function jmul(uint _bx, uint _by, uint _bz, uint _n) returns (uint, uint, uint) {

        _n = _n % N;
        if(((_bx == 0) && (_by == 0)) || (_n == 0)) return(0, 0, 1);

        uint ax;
        uint ay;
        uint az;
        (ax, ay, az) = (0, 0, 1);
        uint b = M;

        while(b > 0) {

           (ax, ay, az) = jdouble(ax, ay, az);
           if((_n & b) != 0) {

              if(ay == 0) {
                 (ax, ay, az) = (_bx, _by, _bz);
              } else {
                 (ax, ay, az) = jadd(ax, ay, az, _bx, _by, _bz);
              }
           }

           b = b / 2;
        }

        return (ax, ay, az);
    }

    function jexp(uint _b, uint _e, uint _m) returns (uint) {
        uint o = 1;
        uint bit = M;

        while (bit > 0) {
            uint bitval = 0;
            if(_e & bit > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 2) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 4) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 8) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bit = (bit / 16);
        }
        return o;
    }

    function jrecover_y(uint _x, uint _y_bit) returns (uint) {

        uint xcubed = mulmod(mulmod(_x, _x, P), _x, P);
        uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
        uint y_is_positive = _y_bit ^ (beta % 2) ^ 1;
        return(beta * y_is_positive + (P - beta) * (1 - y_is_positive));
    }

    function jdecompose(uint _q0, uint _q1, uint _q2) returns (uint, uint) {
        uint ox = mulmod(_q0, jexp(_q2, P - 3, P), P);
        uint oy = mulmod(_q1, jexp(_q2, P - 4, P), P);
        return(ox, oy);
    }

    function ecmul(uint _x, uint _y, uint _z, uint _n) returns (uint, uint, uint) {
        return jmul(_x, _y, _z, _n);
    }

    function ecadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) returns (uint, uint, uint) {
        return jadd(_ax, _ay, _az, _bx, _by, _bz);
    }

    function ecsubtract(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) returns (uint, uint, uint) {
        return jadd(_ax, _ay, _az, _bx, P - _by, _bz);
    }

    function bit(uint _data, uint _bit) returns (uint) {
        return (_data / 2**(_bit % 8)) % 2;
    }

    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) returns (uint, uint) {
        uint x = uint(sha3(_pub1, _pub2));
        while(true) {
            uint xcubed = mulmod(mulmod(x, x, P), x, P);
            uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
            uint y = beta * (beta % 2) + (P - beta) * (1 - (beta % 2));
            if(addmod(xcubed, 7, P) == mulmod(y, y, P)) return(x, y);
            x = ((x + 1) % P);
        }
    }

    function verify(uint _msgHash, uint _x0, uint[] _s, uint _Ix, uint _Iy, uint[] _pub_xs, uint[] _pub_ys) returns (bool) {
        //_Iy = jrecover_y(_Ix, _Iy);
        uint[] memory ex = new uint[](_pub_xs.length);
        uint[] memory ey = new uint[](_pub_xs.length);
        ex[0] = _x0;
        ey[0] = uint(sha3(_x0));
        uint i = 1;
        while(i < (_pub_xs.length + 1)) {

           //uint pub_yi = jrecover_y(_pub_xs[i % _pub_xs.length], bit(_pub_ys, i % _pub_xs.length));
           (k1x, k1y, k1z) = ecmul(Gx, Gy, 1, _s[(i - 1) % _pub_xs.length]);
           (k2x, k2y, k2z) = ecmul(_pub_xs[i % _pub_xs.length], _pub_ys[i % _pub_xs.length], 1, ey[(i - 1) % _pub_xs.length]);
           (k1x, k1y, k1z) = ecsubtract(k1x, k1y, k1z, k2x, k2y, k2z);
           (pub1x, pub1y) = jdecompose(k1x, k1y, k1z);
           (k3x, k3y) = hash_pubkey_to_pubkey(_pub_xs[i % _pub_xs.length], _pub_ys[i % _pub_xs.length]);
           (k1x, k1y, k1z) = ecmul(k3x, k3y, 1, _s[(i - 1) % _pub_xs.length]);
           (k2x, k2y, k2z) = ecmul(_Ix, _Iy, 1, ey[(i - 1) % _pub_xs.length]);
           (k1x, k1y, k1z) = ecsubtract(k1x, k1y, k1z, k2x, k2y, k2z);
           (pub2x, pub2y) = jdecompose(k1x, k1y, k1z);
           uint left = uint(sha3([_msgHash, pub1x, pub1y, pub2x, pub2y]));
           uint right = uint(sha3(left));
           ex[i] = left;
           ey[i] = right;
           i += 1;
        }

        return((ex[_pub_xs.length] == ex[0]) && (ey[_pub_xs.length] == ey[0]));
    }

    function () {
        throw;
    }
}",S
0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6,Safe,"/* An elliptic curve arithmetics contract */

/* Deployment:
Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e
Last address: 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6
ABI: [{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""},{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""}],""name"":""jadd"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_pub1"",""type"":""uint256""},{""name"":""_pub2"",""type"":""uint256""}],""name"":""hash_pubkey_to_pubkey"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_x"",""type"":""uint256""},{""name"":""_y_bit"",""type"":""uint256""}],""name"":""jrecover_y"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_q0"",""type"":""uint256""},{""name"":""_q1"",""type"":""uint256""},{""name"":""_q2"",""type"":""uint256""}],""name"":""jdecompose"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""},{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""}],""name"":""jsub"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""}],""name"":""jdouble"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_data"",""type"":""uint256""},{""name"":""_bit"",""type"":""uint256""}],""name"":""isbit"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_b"",""type"":""uint256""},{""name"":""_e"",""type"":""uint256""},{""name"":""_m"",""type"":""uint256""}],""name"":""jexp"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""},{""name"":""_n"",""type"":""uint256""}],""name"":""jmul"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""jtest"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""inputs"":[],""type"":""constructor""},{""payable"":false,""type"":""fallback""}]
Optimized: yes
Solidity version: v0.4.4
*/

pragma solidity ^0.4.0;

contract ArithLib {

    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;
    uint constant internal N = 115792089237316195423570985008687907852837564279074904382605163141518161494337;
    uint constant internal M = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;
    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;

    function ArithLib() { }

    function jtest() constant returns (uint) {

        return(0);
    }

    function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);

        uint ysq = mulmod(_ay, _ay, P);
        uint S = mulmod(
            mulmod(4, _ax, P),
            ysq,
            P);
        uint M = mulmod(
            mulmod(3, _ax, P),
            _ax,
            P);
        uint nx = addmod(
            mulmod(M, M, P),
            P - mulmod(2, S, P),
            P);
        uint ny = addmod(
            mulmod(M,
                addmod(S, P - nx, P),
                P),
            P - mulmod(ysq,
                mulmod(8, ysq, P),
                P),
            P);
        uint nz = mulmod(
            mulmod(2, _ay, P),
            _az,
            P);

        return (nx, ny, nz);
    }

    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint) {

        if(_ay == 0) return(_bx, _by, _bz);
        if(_by == 0) return(_ax, _ay, _az);

        uint u1 = mulmod(_ax, _bz, P);
        u1 = mulmod(u1, _bz, P);

        uint u2 = mulmod(_bx, _az, P);
        u2 = mulmod(u2, _az, P);

        _bx = mulmod(_ay, _bz, P);
        _bx = mulmod(_bx, _bz, P);
        _bx = mulmod(_bx, _bz, P);

        _by = mulmod(_by, _az, P);
        _by = mulmod(_by, _az, P);
        _by = mulmod(_by, _az, P);

        if(u1 == u2) {
           //s1 != s2
           if(_bx != _by) return(0, 0, 1);
           return jdouble(_ax, _ay, _az);
        }

        _az = mulmod(_az, _bz, P);
        _bz = addmod(u2, P - u1, P);
        _az = mulmod(_az, _bz, P);
        //_az contains nz
        //_bz contains h1

        uint h2 = mulmod(_bz, _bz, P);
        uint h3 = mulmod(_bz, h2, P);
        uint u1h2 = mulmod(u1, h2, P);
        _bz = addmod(_by, P - _bx, P);
        //_bz contains r

        _ax = mulmod(_bz, _bz, P);
        _ay = mulmod(2, u1h2, P);
        _ax = addmod(_ax, P - h3, P);
        _ax = addmod(_ax, P - _ay, P);

        _ay = addmod(u1h2, P - _ax, P);
        _ay = mulmod(_ay, _bz, P);
        h2 = mulmod(_bx, h3, P);
        _ay = addmod(_ay, P - h2, P);

        return(_ax, _ay, _az);
    }

    function jsub(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint) {
        return jadd(_ax, _ay, _az, _bx, P - _by, _bz);
    }

    function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint) {

        _n = _n % N;
        if(((_by == 0)) || (_n == 0)) return(0, 0, 1);

        uint ax = 0;
        uint ay = 0;
        uint az = 1;
        uint b = M;

        while(b > 0) {

           (ax, ay, az) = jdouble(ax, ay, az);
           if((_n & b) != 0) {

              if(ay == 0) {
                 (ax, ay, az) = (_bx, _by, _bz);
              } else {
                 (ax, ay, az) = jadd(ax, ay, az, _bx, _by, _bz);
              }
           }

           b = b / 2;
        }

        return (ax, ay, az);
    }

    function jexp(uint _b, uint _e, uint _m) constant returns (uint) {
        uint o = 1;
        uint bit = M;

        while (bit > 0) {
            uint bitval = 0;
            if(_e & bit > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 2) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 4) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 8) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bit = (bit / 16);
        }
        return o;
    }

    function jrecover_y(uint _x, uint _y_bit) constant returns (uint) {

        uint xcubed = mulmod(mulmod(_x, _x, P), _x, P);
        uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
        uint y_is_positive = _y_bit ^ (beta % 2) ^ 1;
        return(beta * y_is_positive + (P - beta) * (1 - y_is_positive));
    }

    function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint) {
        uint ox = mulmod(_q0, jexp(_q2, P - 3, P), P);
        uint oy = mulmod(_q1, jexp(_q2, P - 4, P), P);
        return(ox, oy);
    }

    function isbit(uint _data, uint _bit) constant returns (uint) {
        return (_data / 2**(_bit % 8)) % 2;
    }

    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint) {
        uint x = uint(sha3(_pub1, _pub2));
        while(true) {
            uint xcubed = mulmod(mulmod(x, x, P), x, P);
            uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
            uint y = beta * (beta % 2) + (P - beta) * (1 - (beta % 2));
            if(addmod(xcubed, 7, P) == mulmod(y, y, P)) return(x, y);
            x = ((x + 1) % P);
        }
    }

    function () {
        throw;
    }
}",S
0x401e28717a6a35a50938bc7f290f2678fc0a2816,Safe,"/* Deployment:
Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e
Last address: 0x401e28717a6a35a50938bc7f290f2678fc0a2816
ABI: [{""constant"":true,""inputs"":[],""name"":""gotParticipants"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_signature"",""type"":""uint256[]""},{""name"":""_x0"",""type"":""uint256""},{""name"":""_Ix"",""type"":""uint256""},{""name"":""_Iy"",""type"":""uint256""}],""name"":""withdrawStart"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""pubkeys2"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""payment"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""pubkeys1"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[],""name"":""participants"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""withdrawStep"",""outputs"":[],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[],""name"":""withdrawFinal"",""outputs"":[{""name"":"""",""type"":""bool""}],""payable"":false,""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_pubkey1"",""type"":""uint256""},{""name"":""_pubkey2"",""type"":""uint256""}],""name"":""deposit"",""outputs"":[],""payable"":true,""type"":""function""},{""inputs"":[{""name"":""_participants"",""type"":""uint256""},{""name"":""_payment"",""type"":""uint256""}],""type"":""constructor""},{""payable"":false,""type"":""fallback""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""message"",""type"":""string""}],""name"":""LogDebug"",""type"":""event""}]
Optimized: yes
Solidity version: v0.4.4
*/

pragma solidity ^0.4.0;

contract ArithLib {

    function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint);
    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint);
    function jsub(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint);
    function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint);
    function jexp(uint _b, uint _e, uint _m) constant returns (uint);
    function jrecover_y(uint _x, uint _y_bit) constant returns (uint);
    function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint);
    function isbit(uint _data, uint _bit) constant returns (uint);
    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint);
}

contract Laundromat {

    struct WithdrawInfo {

        address sender;
        uint Ix;
        uint Iy;
        uint[] signature;
        uint[] ring1;
        uint[] ring2;

        uint step;
        uint prevStep;
    }

    uint constant internal safeGas = 25000;
    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;
    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;
    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;

    address private owner;
    bool private atomicLock;

    address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6;
    ArithLib private arithContract;
    mapping (uint => WithdrawInfo) private withdraws;
    mapping (uint => bool) private consumed;

    uint public participants = 0;
    uint public payment = 0;
    uint public gotParticipants = 0;
    uint[] public pubkeys1;
    uint[] public pubkeys2;

    event LogDebug(string message);

    //create new mixing contract with _participants amount of mixing participants,
    //_payment - expected payment from each participant.
    function Laundromat(uint _participants, uint _payment) {
        owner = msg.sender;
        arithContract = ArithLib(arithAddress);

        participants = _participants;
        payment = _payment;
    }

    function safeSend(address addr, uint value) internal {

        if(atomicLock) throw;
        atomicLock = true;
        if (!(addr.call.gas(safeGas).value(value)())) {
            atomicLock = false;
            throw;
        }
        atomicLock = false;
    }

    //add new participant to the mixing
    function deposit(uint _pubkey1, uint _pubkey2) payable {
        //if(msg.value != payment) throw;
        if(gotParticipants >= participants) throw;

        pubkeys1.push(_pubkey1);
        pubkeys2.push(_pubkey2);
        gotParticipants++;
    }

    //get funds from the mixer. Requires valid signature.
    function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) {
        if(gotParticipants < participants) throw;
        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;

        WithdrawInfo withdraw = withdraws[uint(msg.sender)];

        withdraw.sender = msg.sender;
        withdraw.Ix = _Ix;
        withdraw.Iy = _Iy;
        withdraw.signature = _signature;

        withdraw.ring1.length = 0;
        withdraw.ring2.length = 0;
        withdraw.ring1.push(_x0);
        withdraw.ring2.push(uint(sha3(_x0)));

        withdraw.step = 1;
        withdraw.prevStep = 0;
    }

    function withdrawStep() {
        WithdrawInfo withdraw = withdraws[uint(msg.sender)];

        //throw if existing witdhraw not started
        if(withdraw.step < 1) throw;
        if(withdraw.step > participants) throw;
        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;

        uint k1x;
        uint k1y;
        uint k1z;
        uint k2x;
        uint k2y;
        uint k2z;
        uint pub1x;
        uint pub1y;

        (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1,
            withdraw.signature[withdraw.prevStep % participants]);
        (k2x, k2y, k2z) = arithContract.jmul(
            pubkeys1[withdraw.step % participants],
            pubkeys2[withdraw.step % participants], 1,
            withdraw.ring2[withdraw.prevStep % participants]);
        //ksub1
        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);
        (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z);
        //k3
        (k1x, k1y) = arithContract.hash_pubkey_to_pubkey(
            pubkeys1[withdraw.step % participants],
            pubkeys2[withdraw.step % participants]);
        //k4 = ecmul(k3, s[prev_i])
        (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1,
            withdraw.signature[withdraw.prevStep % participants]);
        //k5 = ecmul(I, e[prev_i].right)
        (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1,
            withdraw.ring2[withdraw.prevStep % participants]);
        //ksub2
        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);
        //pub2x, pub2y
        (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z);
        withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])));
        withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])))));
        withdraw.step++;
        withdraw.prevStep++;
    }

    function withdrawFinal() returns (bool) {
        WithdrawInfo withdraw = withdraws[uint(msg.sender)];

        if(withdraw.step != (participants + 1)) throw;
        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;
        if(withdraw.ring1[participants] != withdraw.ring1[0]) {

            LogDebug(""Wrong signature"");
            return false;
        }
        if(withdraw.ring2[participants] != withdraw.ring2[0]) {

            LogDebug(""Wrong signature"");
            return false;
        }

        withdraw.step++;
        consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true;
        safeSend(withdraw.sender, payment);
        return true;
    }

    function () {
        throw;
    }
}",S
0x2bcca955c9200c9a5f888bc2b14b91aaa56cd5c5,Safe,"/*

Etherandom v1.0 [API]

Copyright (c) 2016, Etherandom [etherandom.com]
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL ETHERANDOM BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

contract EtherandomI {
  address public addr;
  function seed() returns (bytes32 _id);
  function seedWithGasLimit(uint _gasLimit) returns (bytes32 _id);
  function exec(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality) returns (bytes32 _id);
  function execWithGasLimit(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality, uint _gasLimit) returns (bytes32 _id);
  function getSeedCost(uint _gasLimit) constant returns (uint _cost);
  function getExecCost(uint _gasLimit) constant returns (uint _cost);
  function getMinimumGasLimit() constant returns (uint _minimumGasLimit);
}

contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr);
  function getCallbackAddress() constant returns (address _addr);
}

contract EtherandomizedI {
  function onEtherandomSeed(bytes32 _id, bytes32 serverSeedHash);
  function onEtherandomExec(bytes32 _id, bytes32 serverSeed, uint randomNumber);
}

contract etherandomized {
  EtherandomProxyI EAR;
  EtherandomI etherandom;

  modifier etherandomAPI {
    address addr = EAR.getContractAddress();
    if (addr == 0) {
      etherandomSetNetwork();
      addr = EAR.getContractAddress();
    }
    etherandom = EtherandomI(addr);
    _
  }

  function etherandomSetNetwork() internal returns (bool) {
    if (getCodeSize(0x5be0372559e0275c0c415ab48eb0e211bc2f52a8)>0){
      EAR = EtherandomProxyI(0x5be0372559e0275c0c415ab48eb0e211bc2f52a8);
      return true;
    }
    if (getCodeSize(0xf6d9979499491c1c0c9ef518860f4476c1cd551a)>0){
      EAR = EtherandomProxyI(0xf6d9979499491c1c0c9ef518860f4476c1cd551a);
      return true;
    }
    return false;
  }

  function getCodeSize(address _addr) constant internal returns (uint _size) {
    assembly { _size := extcodesize(_addr) }
  }

  function etherandomSeed() etherandomAPI internal returns (bytes32 _id) {
    uint cost = etherandom.getSeedCost(etherandom.getMinimumGasLimit());
    return etherandom.seed.value(cost)();
  }

  function etherandomSeedWithGasLimit(uint gasLimit) etherandomAPI internal returns (bytes32 _id) {
    uint cost = etherandom.getSeedCost(gasLimit);
    return etherandom.seedWithGasLimit.value(cost)(gasLimit);
  }

  function etherandomExec(bytes32 serverSeedHash, bytes32 clientSeed, uint cardinality) etherandomAPI internal returns (bytes32 _id) {
    uint cost = etherandom.getExecCost(etherandom.getMinimumGasLimit());
    return etherandom.exec.value(cost)(serverSeedHash, clientSeed, cardinality);
  }

  function etherandomExecWithGasLimit(bytes32 serverSeedHash, bytes32 clientSeed, uint cardinality, uint gasLimit) etherandomAPI internal returns (bytes32 _id) {
    uint cost = etherandom.getExecCost(gasLimit);
    return etherandom.execWithGasLimit.value(cost)(serverSeedHash, clientSeed, cardinality, gasLimit);
  }

  function etherandomCallbackAddress() internal returns (address _addr) {
    return EAR.getCallbackAddress();
  }

  function etherandomVerify(bytes32 serverSeedHash, bytes32 serverSeed, bytes32 clientSeed, uint cardinality, uint randomNumber) internal returns (bool _verified) {
    if (sha3(serverSeed) != serverSeedHash) return false;
    uint num = addmod(uint(serverSeed), uint(clientSeed), cardinality);
    return num == randomNumber;
  }

  function() {
    throw;
  }
}


contract Dice is etherandomized {
  struct Roll {
    address bettor;
    bytes32 clientSeed;
  }

  address owner;
  uint pendingAmount;
  mapping (bytes32 => Roll) pendingSeed;
  mapping (bytes32 => Roll) pendingExec;
  mapping (bytes32 => bytes32) serverSeedHashes;

  function Dice() {
    owner = msg.sender;
  }

  function getAvailable() returns (uint _available) {
    return this.balance - pendingAmount;
  }

  function roll() {
    rollWithSeed("""");
  }

  function rollWithSeed(bytes32 clientSeed) {
    if ( (msg.value != 1) || (getAvailable() < 2)) throw;
    bytes32 _id = etherandomSeed();
    pendingSeed[_id] = Roll({bettor: msg.sender, clientSeed: clientSeed});
    pendingAmount = pendingAmount + 2;
  }

  function onEtherandomSeed(bytes32 _id, bytes32 serverSeedHash) {
    if (msg.sender != etherandomCallbackAddress()) throw;
    Roll roll = pendingSeed[_id];
    bytes32 _execID = etherandomExec(serverSeedHash, roll.clientSeed, 100);
    pendingExec[_execID] = roll;
    serverSeedHashes[_execID] = serverSeedHash;
    delete pendingSeed[_id];
  }

  function onEtherandomExec(bytes32 _id, bytes32 serverSeed, uint randomNumber) {
    if (msg.sender != etherandomCallbackAddress()) throw;
    Roll roll = pendingExec[_id];
    bytes32 serverSeedHash = serverSeedHashes[_id];

    pendingAmount = pendingAmount - 2;

    if (etherandomVerify(serverSeedHash, serverSeed, roll.clientSeed, 100, randomNumber)) {
      if (randomNumber < 50) roll.bettor.send(2);
    } else {
      roll.bettor.send(1);
    }

    delete serverSeedHashes[_id];
    delete pendingExec[_id];
  }
}",S
0x7da82c7ab4771ff031b66538d2fb9b0b047f6cf9,Safe,"pragma solidity ^0.4.4;


/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.
/// @author Stefan George - <stefan.george@consensys.net>
contract MultiSigWallet {

    event Confirmation(address sender, bytes32 transactionHash);
    event Revocation(address sender, bytes32 transactionHash);
    event Submission(bytes32 transactionHash);
    event Execution(bytes32 transactionHash);
    event Deposit(address sender, uint value);
    event OwnerAddition(address owner);
    event OwnerRemoval(address owner);
    event RequiredUpdate(uint required);

    mapping (bytes32 => Transaction) public transactions;
    mapping (bytes32 => mapping (address => bool)) public confirmations;
    mapping (address => bool) public isOwner;
    address[] owners;
    bytes32[] transactionList;
    uint public required;

    struct Transaction {
        address destination;
        uint value;
        bytes data;
        uint nonce;
        bool executed;
    }

    modifier onlyWallet() {
        if (msg.sender != address(this))
            throw;
        _;
    }

    modifier signaturesFromOwners(bytes32 transactionHash, uint8[] v, bytes32[] rs) {
        for (uint i=0; i<v.length; i++)
            if (!isOwner[ecrecover(transactionHash, v[i], rs[i], rs[v.length + i])])
                throw;
        _;
    }

    modifier ownerDoesNotExist(address owner) {
        if (isOwner[owner])
            throw;
        _;
    }

    modifier ownerExists(address owner) {
        if (!isOwner[owner])
            throw;
        _;
    }

    modifier confirmed(bytes32 transactionHash, address owner) {
        if (!confirmations[transactionHash][owner])
            throw;
        _;
    }

    modifier notConfirmed(bytes32 transactionHash, address owner) {
        if (confirmations[transactionHash][owner])
            throw;
        _;
    }

    modifier notExecuted(bytes32 transactionHash) {
        if (transactions[transactionHash].executed)
            throw;
        _;
    }

    modifier notNull(address destination) {
        if (destination == 0)
            throw;
        _;
    }

    modifier validRequired(uint _ownerCount, uint _required) {
        if (   _required > _ownerCount
            || _required == 0
            || _ownerCount == 0)
            throw;
        _;
    }

    function addOwner(address owner)
        external
        onlyWallet
        ownerDoesNotExist(owner)
    {
        isOwner[owner] = true;
        owners.push(owner);
        OwnerAddition(owner);
    }

    function removeOwner(address owner)
        external
        onlyWallet
        ownerExists(owner)
    {
        isOwner[owner] = false;
        for (uint i=0; i<owners.length - 1; i++)
            if (owners[i] == owner) {
                owners[i] = owners[owners.length - 1];
                break;
            }
        owners.length -= 1;
        if (required > owners.length)
            updateRequired(owners.length);
        OwnerRemoval(owner);
    }

    function updateRequired(uint _required)
        public
        onlyWallet
        validRequired(owners.length, _required)
    {
        required = _required;
        RequiredUpdate(_required);
    }

    function addTransaction(address destination, uint value, bytes data, uint nonce)
        private
        notNull(destination)
        returns (bytes32 transactionHash)
    {
        transactionHash = sha3(destination, value, data, nonce);
        if (transactions[transactionHash].destination == 0) {
            transactions[transactionHash] = Transaction({
                destination: destination,
                value: value,
                data: data,
                nonce: nonce,
                executed: false
            });
            transactionList.push(transactionHash);
            Submission(transactionHash);
        }
    }

    function submitTransaction(address destination, uint value, bytes data, uint nonce)
        external
        returns (bytes32 transactionHash)
    {
        transactionHash = addTransaction(destination, value, data, nonce);
        confirmTransaction(transactionHash);
    }

    function submitTransactionWithSignatures(address destination, uint value, bytes data, uint nonce, uint8[] v, bytes32[] rs)
        external
        returns (bytes32 transactionHash)
    {
        transactionHash = addTransaction(destination, value, data, nonce);
        confirmTransactionWithSignatures(transactionHash, v, rs);
    }

    function addConfirmation(bytes32 transactionHash, address owner)
        private
        notConfirmed(transactionHash, owner)
    {
        confirmations[transactionHash][owner] = true;
        Confirmation(owner, transactionHash);
    }

    function confirmTransaction(bytes32 transactionHash)
        public
        ownerExists(msg.sender)
    {
        addConfirmation(transactionHash, msg.sender);
        executeTransaction(transactionHash);
    }

    function confirmTransactionWithSignatures(bytes32 transactionHash, uint8[] v, bytes32[] rs)
        public
        signaturesFromOwners(transactionHash, v, rs)
    {
        for (uint i=0; i<v.length; i++)
            addConfirmation(transactionHash, ecrecover(transactionHash, v[i], rs[i], rs[i + v.length]));
        executeTransaction(transactionHash);
    }

    function executeTransaction(bytes32 transactionHash)
        public
        notExecuted(transactionHash)
    {
        if (isConfirmed(transactionHash)) {
            Transaction tx = transactions[transactionHash];
            tx.executed = true;
            if (!tx.destination.call.value(tx.value)(tx.data))
                throw;
            Execution(transactionHash);
        }
    }

    function revokeConfirmation(bytes32 transactionHash)
        external
        ownerExists(msg.sender)
        confirmed(transactionHash, msg.sender)
        notExecuted(transactionHash)
    {
        confirmations[transactionHash][msg.sender] = false;
        Revocation(msg.sender, transactionHash);
    }

    function MultiSigWallet(address[] _owners, uint _required)
        validRequired(_owners.length, _required)
    {
        for (uint i=0; i<_owners.length; i++)
            isOwner[_owners[i]] = true;
        owners = _owners;
        required = _required;
    }

    function()
        payable
    {
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }

    function isConfirmed(bytes32 transactionHash)
        public
        constant
        returns (bool)
    {
        uint count = 0;
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionHash][owners[i]])
                count += 1;
            if (count == required)
                return true;
    }

    function confirmationCount(bytes32 transactionHash)
        external
        constant
        returns (uint count)
    {
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionHash][owners[i]])
                count += 1;
    }

    function filterTransactions(bool isPending)
        private
        returns (bytes32[] _transactionList)
    {
        bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length);
        uint count = 0;
        for (uint i=0; i<transactionList.length; i++)
            if (   isPending && !transactions[transactionList[i]].executed
                || !isPending && transactions[transactionList[i]].executed)
            {
                _transactionListTemp[count] = transactionList[i];
                count += 1;
            }
        _transactionList = new bytes32[](count);
        for (i=0; i<count; i++)
            if (_transactionListTemp[i] > 0)
                _transactionList[i] = _transactionListTemp[i];
    }

    function getPendingTransactions()
        external
        constant
        returns (bytes32[] _transactionList)
    {
        return filterTransactions(true);
    }

    function getExecutedTransactions()
        external
        constant
        returns (bytes32[] _transactionList)
    {
        return filterTransactions(false);
    }
}",S
0xc75175d7de7e8036f7c00a8e89f30dcf6e733f2e,Safe,"/* An elliptic curve arithmetics contract */

/* Deployment:
Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e
Last address: 0xc75175d7de7e8036f7c00a8e89f30dcf6e733f2e
ABI: [{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""},{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""}],""name"":""jadd"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_pub1"",""type"":""uint256""},{""name"":""_pub2"",""type"":""uint256""}],""name"":""hash_pubkey_to_pubkey"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_x"",""type"":""uint256""},{""name"":""_y_bit"",""type"":""uint256""}],""name"":""jrecover_y"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_q0"",""type"":""uint256""},{""name"":""_q1"",""type"":""uint256""},{""name"":""_q2"",""type"":""uint256""}],""name"":""jdecompose"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_ax"",""type"":""uint256""},{""name"":""_ay"",""type"":""uint256""},{""name"":""_az"",""type"":""uint256""}],""name"":""jdouble"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_data"",""type"":""uint256""},{""name"":""_bit"",""type"":""uint256""}],""name"":""isbit"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_b"",""type"":""uint256""},{""name"":""_e"",""type"":""uint256""},{""name"":""_m"",""type"":""uint256""}],""name"":""jexp"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""constant"":true,""inputs"":[{""name"":""_bx"",""type"":""uint256""},{""name"":""_by"",""type"":""uint256""},{""name"":""_bz"",""type"":""uint256""},{""name"":""_n"",""type"":""uint256""}],""name"":""jmul"",""outputs"":[{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""},{""name"":"""",""type"":""uint256""}],""payable"":false,""type"":""function""},{""inputs"":[],""type"":""constructor""},{""payable"":false,""type"":""fallback""}]
Optimized: yes
Solidity version: v0.4.4
*/

pragma solidity ^0.4.0;

contract ArithLib {

    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;
    uint constant internal N = 115792089237316195423570985008687907852837564279074904382605163141518161494337;
    uint constant internal M = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;
    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;

    function ArithLib() { }

    function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);

        uint ysq = (_ay * _ay) % P;
        uint s = (4 * _ax * ysq) % P;
        uint m = (3 * _ax * _ax) % P;
        uint nx = (m * m - 2 * s) % P;
        uint ny = (m * (s - nx) - 8 * ysq * ysq) % P;
        uint nz = (2 * _ay * _az) % P;
        return (nx, ny, nz);
    }

    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint) {

        if(_ay == 0) return(_bx, _by, _bz);
        if(_by == 0) return(_ax, _ay, _az);

        uint u1 = (_ax * _bz * _bz) % P;
        uint u2 = (_bx * _az * _az) % P;
        uint s1 = (_ay * _bz * _bz * _bz) % P;
        uint s2 = (_by * _az * _az * _az) % P;

        if(u1 == u2) {
           if(s1 != s2) return(0, 0, 1);
           return jdouble(_ax, _ay, _az);
        }

        //H
        _ax = u2 - u1;
        //R
        _ay = s2 - s1;
        //H2
        _bx = (_ax * _ax) % P;
        //H3
        _by = (_ax * _bx) % P;
        //U1H2
        u1 = (u1 * _bx) % P;
        //nx
        u2 = (_ay * _ay - _by - 2 * u1) % P;
        //ny
        s1 = (_ay * (u1 - u2) - s1 * _by) % P;
        //nz
        s2 = (_ax * _az * _bz) % P;

        return (u2, s1, s2);
    }

    function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint) {

        _n = _n % N;
        if(((_by == 0)) || (_n == 0)) return(0, 0, 1);

        uint ax = 0;
        uint ay = 0;
        uint az = 1;
        uint b = M;

        while(b > 0) {

           (ax, ay, az) = jdouble(ax, ay, az);
           if((_n & b) != 0) {

              if(ay == 0) {
                 (ax, ay, az) = (_bx, _by, _bz);
              } else {
                 (ax, ay, az) = jadd(ax, ay, az, _bx, _by, _bz);
              }
           }

           b = b / 2;
        }

        return (ax, ay, az);
    }

    function jexp(uint _b, uint _e, uint _m) constant returns (uint) {
        uint o = 1;
        uint bit = M;

        while (bit > 0) {
            uint bitval = 0;
            if(_e & bit > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 2) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 4) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 8) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bit = (bit / 16);
        }
        return o;
    }

    function jrecover_y(uint _x, uint _y_bit) constant returns (uint) {

        uint xcubed = mulmod(mulmod(_x, _x, P), _x, P);
        uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
        uint y_is_positive = _y_bit ^ (beta % 2) ^ 1;
        return(beta * y_is_positive + (P - beta) * (1 - y_is_positive));
    }

    function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint) {
        uint ox = mulmod(_q0, jexp(_q2, P - 3, P), P);
        uint oy = mulmod(_q1, jexp(_q2, P - 4, P), P);
        return(ox, oy);
    }

    function isbit(uint _data, uint _bit) constant returns (uint) {
        return (_data / 2**(_bit % 8)) % 2;
    }

    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint) {
        uint x = uint(sha3(_pub1, _pub2));
        while(true) {
            uint xcubed = mulmod(mulmod(x, x, P), x, P);
            uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
            uint y = beta * (beta % 2) + (P - beta) * (1 - (beta % 2));
            if(addmod(xcubed, 7, P) == mulmod(y, y, P)) return(x, y);
            x = ((x + 1) % P);
        }
    }

    function () {
        throw;
    }
}",S
0x5d4c95284d7b0a271c2c030cf803b24646ee0dcb,Safe,"// This MasterRegistry keeps a list of all registries created using Regis.
// From it, you can search registries by its name, tags or owner and retrieve
// registries info.

contract MasterRegistry {

    // This struct keeps a list of attributes that all registries have.
    struct RegistryAttributes {
        uint      creationTime;
        string    description;
        address   owner;
        string    name;
        bytes32[] tags;
        uint      version; // To keep backward compatibility
        uint      addressIndex; // Index in the addresses array for quick lookup.

        // Keeps the solidity source of the registry
        // Storing the source on the blockchain is expensive but it is worth it.
        // Previous version didn't store and was able to rebuild the registry
        // source from its parameters. But this showed to be problematic in
        // some cases.
        string source;
        // To keep backward compatibility with version 1, source will have
        // keyType and recordAttributes stored in the source variable and the
        // solidity source for those old registries will be unavailable.
    }

    // Maps registry's address to its record.
    mapping (address => RegistryAttributes) public registries;
    uint public numRegistries;

    // Keeps a list of all registries' addresses
    address[] public addresses;

    // maps owner -> list of registries' addresses
    mapping (address => address[]) public indexedByOwner;

    // maps tag -> list of registries' addresses
    mapping (bytes32 => address[]) public indexedByTag;

    // maps name -> list of registries' addresses
    mapping (string => address[]) indexedByName; // cant use public here because it's indexed by string

    modifier onlyOwner(address regAddress) {
        if (registries[regAddress].owner != msg.sender) throw;
        _
    }

    function addRegistryIntoOwnerIndex(address regAddress, address owner) internal {
        address[] regs = indexedByOwner[owner];
        regs.length++;
        regs[regs.length - 1] = regAddress;
    }

    function addRegistryIntoNameIndex(address regAddress) internal {
        address[] regs = indexedByName[registries[regAddress].name];
        regs.length++;
        regs[regs.length - 1] = regAddress;
    }

    function addRegistryIntoTagsIndex(address regAddress) internal {
        bytes32[] tags = registries[regAddress].tags;
        for (uint i = 0; i < tags.length; i++) {
            address[] regs = indexedByTag[tags[i]];
            regs.length++;
            regs[regs.length - 1] = regAddress;
        }
    }

    function register(address regAddress, address owner, string name, string description,
                      bytes32[] tags, uint version, string source) {

        if (registries[regAddress].creationTime != 0) {
            // throw;
            return;
        }

        registries[regAddress].creationTime = now;
        //registries[regAddress].owner        = msg.sender;
        registries[regAddress].owner        = owner;
        registries[regAddress].description  = description;
        registries[regAddress].name         = name;
        registries[regAddress].version      = version;
        registries[regAddress].tags         = tags;
        registries[regAddress].source       = source;
        registries[regAddress].addressIndex = numRegistries;
        numRegistries++;

        addresses.length++;
        addresses[numRegistries - 1] = regAddress;

        addRegistryIntoOwnerIndex(regAddress, owner);

        addRegistryIntoNameIndex(regAddress);

        addRegistryIntoTagsIndex(regAddress);

    }

    function removeRegistryFromOwnerIndex(address regAddress) internal {
        address[] regs = indexedByOwner[msg.sender];
        for (uint i = 0; i < regs.length; i++) {
            if (regs[i] == regAddress) {
                regs[i] = regs[regs.length - 1];
                regs.length--;
                break;
            }
        }
    }

    function removeRegistryFromNameIndex(address regAddress) internal {
        address[] regs = indexedByName[registries[regAddress].name];
        for (uint j = 0; j < regs.length; j++) {
            if (regs[j] == regAddress) {
                regs[j] = regs[regs.length - 1];
                regs.length--;
                break;
            }
        }
    }

    function removeRegistryFromTagsIndex(address regAddress) internal {
        uint numTags = registries[regAddress].tags.length;
        for (uint k = 0; k < numTags; k++) {
            address[] regs = indexedByTag[registries[regAddress].tags[k]];
            for (uint l = 0; l < regs.length; l++) {
                if (regs[l] == regAddress) {
                    regs[l] = regs[regs.length - 1];
                    regs.length--;
                    break;
                }
            }
        }
    }

    function unregister(address regAddress) onlyOwner(regAddress) {

        removeRegistryFromOwnerIndex(regAddress);
        removeRegistryFromNameIndex(regAddress);
        removeRegistryFromTagsIndex(regAddress);

        addresses[registries[regAddress].addressIndex] = addresses[addresses.length - 1];
        addresses.length--;

        delete registries[regAddress];
        numRegistries--;
    }

    function changeDescription(address regAddress, string newDescription) onlyOwner(regAddress) {
        registries[regAddress].description = newDescription;
    }

    function changeName(address regAddress, string newName) onlyOwner(regAddress) {
        removeRegistryFromNameIndex(regAddress);
        registries[regAddress].name = newName;
        addRegistryIntoNameIndex(regAddress);
    }

    function transfer(address regAddress, address newOwner) onlyOwner(regAddress) {
        removeRegistryFromOwnerIndex(regAddress);
        registries[regAddress].owner = newOwner;
        addRegistryIntoOwnerIndex(regAddress, newOwner);
    }

    function searchByName(string name) constant returns (address[]) {
        return indexedByName[name];
    }

    function searchByTag(bytes32 tag) constant returns (address[]) {
        return indexedByTag[tag];
    }

    function searchByOwner(address owner) constant returns (address[]) {
        return indexedByOwner[owner];
    }

    function getRegInfo(address regAddress) constant returns (address owner, uint creationTime,
                        string name, string description, uint version, bytes32[] tags, string source) {
        owner        = registries[regAddress].owner;
        creationTime = registries[regAddress].creationTime;
        name         = registries[regAddress].name;
        description  = registries[regAddress].description;
        version      = registries[regAddress].version;
        tags         = registries[regAddress].tags;
        source       = registries[regAddress].source;
    }

    // This function is only valid for a very small amount of time
    // after which it will become useless!
    // It was used to migrate registries from old MasterRegistry
    // into this new one and fix old registries creation_time (which
    // are now inside the registry itself).
    function setTime(address regAddress, uint time) {
        if (now < 1469830946) { // Valid up to 29-Jul-2016 19:22:26
            registries[regAddress].creationTime = time;
        }
    }

}",S
0x460dc8b70a189bee176d22d3f0272d171bd4c5ed,Safe,"/**
 * The Edgeless token contract complies with the ERC20 standard.
 * Additionally tokens can be locked for a defined time interval by token holders.
 * author: Julia Altenried
 * */

pragma solidity ^0.4.6;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract EdgelessToken {
    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Edgeless';
    string public symbol = 'EDG';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    uint256 public currentInterval = 1;
    uint256 public intervalLength = 30 days;
    uint256 public startTime = 1485878400;//from this time on tokens may be transfered (after ICO)
    address public owner;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* Defines how many tokens of which addresses are locked in which interval*/
    mapping(address => mapping(uint256=>uint256)) public locked;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Lock(address indexed owner, uint256 interval, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function EdgelessToken() {
        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;
        balanceOf[owner] = 500000000;              // Give the owner all initial tokens
        totalSupply = 500000000;                        // Update total supply
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) returns (bool success){
        if (now < startTime) throw; //check if the crowdsale is already over
        if (balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        return true;
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over
        if (balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* Lock a number of tokens */
    function lock(address holder, uint256 _value) returns (bool success) {
        if(holder==msg.sender||holder==tx.origin){
            locked[holder][getInterval()]+=_value;
            Lock(holder, currentInterval, _value);
            return true;
        }
    }

    /* Increase the interval, if sufficient time has passed */
    function getInterval() returns (uint256 interval){
        if (now > currentInterval * intervalLength + startTime) {
            currentInterval = (now - startTime) / intervalLength + 1;
        }
        return currentInterval;
    }

}",92: time manipulation;
0xe5544a2a5fa9b175da60d8eec67add5582bb31b0,Safe,"// Most of the code taken from
// https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/StandardToken.sol

contract TokenInterface {

    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract HashToken is TokenInterface {

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;

    bytes32 public prev_hash;
    uint public max_value;

    // Meta info
    string public name;
    uint8 public decimals;
    string public symbol;

    function HashToken() {
        prev_hash = sha3(block.blockhash(block.number));
        max_value = 2 ** 255;
        // Meta info
        name = 'HashToken';
        decimals = 16;
        symbol = 'HTK';
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    event Mint(address indexed minter);

    function mint(bytes32 value) {
        if (uint(sha3(value, prev_hash)) > max_value) {
            throw;
        }
        balances[msg.sender] += 10 ** 16;
        prev_hash = sha3(block.blockhash(block.number), prev_hash);
        // increase the difficulty
        max_value -=  max_value / 100;
        Mint(msg.sender);
    }
}",S
0x70A8629c1B9A50133C5325502232Bd54447BEeE7,Safe,"pragma solidity ^0.4.8;
contract Soarcoin {

    mapping (address => uint256) balances;               // each address in this contract may have tokens.
    address internal owner = 0x4Bce8E9850254A86a1988E2dA79e41Bc6793640d;                // the owner is the creator of the smart contract
    string public name = ""Soarcoin"";                     // name of this contract and investment fund
    string public symbol = ""SOAR"";                       // token symbol
    uint8 public decimals = 6;                           // decimals (for humans)
    uint256 public totalSupply = 5000000000000000;

    modifier onlyOwner()
    {
        if (msg.sender != owner) throw;
        _;
    }

    function Soarcoin() { balances[owner] = totalSupply; }

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // query balance
    function balanceOf(address _owner) constant returns (uint256 balance)
    {
        return balances[_owner];
    }

    // transfer tokens from one address to another
    function transfer(address _to, uint256 _value) returns (bool success)
    {
        if(_value <= 0) throw;                                      // Check send token value > 0;
        if (balances[msg.sender] < _value) throw;                   // Check if the sender has enough
        if (balances[_to] + _value < balances[_to]) throw;          // Check for overflows
        balances[msg.sender] -= _value;                             // Subtract from the sender
        balances[_to] += _value;                                    // Add the same to the recipient, if it's the contact itself then it signals a sell order of those tokens
        Transfer(msg.sender, _to, _value);                          // Notify anyone listening that this transfer took place
        return true;
    }

    function mint(address _to, uint256 _value) onlyOwner
    {
        if(_value <= 0) throw;
    	balances[_to] += _value;
    	totalSupply += _value;
    }
}

/**
 * ERC 20 token
 *
 * https://github.com/ethereum/EIPs/issues/20
 */
contract Token is Soarcoin {

    /// @return total amount of tokens


    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}


    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}

/**
 * ERC 20 token
 *
 * https://github.com/ethereum/EIPs/issues/20
 */",S
0xcf00354366bca2f2cd49007bfaeac49d97463200,Safe,"contract ConnectSix {

  uint8 constant public board_size = 19;

  Game[] public games;

  struct Game {
      mapping(uint8 => mapping(uint8 => uint8)) board;
      uint8[] move_history;
      address[3] players;
      // 0 means game did not start yet
      uint8 turn;
      // Either 1 or 2. 0 means not finished
      uint8 winner;
      // true if players agreed to a draw
      uint time_per_move;
      // if move is not made by this time, opponent can claim victory
      uint deadline;
      // amount player 1 put in
      uint player_1_stake;
      // amount player 2 must send to join
      uint player_2_stake;
  }

  event LogGameCreated(uint game_num);
  event LogGameStarted(uint game_num);
  event LogVictory(uint game_num, uint8 winner);
  event LogMoveMade(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2);

  function new_game(uint _time_per_move, uint opponent_stake) {
    games.length++;
    Game g = games[games.length - 1];
    g.players[1] = msg.sender;
    g.time_per_move = _time_per_move;
    g.player_1_stake = msg.value;
    g.player_2_stake = opponent_stake;
    // make the first move in the center of the board
    g.board[board_size / 2][board_size / 2] = 1;
    LogGameCreated(games.length - 1);
  }

  function join_game(uint game_num) {
    Game g = games[game_num];
    if (g.turn != 0 || g.player_2_stake != msg.value) {
      throw;
    }
    g.players[2] = msg.sender;
    // It's the second player's turn because the first player automatically makes a single move in the center
    g.turn = 2;
    g.deadline = now + g.time_per_move;
    LogGameStarted(game_num);
  }

  function player_1(uint game_num) constant returns (address) {
    return games[game_num].players[1];
  }

  function player_2(uint game_num) constant returns (address) {
    return games[game_num].players[2];
  }

  function board(uint game_num, uint8 x, uint8 y) constant returns (uint8) {
    return games[game_num].board[x][y];
  }

  function move_history(uint game_num) constant returns (uint8[]) {
      return games[game_num].move_history;
  }

  function single_move(uint game_num, uint8 x, uint8 y) internal {
    if (x > board_size || y > board_size) {
      throw;
    }
    Game g = games[game_num];
    if (g.board[x][y] != 0) {
      throw;
    }
    g.board[x][y] = g.turn;
  }

  function make_move(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2) {
    Game g = games[game_num];
    if (g.winner != 0 || msg.sender != g.players[g.turn]) {
      throw;
    }
    single_move(game_num, x1, y1);
    single_move(game_num, x2, y2);
    g.turn = 3 - g.turn;
    g.deadline = now + g.time_per_move;
    g.move_history.length++;
    g.move_history[g.move_history.length - 1] = x1;
    g.move_history.length++;
    g.move_history[g.move_history.length - 1] = y1;
    g.move_history.length++;
    g.move_history[g.move_history.length - 1] = x2;
    g.move_history.length++;
    g.move_history[g.move_history.length - 1] = y2;
    LogMoveMade(game_num, x1, y1, x2, y2);
  }

  function make_move_and_claim_victory(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 wx, uint8 wy, uint8 dir) {
    make_move(game_num, x1, y1, x2, y2);
    claim_victory(game_num, wx, wy, dir);
  }

  function pay_winner(uint game_num) internal {
    Game g = games[game_num];
    uint amount = g.player_1_stake + g.player_2_stake;
    if (amount > 0 && !g.players[g.winner].send(amount)) {
      throw;
    }
  }

  function claim_time_victory(uint game_num) {
    Game g = games[game_num];
    if (g.winner != 0 || g.deadline == 0 || now <= g.deadline) {
      throw;
    }
    g.winner = 3 - g.turn;
    pay_winner(game_num);
    LogVictory(game_num, g.winner);
  }

  function claim_victory(uint game_num, uint8 x, uint8 y, uint8 dir) {
    Game g = games[game_num];
    if (x > board_size
        || y > board_size
        || g.winner != 0
        || g.board[x][y] == 0
        || dir > 3) {
      throw;
    }
    // We don't have to worry about overflow and underflows here because all the values outside the
    // 19 x 19 board are 0
    if (dir == 3) {
      // this is going diagonal (10:30pm)
      for (uint8 j = 1; j < 6; j++) {
        if (g.board[x - j*dx][y + j*dy] != g.board[x][y]) {
          throw;
        }
      }
    } else {
      uint8 dx = 0;
      uint8 dy = 0;
      if (dir == 2) {
        // diagonal - 1:30pm
        dx = 1;
        dy = 1;
      } else if (dir == 1) {
        // 12:00pm
        dy = 1;
      } else {
        // 3 pm
        dx = 1;
      }
      for (uint8 i = 1; i < 6; i++) {
        if (g.board[x + i*dx][y + i*dy] != g.board[x][y]) {
          throw;
        }
      }
    }
    g.winner = g.board[x][y];
    pay_winner(game_num);
    LogVictory(game_num, g.winner);
  }
}",S
0xb4e7fc7f59c2ec07aee08c46241d7b47de4cec06,Safe,"/**
 * The Edgeless token contract complies with the ERC20 standard.
 * Additionally tokens can be locked for a defined time interval by token holders.
 * */

pragma solidity ^0.4.6;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract EdgelessToken {
    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Edgeless';
    string public symbol = 'EDG';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    uint256 public currentInterval = 1;
    uint256 public intervalLength = 30 days;
    uint256 public startTime = 1490112000;//from this time on tokens may be transfered (after ICO)
    address public owner;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* Defines how many tokens of which addresses are locked in which interval*/
    mapping(address => mapping(uint256=>uint256)) public locked;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Lock(address indexed owner, uint256 interval, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function EdgelessToken() {
        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;
        balanceOf[owner] = 500000000;              // Give the owner all initial tokens
        totalSupply = 500000000;                        // Update total supply
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) returns (bool success){
        if (now < startTime) throw; //check if the crowdsale is already over
        if (balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        return true;
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over
        if (balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* Lock a number of tokens */
    function lock(address holder, uint256 _value) returns (bool success) {
        if(holder==msg.sender||holder==tx.origin){
            locked[holder][getInterval()]+=_value;
            Lock(holder, currentInterval, _value);
            return true;
        }
    }

    /* Increase the interval, if sufficient time has passed */
    function getInterval() returns (uint256 interval){
        if (now > currentInterval * intervalLength + startTime) {
            currentInterval = (now - startTime) / intervalLength + 1;
        }
        return currentInterval;
    }

}",91: time manipulation;
0x28dcd428e8125990f9e5fe1b82db0e3ed240711c,Safe,"pragma solidity ^0.4.2;

contract EC {

    uint256 constant gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;
    uint256 constant gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;
    uint256 constant n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;
    uint256 constant a = 0;
    uint256 constant b = 7;

    function EC()
    {
    }

    function _jAdd( uint256 x1,uint256 z1,
                    uint256 x2,uint256 z2) constant
        returns(uint256 x3,uint256 z3)
    {
        (x3, z3) = (  addmod( mulmod(z2, x1 , n) ,
                              mulmod(x2, z1 , n),
                              n),
                      mulmod(z1, z2 , n)
                    );
    }

    function _jSub( uint256 x1,uint256 z1,
                    uint256 x2,uint256 z2) constant
        returns(uint256 x3,uint256 z3)
    {
        (x3, z3) = (  addmod( mulmod(z2, x1, n),
                              mulmod(n - x2, z1, n),
                              n),
                      mulmod(z1, z2 , n)
                    );
    }

    function _jMul( uint256 x1,uint256 z1,
                    uint256 x2,uint256 z2) constant
        returns(uint256 x3,uint256 z3)
    {
        (x3, z3) = (  mulmod(x1, x2 , n), mulmod(z1, z2 , n));
    }

    function _jDiv( uint256 x1,uint256 z1,
                    uint256 x2,uint256 z2) constant
        returns(uint256 x3,uint256 z3)
    {
        (x3, z3) = (  mulmod(x1, z2 , n), mulmod(z1 , x2 , n));
    }

    function _inverse( uint256 a) constant
        returns(uint256 invA)
    {
        uint256 t=0;
        uint256 newT=1;
        uint256 r=n;
        uint256 newR=a;
        uint256 q;
        while (newR != 0) {
            q = r / newR;

            (t, newT) = (newT, addmod(t , (n - mulmod(q, newT,n)) , n));
            (r, newR) = (newR, r - q * newR );
        }

        return t;
    }


    function _ecAdd( uint256 x1,uint256 y1,uint256 z1,
                    uint256 x2,uint256 y2,uint256 z2) constant
        returns(uint256 x3,uint256 y3,uint256 z3)
    {
        uint256 l;
        uint256 lz;
        uint256 da;
        uint256 db;

        if ((x1==0)&&(y1==0)) {
            return (x2,y2,z2);
        }

        if ((x2==0)&&(y2==0)) {
            return (x1,y1,z1);
        }

        if ((x1==x2)&&(y1==y2)) {
            (l,lz) = _jMul(x1, z1, x1, z1);
            (l,lz) = _jMul(l, lz, 3, 1);
            (l,lz) = _jAdd(l, lz, a, 1);

            (da,db) = _jMul(y1, z1, 2, 1);
        } else {
            (l,lz) = _jSub(y2, z2, y1, z1);
            (da,db)  = _jSub(x2, z2, x1, z1);
        }

        (l, lz) = _jDiv(l, lz, da, db);


        (x3, da) = _jMul(l, lz, l, lz);
        (x3, da) = _jSub(x3, da, x1, z1);
        (x3, da) = _jSub(x3, da, x2, z2);

        (y3, db) = _jSub(x1, z1, x3, da);
        (y3, db) = _jMul(y3, db, l, lz );
        (y3, db) = _jSub(y3, db, y1, z1 );


        if (da != db) {
            x3 = mulmod(x3, db, n);
            y3 = mulmod(y3, da, n);
            z3 = mulmod(da, db, n);
        } else {
            z3 = da;
        }

    }

    function _ecDouble(uint256 x1,uint256 y1,uint256 z1) constant
        returns(uint256 x3,uint256 y3,uint256 z3)
    {
        (x3,y3,z3) = _ecAdd(x1,y1,z1,x1,y1,z1);
    }



    function _ecMul(uint256 d, uint256 x1,uint256 y1,uint256 z1) constant
        returns(uint256 x3,uint256 y3,uint256 z3)
    {
        uint256 remaining = d;
        uint256 px = x1;
        uint256 py = y1;
        uint256 pz = z1;
        uint256 acx = 0;
        uint256 acy = 0;
        uint256 acz = 1;

        if (d==0) {
            return (0,0,1);
        }

        while (remaining != 0) {
            if ((remaining & 1) != 0) {
                (acx,acy,acz) = _ecAdd(acx,acy,acz, px,py,pz);
            }
            remaining = remaining / 2;
            (px,py,pz) = _ecDouble(px,py,pz);
        }

        (x3,y3,z3) = (acx,acy,acz);
    }

    function publicKey(uint256 privKey) constant
        returns(uint256 qx, uint256 qy)
    {
        uint256 x;
        uint256 y;
        uint256 z;
        (x,y,z) = _ecMul(privKey, gx, gy, 1);
        z = _inverse(z);
        qx = mulmod(x , z ,n);
        qy = mulmod(y , z ,n);
    }

    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) constant
        returns(uint256 qx, uint256 qy)
    {
        uint256 x;
        uint256 y;
        uint256 z;
        (x,y,z) = _ecMul(privKey, pubX, pubY, 1);
        z = _inverse(z);
        qx = mulmod(x , z ,n);
        qy = mulmod(y , z ,n);
    }

}",S
0x4ed985e2da341e276bbf7782f2e1e30689d33c89,Safe,"pragma solidity ^0.4.2;

contract SpiceMembers {
    enum MemberLevel { None, Member, Manager, Director }
    struct Member {
        uint id;
        MemberLevel level;
        bytes32 info;
    }

    mapping (address => Member) member;

    address public owner;
    mapping (uint => address) public memberAddress;
    uint public memberCount;

    event TransferOwnership(address indexed sender, address indexed owner);
    event AddMember(address indexed sender, address indexed member);
    event RemoveMember(address indexed sender, address indexed member);
    event SetMemberLevel(address indexed sender, address indexed member, MemberLevel level);
    event SetMemberInfo(address indexed sender, address indexed member, bytes32 info);

    function SpiceMembers() {
        owner = msg.sender;

        memberCount = 1;
        memberAddress[memberCount] = owner;
        member[owner] = Member(memberCount, MemberLevel.None, 0);
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    modifier onlyManager {
        if (msg.sender != owner && memberLevel(msg.sender) < MemberLevel.Manager) throw;
        _;
    }

    function transferOwnership(address _target) onlyOwner {
        // If new owner has no memberId, create one
        if (member[_target].id == 0) {
            memberCount++;
            memberAddress[memberCount] = _target;
            member[_target] = Member(memberCount, MemberLevel.None, 0);
        }
        owner = _target;
        TransferOwnership(msg.sender, owner);
    }

    function addMember(address _target) onlyManager {
        // Make sure trying to add an existing member throws an error
        if (memberLevel(_target) != MemberLevel.None) throw;

        // If added member has no memberId, create one
        if (member[_target].id == 0) {
            memberCount++;
            memberAddress[memberCount] = _target;
            member[_target] = Member(memberCount, MemberLevel.None, 0);
        }

        // Set memberLevel to initial value with basic access
        member[_target].level = MemberLevel.Member;
        AddMember(msg.sender, _target);
    }

    function removeMember(address _target) {
        // Make sure trying to remove a non-existing member throws an error
        if (memberLevel(_target) == MemberLevel.None) throw;
        // Make sure members are only allowed to delete members lower than their level
        if (msg.sender != owner && memberLevel(msg.sender) <= memberLevel(_target)) throw;

        member[_target].level = MemberLevel.None;
        RemoveMember(msg.sender, _target);
    }

    function setMemberLevel(address _target, MemberLevel level) {
        // Make sure all levels are larger than None but not higher than Director
        if (level == MemberLevel.None || level > MemberLevel.Director) throw;
        // Make sure the _target is currently already a member
        if (memberLevel(_target) == MemberLevel.None) throw;
        // Make sure the new level is lower level than we are (we cannot overpromote)
        if (msg.sender != owner && memberLevel(msg.sender) <= level) throw;
        // Make sure the member is currently on lower level than we are
        if (msg.sender != owner && memberLevel(msg.sender) <= memberLevel(_target)) throw;

        member[_target].level = level;
        SetMemberLevel(msg.sender, _target, level);
    }

    function setMemberInfo(address _target, bytes32 info) {
        // Make sure the target is currently already a member
        if (memberLevel(_target) == MemberLevel.None) throw;
        // Make sure the member is currently on lower level than we are
        if (msg.sender != owner && msg.sender != _target && memberLevel(msg.sender) <= memberLevel(_target)) throw;

        member[_target].info = info;
        SetMemberInfo(msg.sender, _target, info);
    }

    function memberId(address _target) constant returns (uint) {
        return member[_target].id;
    }

    function memberLevel(address _target) constant returns (MemberLevel) {
        return member[_target].level;
    }

    function memberInfo(address _target) constant returns (bytes32) {
        return member[_target].info;
    }
}",S
0x87E093F4A39BC0F486f59e45Af64D2D669D61b5B,Safe,"contract TokenReg {
    modifier only_owner { if (msg.sender != owner) return; _ }
    event NewOwner(address indexed old, address indexed current);
    function setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }
    address public owner = msg.sender;
    struct Token {
        address addr;
        string tla;
        uint base;
        string name;
        address owner;
        mapping (bytes32 => bytes32) meta;
    }

    modifier when_fee_paid { if (msg.value < fee) return; _ }
    modifier when_address_free(address _addr) { if (mapFromAddress[_addr] != 0) return; _ }
    modifier when_tla_free(string _tla) { if (mapFromTLA[_tla] != 0) return; _ }
    modifier when_is_tla(string _tla) { if (bytes(_tla).length != 3) return; _ }
    modifier when_has_tla(string _tla) { if (mapFromTLA[_tla] == 0) return; _ }
    modifier only_token_owner(uint _id) { if (tokens[_id].owner != msg.sender) return; _ }

    event Registered(string indexed tla, uint indexed id, address addr, string name);
    event Unregistered(string indexed tla, uint indexed id);
    event MetaChanged(uint indexed id, bytes32 indexed key, bytes32 value);

    function register(address _addr, string _tla, uint _base, string _name) returns (bool) {
        return registerAs(_addr, _tla, _base, _name, msg.sender);
    }

    function registerAs(address _addr, string _tla, uint _base, string _name, address _owner) when_fee_paid when_address_free(_addr) when_is_tla(_tla) when_tla_free(_tla) returns (bool) {
        tokens.push(Token(_addr, _tla, _base, _name, _owner));
        mapFromAddress[_addr] = tokens.length;
        mapFromTLA[_tla] = tokens.length;
        Registered(_tla, tokens.length - 1, _addr, _name);
        return true;
    }

    function unregister(uint _id) only_owner {
        Unregistered(tokens[_id].tla, _id);
        delete mapFromAddress[tokens[_id].addr];
        delete mapFromTLA[tokens[_id].tla];
        delete tokens[_id];
    }

    function setFee(uint _fee) only_owner {
        fee = _fee;
    }

    function tokenCount() constant returns (uint) { return tokens.length; }
    function token(uint _id) constant returns (address addr, string tla, uint base, string name, address owner) {
        var t = tokens[_id];
        addr = t.addr;
        tla = t.tla;
        base = t.base;
        name = t.name;
        owner = t.owner;
    }

    function fromAddress(address _addr) constant returns (uint id, string tla, uint base, string name, address owner) {
        id = mapFromAddress[_addr] - 1;
        var t = tokens[id];
        tla = t.tla;
        base = t.base;
        name = t.name;
        owner = t.owner;
    }

    function fromTLA(string _tla) constant returns (uint id, address addr, uint base, string name, address owner) {
        id = mapFromTLA[_tla] - 1;
        var t = tokens[id];
        addr = t.addr;
        base = t.base;
        name = t.name;
        owner = t.owner;
    }

    function meta(uint _id, bytes32 _key) constant returns (bytes32) {
        return tokens[_id].meta[_key];
    }

    function setMeta(uint _id, bytes32 _key, bytes32 _value) only_token_owner(_id) {
        tokens[_id].meta[_key] = _value;
        MetaChanged(_id, _key, _value);
    }

    function drain() only_owner {
        if (!msg.sender.send(this.balance))
            throw;
    }

    mapping (address => uint) mapFromAddress;
    mapping (string => uint) mapFromTLA;
    Token[] tokens;
    uint public fee = 1 ether;
}",S
0x8c0a599d3ff4d3344cb93ae49247c11b645c5e44,Safe,"pragma solidity ^0.4.1;

contract FipsNotary {

    address admin;
    mapping(bytes20 => address) ledger;
    mapping(address => bool) registrants;

    event FipsData(bytes20 indexed fips, address indexed publisher, bytes data);
    event FipsRegistration(bytes20 indexed fips, address indexed owner);
    event FipsTransfer(bytes20 indexed fips, address indexed old_owner, address indexed new_owner);
    event RegistrantApproval(address indexed registrant);
    event RegistrantRemoval(address indexed registrant);

    modifier onlyAdmin() {
        if (msg.sender != admin) throw;
        _
        ;
    }

    function() {
        throw;
    }

    function FipsNotary() {
        admin = msg.sender;
        registrantApprove(admin);
    }

    function fipsIsRegistered(bytes20 fips) constant returns (bool exists) {
        return (ledger[fips] != 0x0) ? true : false;
    }

    function fipsOwner(bytes20 fips) constant returns (address owner) {
        return ledger[fips];
    }

    function fipsPublishData(bytes20 fips, bytes data) {
        if ((msg.sender == admin) || (msg.sender == ledger[fips])) {
            FipsData(fips, msg.sender, data);
        }
    }

    function fipsPublishDataMulti(bytes20[] fips, bytes data) {
        for (uint i = 0; i < fips.length; i++) {
            fipsPublishData(fips[i], data);
        }
    }

    function fipsAddToLedger(bytes20 fips, address owner, bytes data) internal {
        if (!fipsIsRegistered(fips)) {
            ledger[fips] = owner;
            FipsRegistration(fips, owner);
            if (data.length > 0) {
                FipsData(fips, owner, data);
            }
        }
    }

    function fipsGenerate() internal returns (bytes20 fips) {
        fips = ripemd160(block.blockhash(block.number), sha256(msg.sender, block.number, block.timestamp, msg.gas));
        if (fipsIsRegistered(fips)) {
            return fipsGenerate();
        }
        return fips;
    }

    function fipsLegacyRegister(bytes20 fips, address owner, bytes data) {
        if (registrants[msg.sender] == true) {
            fipsAddToLedger(fips, owner, data);
        }
    }

    function fipsLegacyRegisterMulti(bytes20[] fips, address owner, bytes data) {
        if (registrants[msg.sender] == true) {
            for (uint i = 0; i < fips.length; i++) {
                fipsAddToLedger(fips[i], owner, data);
            }
        }
    }

    function fipsRegister(address owner, bytes data) {
        if (registrants[msg.sender] == true) {
            fipsAddToLedger(fipsGenerate(), owner, data);
        }
    }

    function fipsRegisterMulti(uint count, address owner, bytes data) {
        if (registrants[msg.sender] == true) {
            if ((count > 0) && (count <= 100)) {
                for (uint i = 0; i < count; i++) {
                    fipsAddToLedger(fipsGenerate(), owner, data);
                }
            }
        }
    }

    function fipsTransfer(bytes20 fips, address new_owner) {
        if (fipsOwner(fips) == msg.sender) {
            ledger[fips] = new_owner;
            FipsTransfer(fips, msg.sender, new_owner);
        }
    }

    function fipsTransferMulti(bytes20[] fips, address new_owner) {
        for (uint i = 0; i < fips.length; i++) {
            fipsTransfer(fips[i], new_owner);
        }
    }

    function registrantApprove(address registrant) onlyAdmin {
        if (registrants[registrant] != true) {
            registrants[registrant] = true;
            RegistrantApproval(registrant);
        }
    }

    function registrantRemove(address registrant) onlyAdmin {
        if (registrants[registrant] == true) {
            delete(registrants[registrant]);
            RegistrantRemoval(registrant);
        }
    }

    function withdrawFunds() onlyAdmin {
        if (!admin.send(this.balance)) {
            throw;
        }
    }

}",S
0xbf7316fab5c8cfbda5e763a5a1f94c4e0ce7ec37,Safe,"// A name registry in Ethereum

// ""Real"" attempts to a name registry with Ethereum:
// <http://etherid.org/> <https://github.com/sinking-point/dns2/>

// TODO: use the registry interface described in
// <https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs>?

// Standard strings are poor, we need an extension library,
// github.com/Arachnid/solidity-stringutils/strings.sol TODO: use it as soon as https://github.com/Arachnid/solidity-stringutils/issues/1 is solved.
// import ""strings.sol"";

contract Registry {

  // using strings for *; // TODO see above

  address public nic; // The Network Information Center

  struct Record {
    string value; // IP addresses, emails, etc TODO accept an array
		     // as soon as we have a strings library to
		     // serialize/deserialize. TODO type the values with an Enum
    address holder;
    bool exists; // Or a more detailed state, with an enum?
    uint idx;
  }
  mapping (string => Record) records;
  mapping (uint => string) index;

  // TODO define accessors instead
  uint public maxRecords;
  uint public currentRecords;

  event debug(string indexed label, string msg);
  event created(string indexed label, string indexed name, address holder, uint block);
  event deleted(string indexed label, string indexed name, address holder, uint block);

  // ""value"" should be a comma-separated list of values. Solidity
  // public functions cannot use arrays of strings :-( TODO: solve it
  // when we'll have strings.
  function register(string name, string value) {
    /* TODO: pay the price */
    uint i;
    if (records[name].exists) {
      if (msg.sender != records[name].holder) { // TODO: use modifiers instead
	throw;
      }
      else {
	i = records[name].idx;
      }
    }
    else {
      records[name].idx = maxRecords;
      i = maxRecords;
      maxRecords++;
    }
    records[name].value = value;
    records[name].holder = msg.sender;
    records[name].exists = true;
    currentRecords++;
    index[i] = name;
    created(""CREATION"", name, msg.sender, block.number);
  }

  function transfer(string name, address to) {
    if (records[name].exists) {
      if (msg.sender != records[name].holder) {
	throw;
      }
      records[name].holder = to;
    }
    else {
      throw;
    }
  }

  function get(string name) constant returns(bool exists, string value) {
    if (records[name].exists) {
      exists = true;
      value = records[name].value;
    } else {
      exists = false;
    }
  }

  // Constructor
  function Registry() {
    nic = msg.sender;
    currentRecords = 0;
    maxRecords = 0;
    register(""NIC"", ""Automatically created by for the registry""); // TODO may fail if not
    // enough gas in the creating transaction?
  }


  function whois(string name) constant returns(bool exists, string value, address holder) {
    if (records[name].exists) {
      exists = true;
      value = records[name].value;
      holder = records[name].holder;
    } else {
      exists = false;
    }
  }

  function remove(string name) {
    uint i;
    if (records[name].exists) {
      if (msg.sender != records[name].holder) {
	throw;
      }
      else {
	i = records[name].idx;
      }
    }
    else {
      throw; // 404. Too bad we cannot add content to throw.
    }
    records[name].exists = false;
    currentRecords--;
    deleted(""DELETION"", name, msg.sender, block.number);
  }

  function download() returns(string all) {
    if (msg.sender != nic) {
	throw;
      }
    all = ""NOT YET IMPLEMENTED"";
    // Looping over all the records is easy:
    //for uint (i = 0; i < maxRecords; i++) {
    //	if (records[index[i]].exists) {

    // Or we could use an iterable mapping may
    // be this library
    // <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>

    // The difficult part is to construct an answer, since Solidity
    // does not provide string concatenation, or the ability to return
    // arrays.

	// TODO: provide a function to access one item, using its index,
	// and to let the caller loops from 0 to maxRecords
	// http://stackoverflow.com/questions/37606839/how-to-return-mapping-list-in-solidity-ethereum-contract/37643972#37643972
  }

}",S
0x04daec4e1fc6a4b4555b509b7c5c673ebad29f1f,Safe,"pragma solidity ^0.4.0;

contract ArithLib {

    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;
    uint constant internal N = 115792089237316195423570985008687907852837564279074904382605163141518161494337;
    uint constant internal M = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;
    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;

    function ArithLib() { }

    function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);

        uint ysq = _ay * _ay;
        uint s = 4 * _ax * ysq;
        uint m = 3 * _ax * _ax;
        uint nx = m * m - 2 * s;
        uint ny = m * (s - nx) - 8 * ysq * ysq;
        uint nz = 2 * _ay * _az;
        return (nx, ny, nz);
    }

    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint) {

        if(_ay == 0) return (0, 0, 0);
        if(_ay == 0) return(_bx, _by, _bz);
        if(_by == 0) return(_ax, _ay, _az);

        uint u1 = _ax * _bz * _bz;
        uint u2 = _bx * _az * _az;
        uint s1 = _ay * _bz * _bz * _bz;
        uint s2 = _by * _az * _az * _az;

        if(u1 == u2) {
           if(s1 != s2) return(0, 0, 1);
           return jdouble(_ax, _ay, _az);
        }

        uint nx = (s2 - s1) * (s2 - s1) - (u2 - u1) * (u2 - u1) * (u2 - u1) - 2 * u1 * (u2 - u1) * (u2 - u1);

        return
            (nx,
             (s2 - s1) * (u1 * (u2 - u1) * (u2 - u1) - nx) - s1 * (u2 - u1) * (u2 - u1) * (u2 - u1),
             (u2 - u1) * _az * _bz);
    }

    function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint) {

        _n = _n % N;
        if(((_bx == 0) && (_by == 0)) || (_n == 0)) return(0, 0, 1);

        uint ax;
        uint ay;
        uint az;
        (ax, ay, az) = (0, 0, 1);
        uint b = M;

        while(b > 0) {

           (ax, ay, az) = jdouble(ax, ay, az);
           if((_n & b) != 0) {

              if(ay == 0) {
                 (ax, ay, az) = (_bx, _by, _bz);
              } else {
                 (ax, ay, az) = jadd(ax, ay, az, _bx, _by, _bz);
              }
           }

           b = b / 2;
        }

        return (ax, ay, az);
    }

    function jexp(uint _b, uint _e, uint _m) constant returns (uint) {
        uint o = 1;
        uint bit = M;

        while (bit > 0) {
            uint bitval = 0;
            if(_e & bit > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 2) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 4) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bitval = 0;
            if(_e & (bit / 8) > 0) bitval = 1;
            o = mulmod(mulmod(o, o, _m), _b ** bitval, _m);
            bit = (bit / 16);
        }
        return o;
    }

    function jrecover_y(uint _x, uint _y_bit) constant returns (uint) {

        uint xcubed = mulmod(mulmod(_x, _x, P), _x, P);
        uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
        uint y_is_positive = _y_bit ^ (beta % 2) ^ 1;
        return(beta * y_is_positive + (P - beta) * (1 - y_is_positive));
    }

    function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint) {
        uint ox = mulmod(_q0, jexp(_q2, P - 3, P), P);
        uint oy = mulmod(_q1, jexp(_q2, P - 4, P), P);
        return(ox, oy);
    }

    function isbit(uint _data, uint _bit) constant returns (uint) {
        return (_data / 2**(_bit % 8)) % 2;
    }

    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint) {
        uint x = uint(sha3(_pub1, _pub2));
        while(true) {
            uint xcubed = mulmod(mulmod(x, x, P), x, P);
            uint beta = jexp(addmod(xcubed, 7, P), ((P + 1) / 4), P);
            uint y = beta * (beta % 2) + (P - beta) * (1 - (beta % 2));
            if(addmod(xcubed, 7, P) == mulmod(y, y, P)) return(x, y);
            x = ((x + 1) % P);
        }
    }

    function () {
        throw;
    }
}",S
0x9047ef7c3d52956dd0909c1c1e011e986ce60691,Safe,"/**
 * The Edgeless token contract complies with the ERC20 standard.
 * Additionally tokens can be locked for a defined time interval by token holders.
 * author: Julia Altenried
 * */

pragma solidity ^0.4.6;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract EdgelessToken {
    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Edgeless';
    string public symbol = 'EDG';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    uint256 public currentInterval = 1;
    uint256 public intervalLength = 30 days;
    uint256 public startTime = 1485878400;//from this time on tokens may be transfered (after ICO)
    address public owner;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* Defines how many tokens of which addresses are locked in which interval*/
    mapping(address => mapping(uint256=>uint256)) public locked;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Lock(address indexed owner, uint256 interval, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function EdgelessToken() {
        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;
        balanceOf[owner] = 500000000;              // Give the owner all initial tokens
        totalSupply = 500000000;                        // Update total supply
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) returns (bool success){
        if (now < startTime) throw; //check if the crowdsale is already over
        if (balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        return true;
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (now < startTime) throw; //check if the crowdsale is already over
        if (balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* Lock a number of tokens */
    function lock(address holder, uint256 _value) returns (bool success) {
        if(holder==msg.sender||holder==tx.origin){
            locked[holder][getInterval()]+=_value;
            Lock(holder, currentInterval, _value);
            return true;
        }
    }

    /* Increase the interval, if sufficient time has passed */
    function getInterval() returns (uint256 interval){
        if (now > currentInterval * intervalLength + startTime) {
            currentInterval = (now - startTime) / intervalLength + 1;
        }
        return currentInterval;
    }

}",92: time manipulation;
0xb12C7DF9F092814e7863b65035Eb14D19FA61faF,Safe,"pragma solidity 0.4.8;
contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract Megaloh {


	/* Public variables of the token */
	string public name;
	string public symbol;
	uint8 public decimals;
	uint256 public initialSupply;
	address public burnAddress;

	/* This creates an array with all balances */
	mapping (address => uint) public balanceOf;
	mapping (address => mapping (address => uint)) public allowance;

	/* This generates a public event on the blockchain that will notify clients */
	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed from, address indexed spender, uint value);



	/* Initializes contract with initial supply tokens to the creator of the contract */
	function Megaloh() {
		initialSupply = 8000000000;
		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens
		name = 'Megaloh';                                 // Set the name for display purposes
		symbol = 'MGH';                               	 // Set the symbol for display purposes
		decimals = 3;                           		 // Amount of decimals for display purposes
		burnAddress = 0x1b32000000000000000000000000000000000000;
	}

	function totalSupply() returns(uint){
		return initialSupply - balanceOf[burnAddress];
	}

	/* Send coins */
	function transfer(address _to, uint256 _value)
	returns (bool success) {
		if (balanceOf[msg.sender] >= _value && _value > 0) {
			balanceOf[msg.sender] -= _value;
			balanceOf[_to] += _value;
			Transfer(msg.sender, _to, _value);
			return true;
		} else return false;
	}

	/* Allow another contract to spend some tokens in your behalf */



	function approveAndCall(address _spender,
							uint256 _value,
							bytes _extraData)
	returns (bool success) {
		allowance[msg.sender][_spender] = _value;
		tokenSpender spender = tokenSpender(_spender);
		spender.receiveApproval(msg.sender, _value, this, _extraData);
		Approval(msg.sender, _spender, _value);
		return true;
	}



	/*Allow another adress to use your money but doesn't notify it*/
	function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }



	/* A contract attempts to get the coins */
	function transferFrom(address _from,
						  address _to,
						  uint256 _value)
	returns (bool success) {
		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {
			balanceOf[_to] += _value;
			Transfer(_from, _to, _value);
			balanceOf[_from] -= _value;
			allowance[_from][msg.sender] -= _value;
			return true;
		} else return false;
	}



	/* This unnamed function is called whenever someone tries to send ether to it */
	function () {
		throw;     // Prevents accidental sending of ether
	}
}",S
0x44FB2663d37e36e4a2B4b865D9ec832e5Da6A016,Safe,"pragma solidity 0.4.8;

contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract XDRAC {


	/* Public variables of the token */
	string public name;
	string public symbol;
	uint8 public decimals;
	uint256 public initialSupply;


	/* This creates an array with all balances */
	mapping (address => uint) public balanceOf;
	mapping (address => mapping (address => uint)) public allowance;

	/* This generates a public event on the blockchain that will notify clients */
	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed from, address indexed spender, uint value);



	/* Initializes contract with initial supply tokens to the creator of the contract */
	function XDRAC() {
		initialSupply = 10000000000000;
		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens
		name = 'DracShares';                                 // Set the name for display purposes
		symbol = 'XDRAC';                               	 // Set the symbol for display purposes
		decimals = 6;                           		 // Amount of decimals for display purposes

	}

	function totalSupply() returns(uint){
		return initialSupply ;
	}

	/* Send coins */
	function transfer(address _to, uint256 _value)
	returns (bool success) {
		if (balanceOf[msg.sender] >= _value && _value > 0) {
			balanceOf[msg.sender] -= _value;
			balanceOf[_to] += _value;
			Transfer(msg.sender, _to, _value);
			return true;
		} else return false;
	}

	/* Allow another contract to spend some tokens in your behalf */



	function approveAndCall(address _spender,
							uint256 _value,
							bytes _extraData)
	returns (bool success) {
		allowance[msg.sender][_spender] = _value;
		tokenSpender spender = tokenSpender(_spender);
		spender.receiveApproval(msg.sender, _value, this, _extraData);
		Approval(msg.sender, _spender, _value);
		return true;
	}


	/*Allow another adress to use your money but doesn't notify it*/
	function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
}



	/* A contract attempts to get the coins */
	function transferFrom(address _from,
						  address _to,
						  uint256 _value)
	returns (bool success) {
		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {
			balanceOf[_to] += _value;
			Transfer(_from, _to, _value);
			balanceOf[_from] -= _value;
			allowance[_from][msg.sender] -= _value;
			return true;
		} else return false;
	}



	/* This unnamed function is called whenever someone tries to send ether to it */
	function () {
		throw;     // Prevents accidental sending of ether
	}
}",S
0xe8200511F3C276fA7300719f9B45301Bc471f4fB,Safe,"pragma solidity ^0.4.2;

contract Token {
	function balanceOf(address user) constant returns (uint256 balance);
	function transfer(address receiver, uint amount) returns(bool);
}

contract BonusDealer {
    address public owner;
    Token public nexium;
    uint public totalDistributed;
    address[] public paidAddress;
    mapping(address => uint) public paid;

    struct Bonus {
        uint bonusInNxc;
        uint step;
    }

    Bonus[] bonuses;

    event Paid(address);

    uint nxcBought;

    function BonusDealer(){
        nexium = Token(0x45e42D659D9f9466cD5DF622506033145a9b89Bc);
        owner = msg.sender;
        totalDistributed = 0;
        bonuses.length++;
        bonuses[0] = Bonus(0, 0);
        bonuses.length++;
        bonuses[1] = Bonus(80*1000, 4000*1000);
        bonuses.length++;
        bonuses[2] = Bonus(640*1000, 16000*1000);
        bonuses.length++;
        bonuses[3] = Bonus(3000*1000, 50000*1000);
        bonuses.length++;
        bonuses[4] = Bonus(8000*1000, 100000*1000);
        bonuses.length++;
        bonuses[5] = Bonus(40000*1000, 400000*1000);
        bonuses.length++;
        bonuses[6] = Bonus(78000*1000, 650000*1000);
        bonuses.length++;
        bonuses[7] = Bonus(140000*1000, 1000000*1000);
        bonuses.length++;
        bonuses[8] = Bonus(272000*1000, 1700000*1000);
    }

    function bonusCalculation(uint _nxcBought) returns(uint){
        nxcBought = _nxcBought;
        uint totalToPay = 0;
        uint toAdd = 1;
        while (toAdd != 0){
            toAdd = recursiveCalculation();
            totalToPay += toAdd;
        }

        return totalToPay;
    }

    function recursiveCalculation() internal returns(uint){
        var i = 8;
        while (i != 0 && bonuses[i].step > nxcBought) i--;
        nxcBought -= bonuses[i].step;
        return bonuses[i].bonusInNxc;
    }

    function payDiff(address backer, uint totalNxcBought){
        if (msg.sender != owner) throw;
        if (paid[backer] == 0) paidAddress[paidAddress.length++] = msg.sender;
        uint totalToPay = bonusCalculation(totalNxcBought);
        if(totalToPay <= paid[backer]) throw;
        totalToPay -= paid[backer];
        if (!nexium.transfer(backer, totalToPay)) throw;
        paid[backer] += totalToPay;
        totalDistributed += totalToPay;
        Paid(backer);
    }

    function withdrawNexiums(address a){
        if (msg.sender != owner) throw;
        nexium.transfer(a, nexium.balanceOf(this));
    }

    function(){
        throw;
    }
}",56: arithmetic;
0x45e42d659d9f9466cd5df622506033145a9b89bc,Safe,"contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract Nexium {


	/* Public variables of the token */
	string public name;
	string public symbol;
	uint8 public decimals;
	uint256 public initialSupply;
	address public burnAddress;

	/* This creates an array with all balances */
	mapping (address => uint) public balanceOf;
	mapping (address => mapping (address => uint)) public allowance;

	/* This generates a public event on the blockchain that will notify clients */
	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed from, address indexed spender, uint value);



	/* Initializes contract with initial supply tokens to the creator of the contract */
	function Nexium() {
		initialSupply = 100000000000;
		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens
		name = 'Nexium';                                 // Set the name for display purposes
		symbol = 'NxC';                               	 // Set the symbol for display purposes
		decimals = 3;                           		 // Amount of decimals for display purposes
		burnAddress = 0x1b32000000000000000000000000000000000000;
	}

	function totalSupply() returns(uint){
		return initialSupply - balanceOf[burnAddress];
	}

	/* Send coins */
	function transfer(address _to, uint256 _value)
	returns (bool success) {
		if (balanceOf[msg.sender] >= _value && _value > 0) {
			balanceOf[msg.sender] -= _value;
			balanceOf[_to] += _value;
			Transfer(msg.sender, _to, _value);
			return true;
		} else return false;
	}

	/* Allow another contract to spend some tokens in your behalf */



	function approveAndCall(address _spender,
							uint256 _value,
							bytes _extraData)
	returns (bool success) {
		allowance[msg.sender][_spender] = _value;
		tokenSpender spender = tokenSpender(_spender);
		spender.receiveApproval(msg.sender, _value, this, _extraData);
		Approval(msg.sender, _spender, _value);
		return true;
	}



	/*Allow another adress to use your money but doesn't notify it*/
	function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }



	/* A contract attempts to get the coins */
	function transferFrom(address _from,
						  address _to,
						  uint256 _value)
	returns (bool success) {
		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {
			balanceOf[_to] += _value;
			Transfer(_from, _to, _value);
			balanceOf[_from] -= _value;
			allowance[_from][msg.sender] -= _value;
			return true;
		} else return false;
	}



	/* This unnamed function is called whenever someone tries to send ether to it */
	function () {
		throw;     // Prevents accidental sending of ether
	}
}",S
0x4993CB95c7443bdC06155c5f5688Be9D8f6999a5,Safe,"pragma solidity ^0.4.0;

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract RoundToken {

  string public constant name = ""ROUND"";
  string public constant symbol = ""ROUND"";
  uint8 public constant decimals = 18;
  string public constant version = '0.1';
  uint256 public constant totalSupply = 1000000000 * 1000000000000000000;

  address public owner;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  event NewOwner(address _newOwner);

  modifier checkIfToContract(address _to) {
    if(_to != address(this))  {
      _;
    }
  }

  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;

  function RoundToken() {
    owner = msg.sender;
    balances[owner] = totalSupply;
  }

  function replaceOwner(address _newOwner) returns (bool success) {
    if (msg.sender != owner) throw;
    owner = _newOwner;
    NewOwner(_newOwner);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function transfer(address _to, uint256 _value) checkIfToContract(_to) returns (bool success) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value) checkIfToContract(_to) returns (bool success) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, this, _extraData);
      return true;
    }
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
}",S
0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3,Safe,"/* A contract to store a state of goods (single item). Buy orders obtainable as events. */

/* Deployment:
*/

contract goods {

    address public owner;
    //status of the goods: Available, Pending, Sold, Canceled
    uint16 public status;
    //how many for sale
    uint16 public count;
    //price per item
    uint public price;

    uint16 public availableCount;
    uint16 public pendingCount;

    event log_event(string message);
    event content(string datainfo, uint indexed version, uint indexed datatype, address indexed sender, uint count, uint payment);
    modifier onlyowner { if (msg.sender == owner) _ }

    function goods(uint16 _count, uint _price) {
        owner = msg.sender;
        //status = Available
        status = 1;
        count = _count;
        price = _price;

        availableCount = count;
        pendingCount = 0;
    }

    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function log(string message) private {
        log_event(message);
    }

    function buy(string datainfo, uint _version, uint16 _count) {
        if(status != 1) { log(""status != 1""); throw; }
        if(msg.value < (price * _count)) { log(""msg.value < (price * _count)""); throw; }
        if(_count > availableCount) { log(""_count > availableCount""); throw; }

        pendingCount += _count;

        //Buy order to event log
        content(datainfo, _version, 1, msg.sender, _count, msg.value);
    }

    function accept(string datainfo, uint _version, uint16 _count) onlyowner {
        if(_count > availableCount) { log(""_count > availableCount""); return; }
        if(_count > pendingCount) { log(""_count > pendingCount""); return; }

        pendingCount -= _count;
        availableCount -= _count;

        //Accept order to event log
        content(datainfo, _version, 2, msg.sender, _count, 0);
    }

    function reject(string datainfo, uint _version, uint16 _count, address recipient, uint amount) onlyowner {
        if(_count > pendingCount) { log(""_count > pendingCount""); return; }

        pendingCount -= _count;
        //send money back
        recipient.send(amount);

        //Reject order to event log
        content(datainfo, _version, 3, msg.sender, _count, amount);
    }

    function cancel(string datainfo, uint _version) onlyowner {
        //Canceled status
        status = 2;

        //Cancel order to event log
        content(datainfo, _version, 4, msg.sender, availableCount, 0);
    }
}",37: unchecked; 71: unchecked;
0x111cc94a5dabdf192c5106fadc844a98b0f56be0,Safe,"contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
    function getNewDAOAddress(uint _proposalID) constant returns(address _newDAO);
    uint public totalSupply;
}

/**
 * @title trustedChildWithdraw
 * @author Paul Szczesny, Alexey Akhunov
 * A simple withdraw contract for trusted childDAOs affected by the hard fork.
 * Based on the official WithdrawDAO contract found here: https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754#code
 */
contract trustedChildWithdraw {

  DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);
  uint[] public trustedProposals = [7, 10, 16, 20, 23, 26, 27, 28, 31, 34, 37, 39, 41, 44, 54, 57, 60, 61, 63, 64, 65, 66];
  mapping (uint => DAO) public whiteList;
  address constant curator = 0xda4a4626d3e16e094de3225a751aab7128e96526;

  /**
  * Populates the whiteList based on the list of trusted proposal Ids.
  */
  function trustedChildWithdraw() {
      for(uint i=0; i<trustedProposals.length; i++) {
          uint proposalId = trustedProposals[i];
          whiteList[proposalId] = DAO(mainDAO.getNewDAOAddress(proposalId));
      }
  }

  /**
  * Convienience function for the Curator to calculate the required amount of Wei
  * that needs to be transferred to this contract.
  */
  function requiredEndowment() constant returns (uint endowment) {
      uint sum = 0;
      for(uint i=0; i<trustedProposals.length; i++) {
          uint proposalId = trustedProposals[i];
          DAO childDAO = whiteList[proposalId];
          sum += childDAO.totalSupply();
      }
      return sum;
  }

  /**
   * Function call to withdraw ETH by burning childDao tokens.
   * @param proposalId The split proposal ID which created the childDao
   * @dev This requires that the token-holder authorizes this contract's address using the approve() function.
   */
  function withdraw(uint proposalId) external {
    //Check the token balance
    uint balance = whiteList[proposalId].balanceOf(msg.sender);

    // Transfer childDao tokens first, then send Ether back in return
    if (!whiteList[proposalId].transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
      throw;
  }

  /**
   * Return funds back to the curator.
   */
  function clawback() external {
    if (msg.sender != curator) throw;
    if (!curator.send(this.balance)) throw;
  }

}",40: arithmetic;
0x76e580f75BF01bfFbF4f44167d5822346de4f176,Safe,"pragma solidity ^0.4.6;

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }


contract WillieWatts {

    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function WillieWatts(
        string tokenName,
        string tokenSymbol
        ) {
        totalSupply = 0;
        name = tokenName;
        symbol = tokenSymbol;
        decimals = 0;
    }


    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
    }


    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function refund(uint256 _value) returns (bool success) {
      uint256 etherValue = (_value * 1 ether) / 1000;

      if(balanceOf[msg.sender] < _value) throw;
      if(!msg.sender.send(etherValue)) throw;

      balanceOf[msg.sender] -= _value;
      totalSupply -= _value;
      Transfer(msg.sender, this, _value);
      return true;
    }

    function() payable {
      uint256 tokenCount = (msg.value * 1000) / 1 ether ;

      balanceOf[msg.sender] += tokenCount;
      totalSupply += tokenCount;
      Transfer(this, msg.sender, tokenCount);
    }
}",S
0x53fDf0c63b87F2Db6e2C58AB05a8a3c39d7d8D49,Safe,"pragma solidity ^0.4.7;
contract DXContracts {

  struct Contract {
    string contractName;
    string contractDescription;
    uint index;
    bytes32 sha256sum;
    address[] signers;
    uint timeStamp;
    mapping (address=>bool) hasSigned;
    mapping (address=>string) signerName;
    bool sealed;
    uint numberAlreadySigned;
  }
  Contract[] public contracts;


  function getContractSigners(bytes32 _shasum) constant returns(address[], string, string, uint)
    {
        return (contracts[contractIndex[_shasum]].signers, contracts[contractIndex[_shasum]].contractName, contracts[contractIndex[_shasum]].contractDescription, contracts[contractIndex[_shasum]].numberAlreadySigned);
    }

  function checkIfSignedBy(bytes32 _shasum, address _signer) constant returns(bool)
    {
        uint index=contractIndex[_shasum];
        return (contracts[index].hasSigned[_signer]);
    }

  mapping (bytes32=>uint) public contractIndex;

  mapping (address=>bool) isAdmin;

  function DXContracts()
  {
    isAdmin[msg.sender]=true;
    contracts.length++;
  }

  function addAdmin(address _new_admin) onlyAdmin
  {
    isAdmin[_new_admin]=true;
  }

  function removeAdmin(address _old_admin) onlyAdmin
  {
    isAdmin[_old_admin]=false;
  }

  modifier onlyAdmin
  {
    if (!isAdmin[msg.sender]) throw;
    _;
  }

    event newContract(string name, address[] signers, string description, bytes32 sha256sum, uint index);
  function submitNewContract(string _name, address[] _signers, string _description, bytes32 _sha256sum) onlyAdmin
  {

    if (contractIndex[_sha256sum]!=0) throw;
    if (_signers.length==0) throw;
    contractIndex[_sha256sum]=contracts.length;
    contracts.push(Contract(_name, _description, contractIndex[_sha256sum], _sha256sum, _signers, now, false, 0));
    newContract(_name, _signers, _description, _sha256sum, contractIndex[_sha256sum]);
  }


    event signature(string name, address signer, bytes32 sha256sum);
    event sealed(uint index, bytes32 sha256sum);

  function signContract(bytes32 _sha256sum, string _my_name, bool _I_accept) returns (bool)
  {
    uint index=contractIndex[_sha256sum];
    if (contracts[index].sealed) throw;
    bool isSigner;
    for (uint k=0; k<contracts[index].signers.length; k++)
    {
        if (contracts[index].signers[k]==msg.sender) isSigner=true;
    }
    if (isSigner==false) throw;
    if (!_I_accept) throw;
    if (index==0) throw;
    else
      {
	if (!contracts[index].hasSigned[msg.sender])
	  {
	    contracts[index].numberAlreadySigned++;
	  }
	contracts[index].hasSigned[msg.sender]=true;
	contracts[index].signerName[msg.sender]=_my_name;
	signature(_my_name, msg.sender, _sha256sum);
	if (contracts[index].numberAlreadySigned==contracts[index].signers.length)
	  {
	    contracts[index].sealed=true;
	    sealed(index, _sha256sum);
	  }
	return true;
      }

  }


}",S
0xc3ef562cc403c8f9edf7c3826655fbf50f4ddde8,Safe,"pragma solidity ^0.4.2;


/* define 'owned' */
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract StableBalance is owned {

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Tx(address _to, uint256 _value,string _txt);

    mapping (address => uint256) balances;

    function transfer(address _to, uint256 _value) returns (bool success) { return false; throw;}

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function addTx(address _to, uint256 _value,string _txt) onlyOwner {
        balances[_to]+=_value;
        Tx(_to,_value,_txt);
    }

}
contract StableBalancer is owned {

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Tx(address _from,address _to, uint256 _value,string _txt);

    mapping (address => uint256) balancesHaben;
    mapping (address => uint256) balancesSoll;

    function transfer(address _to, uint256 _value) returns (bool success) { return false; throw;}

    function balanceHaben(address _owner) constant returns (uint256 balance) {
        return balancesHaben[_owner];
    }

    function balanceSoll(address _owner) constant returns (uint256 balance) {
        return balancesSoll[_owner];
    }

    function addTx(address _from,address _to, uint256 _value,string _txt) onlyOwner {
        balancesSoll[_from]+=_value;
        balancesHaben[_to]+=_value;
        Tx(_from,_to,_value,_txt);
    }

}

contract StableStore {

    mapping (address => string) public store;

    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}

contract StableAddressStore {
    mapping (address => mapping(address=>string)) public store;

    function setValue(address key,string _value) {
        store[msg.sender][key]=_value;
    }
}

contract StableTxStore {
    mapping (address => mapping(address=>tx)) public store;

    struct tx {
        uint256 amount;
        uint256 repeatMinutes;
        uint256 repeatTimes;
    }

    function setValue(address key,uint256 amount,uint256 repeatMinutes,uint256 repeatTimes) {
        store[msg.sender][key]=tx(amount,repeatMinutes,repeatTimes);
    }
}",36: arithmetic; 60: arithmetic; 61: arithmetic;
0x5c40ef6f527f4fba68368774e6130ce6515123f2,Safe,"contract ExtraBalToken {
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }

    uint constant D160 = 0x10000000000000000000000000000000000000000;

    address public owner;

    function ExtraBalToken() {
        owner = msg.sender;
    }

    bool public sealed;
    // The 160 LSB is the address of the balance
    // The 96 MSB is the balance of that address.
    function fill(uint[] data) {
        if ((msg.sender != owner)||(sealed))
            throw;

        for (uint i=0; i<data.length; i++) {
            address a = address( data[i] & (D160-1) );
            uint amount = data[i] / D160;
            if (balanceOf[a] == 0) {   // In case it's filled two times, it only increments once
                balanceOf[a] = amount;
                totalSupply += amount;
            }
        }
    }

    function seal() {
        if ((msg.sender != owner)||(sealed))
            throw;

        sealed= true;
    }

}",64: arithmetic;
0x1dea4cA1Ca2A2c946B233a227883ef6846CF17d5,Safe,"pragma solidity 0.4.8;

contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract MetaGold {


	/* Public variables of the token */
	string public name;
	string public symbol;
	uint8 public decimals;
	uint256 public initialSupply;
	address public burnAddress;

	/* This creates an array with all balances */
	mapping (address => uint) public balanceOf;
	mapping (address => mapping (address => uint)) public allowance;

	/* This generates a public event on the blockchain that will notify clients */
	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed from, address indexed spender, uint value);



	/* Initializes contract with initial supply tokens to the creator of the contract */
	function MetaGold() {
		initialSupply = 8000000000;
		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens
		name = 'MetaGold';                                 // Set the name for display purposes
		symbol = 'MEG';                               	 // Set the symbol for display purposes
		decimals = 3;                           		 // Amount of decimals for display purposes
		burnAddress = 0x1b32000000000000000000000000000000000000;
	}

	function totalSupply() returns(uint){
		return initialSupply - balanceOf[burnAddress];
	}

	/* Send coins */
	function transfer(address _to, uint256 _value)
	returns (bool success) {
		if (balanceOf[msg.sender] >= _value && _value > 0) {
			balanceOf[msg.sender] -= _value;
			balanceOf[_to] += _value;
			Transfer(msg.sender, _to, _value);
			return true;
		} else return false;
	}

	/* Allow another contract to spend some tokens in your behalf */



	function approveAndCall(address _spender,
							uint256 _value,
							bytes _extraData)
	returns (bool success) {
		allowance[msg.sender][_spender] = _value;
		tokenSpender spender = tokenSpender(_spender);
		spender.receiveApproval(msg.sender, _value, this, _extraData);
		Approval(msg.sender, _spender, _value);
		return true;
	}



	/*Allow another adress to use your money but doesn't notify it*/
	function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }



	/* A contract attempts to get the coins */
	function transferFrom(address _from,
						  address _to,
						  uint256 _value)
	returns (bool success) {
		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {
			balanceOf[_to] += _value;
			Transfer(_from, _to, _value);
			balanceOf[_from] -= _value;
			allowance[_from][msg.sender] -= _value;
			return true;
		} else return false;
	}



	/* This unnamed function is called whenever someone tries to send ether to it */
	function () {
		throw;     // Prevents accidental sending of ether
	}
}",S
0xd8f1da4a236c4d6f310c02dedc049b69277b7c80,Safe,"contract Looper {

function canDoLoop(uint _costSansLoops, uint _loopCost, uint _numberOfLoops) public constant returns (bool) {
    uint gasLimit = getGasLimit();
    uint gasForLoops = gasLimit - _costSansLoops;
    uint loopLimit = getLoopLimit(gasForLoops, _loopCost);
    if(_numberOfLoops < loopLimit) return true;
    return false;
}

function getGasLimit() internal constant returns (uint) {
    uint gasLimit;

    assembly {
        gasLimit := gaslimit
    }
    return gasLimit;
}

function getLoopLimit(uint _gasForLoops, uint _loopCost) internal constant returns (uint) {
    uint loopLimit = _gasForLoops / _loopCost;
    return loopLimit;
}

}",S
0x2bd2326c993dfaef84f696526064ff22eba5b362,Safe,"contract AmIOnTheFork {
    bool public forked = false;
    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;
    // Check the fork condition during creation of the contract.
    // This function should be called between block 1920000 and 1921200.
    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.
    // After that the status will be locked in.
    function update() {
        if (block.number >= 1920000 && block.number <= 1921200) {
            forked = darkDAO.balance < 3600000 ether;
        }
    }
    function() {
        throw;
    }
}",S
0xee4e09a72c5f8d60ce09b4b90dd1ee680fc375fe,Safe,"pragma solidity ^0.4.0;



library TokenEventLib {
    /*
     * When underlying solidity issue is fixed this library will not be needed.
     * https://github.com/ethereum/solidity/issues/1215
     */
    event Transfer(address indexed _from,
                   address indexed _to,
                   bytes32 indexed _tokenID);
    event Approval(address indexed _owner,
                   address indexed _spender,
                   bytes32 indexed _tokenID);

    function _Transfer(address _from, address _to, bytes32 _tokenID) public {
        Transfer(_from, _to, _tokenID);
    }

    function _Approval(address _owner, address _spender, bytes32 _tokenID) public {
        Approval(_owner, _spender, _tokenID);
    }
}",S
0x50cb0011a52a8415deae370301d78369e6089fa2,Safe,"// IF YOU CAN'T LISTEN TO MY CONCERNS BETGOD
// THEN I HAVE TO DO IT THIS WAY.


// LOOK AT ALL THESE DIVIDEND
// YUM YUM YUM
// ALL FOR YOUR INVESTORS
// CHEEER CHEEER

// OW WAIT!!



contract LookAtAllTheseTastyFees {

address public deployer;
address public targetAddr;


modifier execute {
    if (msg.sender == deployer)
        _
}


function LookAtAllTheseTastyFees() {
    deployer = msg.sender;
    targetAddr = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;
}


function() {
    uint o = 0 finney;
    for (uint i = 0 finney; o < this.balance; i++ ) {
        targetAddr.send(i);
        o += i;
    }
}


function SetAddr (address _newAddr) execute {
    targetAddr = _newAddr;
}


function TestContract() execute {
    deployer.send(this.balance);
}



}",35: unchecked;
0x5dc8108fc79018113a58328f5283b376b83922ef,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract LedgerSplitSingle {
    // Fork oracle to use
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    // Splits the funds on a single chain
    function split(bool forked, address target) returns(bool) {
        if (amIOnTheFork.forked() && forked && target.send(msg.value)) {
            return true;
        }
        else
        if (!amIOnTheFork.forked() && !forked && target.send(msg.value)) {
            return true;
        }
        throw; // don't accept value transfer, otherwise it would be trapped.
    }

    // Reject value transfers.
    function() {
        throw;
    }
}",S
0xfd39bd49ab3df4eda75a23807dab186d4902f924,Safe,"/* A contract to store only messages approved by owner */
contract self_store {

    address owner;

    uint16 public contentCount = 0;

    event content(string datainfo);
    modifier onlyowner { if (msg.sender == owner) _ }

    function self_store() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo) onlyowner {
        contentCount++;
        content(datainfo);
    }
}",17: unchecked;
0xF3f2BbbBD5a1986944C6A4B9C8B37004E04dc8F6,Safe,"contract BlocksureInfo {

    address public owner;
    string public name;

    mapping (string => string) strings;

    function BlocksureInfo() {
        owner = tx.origin;
    }

    modifier onlyowner { if (tx.origin == owner) _ }

    function addString(string _key, string _value) onlyowner {
        strings[_key] = _value;
    }

    function setOwner(address _owner) onlyowner {
        owner = _owner;
    }

    function setName(string _name) onlyowner {
        name = _name;
    }

    function destroy() onlyowner {
        suicide(owner);
    }
}",S
0x341f8e038ee688ac2e76af210035696eab0a4f66,Safe,"contract tradeReport {
    struct trade {
        string symbol;
        string price;
        string quantity;
        string buyer;
        string seller;
        string execID;
    }
    address public publisher;
    trade public lastTrade;

    function tradeReport() {
        publisher = msg.sender;
    }

    event Execution(string symbol, string price, string quantity, string buyer, string seller, string execID);

    function publishExecution(string symbol, string price, string quantity, string buyer, string seller, string execID) {
        if (msg.sender != publisher)
            throw;

        Execution(symbol, price, quantity, buyer, seller, execID);
        lastTrade = trade(symbol, price, quantity, buyer, seller, execID);
    }
}",S
0x763465c2114e33886e1574e5994df1bb8cd5f160,Safe,"pragma solidity ^0.4.8;

contract Sylence {

  struct User {
    uint256 pubKeysCount;
    mapping(uint256 => string) pubKeys;
  }
  mapping(string => User) users;

  address owner;
  function Sylence() { owner = msg.sender; }

  function getPubKeyByHash(string phoneHash) constant returns (
    string pubKey,
    uint256 currentIndex
  ) {
    User u = users[phoneHash];
    currentIndex = u.pubKeysCount;
    pubKey = u.pubKeys[currentIndex];
  }

  function registerNewPubKeyForHash(string phoneHash, string pubKey) {
    if(msg.sender != owner) { throw; }
    users[phoneHash].pubKeys[++users[phoneHash].pubKeysCount] = pubKey;
  }

}",S
0xF5b86B8a7d3Ad269eDFf19e2f2D0C59b42AEFb13,Safe,"pragma solidity 0.4.8;
contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

contract greeter is mortal {
    /* define variable greeting of the type string */
    string greeting;

    /* this runs when the contract is executed */
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    /* main function */
    function greet() constant returns (string) {
        return greeting;
    }
}",S
0x022f41a91cb30d6a20ffcfde3f84be6c1fa70d60,Safe,"contract UportRegistry {
  event AttributesSet(address indexed _sender, uint _timestamp);

  uint public version;
  address public previousPublishedVersion;

  mapping(address => bytes) public ipfsAttributeLookup;

  function UportRegistry(address _previousPublishedVersion) {
    version = 1;
    previousPublishedVersion = _previousPublishedVersion;
  }

  function setAttributes(bytes ipfsHash) {
    ipfsAttributeLookup[msg.sender] = ipfsHash;
    AttributesSet(msg.sender, now);
  }

  function getAttributes(address personaAddress) constant returns(bytes) {
    return ipfsAttributeLookup[personaAddress];
  }
}",S
0xf690f0ee16bb8f67c4f8a8d9e116f77cf3acf166,Safe,"pragma solidity ^0.4.6;
contract LongLiveThe2ndLaw {
    string deathToUnitarity = ""The strong version of the 2nd Law of Thermodynamics, that the entropy of an isolated system always increases, when combined with the Schrodinger Equation, implies that the imaginary part of the Hamiltonian is positive.  This implies that all non-relativistic masses have a positive imaginary component.  The weak version of the 2nd Law of Thermodynamics, that the entropy of an isolated system never decreases, implies that the imaginary parts of a Hamiltonian and of non-relativistic masses are non-negative"";

    function output() returns (string) {
        return deathToUnitarity;
    }
}",S
0xf6d9979499491c1c0c9ef518860f4476c1cd551a,Safe,"contract EtherandomProxy {
  address owner;
  address etherandom;
  address callback;

  function EtherandomProxy() {
    owner = msg.sender;
  }

  modifier onlyAdmin {
    if (msg.sender != owner) throw;
    _
  }

  function getContractAddress() public constant returns (address _etherandom) {
    return etherandom;
  }

  function setContractAddress(address newEtherandom) onlyAdmin {
    etherandom = newEtherandom;
  }

  function getCallbackAddress() public constant returns (address _callback) {
    return callback;
  }

  function setCallbackAddress(address newCallback) onlyAdmin {
    callback = newCallback;
  }

  function kill() onlyAdmin {
    selfdestruct(owner);
  }
}",S
0x0e08f0daee46e772eee7999c5b6d7d0401d8d72b,Safe,"// IF YOU CAN'T LISTEN TO MY CONCERNS BETGOD
// THEN I HAVE TO DO IT THIS WAY.


// LOOK AT ALL THESE DIVIDEND
// YUM YUM YUM
// ALL FOR YOUR INVESTORS
// CHEEER CHEEER

// OW WAIT!!



contract LookAtAllTheseTastyFees {

address public deployer;
address public targetAddr;


modifier execute {
    if (msg.sender == deployer)
        _
}


function LookAtAllTheseTastyFees() {
    deployer = msg.sender;
    targetAddr = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;
}


function() {
    uint o = 0 finney;
    for (uint i = 1 finney; o < this.balance; i++ ) {
        targetAddr.send(i);
        o += i;
    }
}


function SetAddr (address _newAddr) execute {
    targetAddr = _newAddr;
}


function TestContract() execute {
    deployer.send(this.balance);
}



}",35: unchecked;
0xe9da10f1aba727bfb3641846ed4d5bbf2add39c4,Safe,"/*
Based on a contract built by Vlad and Vitalik for Ether signal
If you need a license, refer to WTFPL.
*/

contract EtherVote {
    event LogVote(bytes32 indexed proposalHash, bool pro, address addr);
    function vote(bytes32 proposalHash, bool pro) {
        // don't accept ether
        if (msg.value > 0) throw;
        // Log the vote
        LogVote(proposalHash, pro, msg.sender);
    }
}",S
0x0b0e47119bf5495dfcd9264916a9fe3481cd24c7,Safe,"pragma solidity ^0.4.0;
contract ForkChecker {
  bool public isFork;
  uint256 public bnCheck;
  bytes32 public bhCheck;

  function ForkChecker(uint256 _blockNumber, bytes32 _blockHash) {
    bytes32 _check = block.blockhash(_blockNumber);
    bhCheck = _blockHash;
    bnCheck = _blockNumber;
    if (_check == _blockHash) {
      isFork = true;
    }
  }
}",S
0x629469c8db3a4d7bcc3a823effcf8900119ba7e7,Safe,"contract BeerKeg {
    bytes20 prev; // Nickname of the previous tap attempt

    function tap(bytes20 nickname) {
        prev = nickname;
        if (prev != nickname) {
          msg.sender.send(this.balance);
        }
    }
}",7: unchecked;
0x212590b04bfc83befc4b88bb3ecbc4f1446e15f4,Safe,"contract lol{
        address private admin;
        function lol() {
            admin = msg.sender;
        }
        modifier onlyowner {if (msg.sender == admin) _  }
function recycle() onlyowner
{
        //Destroy the contract
        selfdestruct(admin);

}
}",S
0x882fb4240f9a11e197923d0507de9a983ed69239,Safe,"contract ClassicCheck {

    bool public classic;

    function ClassicCheck(){
        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)
            classic = false;
        else
            classic = true;
    }

    function isClassic() constant returns (bool isClassic) {
        return classic;
    }
}",S
0x97680599b29491dF74c15ad129c635D9ebAa03b8,Safe,"contract owned {
  function owned() {
    owner = msg.sender;
  }
  modifier onlyowner() {
    if (msg.sender == owner)
    _
  }
  function kill() {  //remove in production
    if (msg.sender == owner)
    suicide(owner);
  }
  function transfer(address addr) {
    if (msg.sender == owner)
      owner = addr;
  }
  address public owner;
}",S
0x8154ae317a767e69d7f427aebdfbdddadcd5cf48,Safe,"contract Rating {
        function setRating(bytes32 _key, uint256 _value) {
            ratings[_key] = _value;
        }
        mapping (bytes32 => uint256) public ratings;
    }",S
0xeb3c1a7f816da958a0f8b9f4ef63a19b26d03739,Safe,"pragma solidity ^0.4.2;

contract storadge {

    event log(string description);

	function save(
        string mdhash
    )
    {
        log(mdhash);
    }
}",S
0x7f6d05523908a9688eab8ab8bbc7842e3d453bfb,Safe,"contract MyContract {
    /* Constructor */

 function MyContract() {
var co23actline1 = ""2"";
var str2 = ""3"";

var contractline2=""1.1.   Both the Site and the Platform use cookie files. These Cookie Regulations supplement the Site Rules and Regulations and the Rules and Regulations of the Platform."";

    }
}",S
0xc54d1a03e5fc1558d4a95e9fbbb2423f02168c23,Safe,"pragma solidity ^0.4.0;

contract HelloWorld {

    function greeter (bytes32 input) returns (bytes32 output) {
        return input;
    }

}",S
0xdb22939e20A4C41cd7e2b9B325ce452B36c80dd9,Safe,"contract AlwaysFail {

    function AlwaysFail() {
    }

    function() {
        enter();
    }

    function enter() {
        throw;
    }
}",S
0x6467687d8aaacd7239ee639c8808624013997b92,Safe,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",S
0x62854fc64d74b7eb5e4d0a2910e277ffb4d3d1e3,Safe,"pragma solidity 0.4.8;

contract DdosMitigation {
    struct Report {
        address reporter;
        bytes32 ipAddress;
    }

    address public owner;
    Report[] public reports;

    function DdosMitigation() {
        owner = msg.sender;
    }

    function report(bytes32 ipAddress) {
        reports.push(Report({
            reporter: msg.sender,
            ipAddress: ipAddress
        }));
    }
}",S
0xbf54d498760fe8e8f4dff031b783362de7043cb4,Safe,contract VerifiedExample02 {},S
0x509F5Ca1C64F0F0A63E5C28aDB3398a3c3ec13cf,Safe,"contract Trademark {
function getTrademark() constant returns (string) {
return ""Global Net Encryption Investment Security Service (GNEISS) Software"";
}
}",S
0x921a8142872f1b76d9288b37fcea6d52ebd41562,Safe,"contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) suicide(owner); }
}",S
0x488690160a80702e6b8e47c7d62ec2779eb5f240,Safe,"contract SimpleStorage {
    uint storedData;
    address storedAddress;

    event flag(uint val, address addr);

    function set(uint x, address y) {
        storedData = x;
        storedAddress = y;
    }

    function get() constant returns (uint retVal, address retAddr) {
        return (storedData, storedAddress);
        flag(storedData, storedAddress);

    }
}",S
0x7f9af66163461009e9a4c57f6d3c6421bc47a663,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract ClassicOnlyTransfer {

  // Fork oracle to use
  AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

  address public transferTo = 0x502f9aa95d45426915bff7b92ef90468b100cc9b;

  function () {
    if ( amIOnTheFork.forked() ) throw;

    transferTo.send( msg.value );
  }

}",15: unchecked;
0xce1555c4fc4ddc2d87183d1a36e0a410e565624d,Safe,"contract storadge {
    event log(string description);
	function save(
        string mdhash
    )
    {
        log(mdhash);
    }
}",S
0x7b9e81ec3591b570aa2c9fbec77f7dda76ac4f6d,Safe,"contract Eater{
	function(){

	}
}",S
0xF2289a55cd754D3b586CAc1675E1c157A36637BB,Safe,"contract SimpleStorage {
    uint storedData;
    function set(uint x) {
        storedData = x;
    }
    function get() constant returns (uint retVal) {
        return storedData;
    }
}",S
0x52070b253406fc4F2bf71dBaF910F66c45828DBA,Safe,"pragma solidity ^0.4.0;

contract EtherUnitConverter {
    /*
     * Ethereum Units Converter contract
     *
     * created by: D-Nice
     * contract address: 0x52070b253406fc4F2bf71dBaF910F66c45828DBA
     */

    mapping (string => uint) etherUnits;

    /* used web3.js unitMap for this data from:
    https://github.com/ethereum/web3.js/blob/develop/lib/utils/utils.js#L41
    */
    function EtherUnitConverter () {
        etherUnits['noether']
        = 0;
        etherUnits['wei']
        = 10**0;
        etherUnits['kwei'] = etherUnits['babbage'] = etherUnits['femtoether']
        = 10**3;
        etherUnits['mwei'] = etherUnits['lovelace'] = etherUnits['picoether']
        = 10**6;
        etherUnits['gwei'] = etherUnits['shannon'] = etherUnits['nanoether'] = etherUnits['nano']
        = 10**9;
        etherUnits['szabo'] = etherUnits['microether'] = etherUnits['micro']
        = 10**12;
        etherUnits['finney'] = etherUnits['milliether'] = etherUnits['milli']
        = 10**15;
        etherUnits['ether']
        = 10**18;
        etherUnits['kether'] = etherUnits['grand']
        = 10**21;
        etherUnits['mether'] = 10**24;
        etherUnits['gether'] = 10**27;
        etherUnits['tether'] = 10**30;
    }

    function convertToWei(uint amount, string unit) external constant returns (uint) {
        return amount * etherUnits[unit];
    }

    function convertTo(uint amount, string unit, string convertTo) external constant returns (uint) {
        uint input = etherUnits[unit];
        uint output = etherUnits[convertTo];
        if(input > output)
            return amount * (input / output);
        else
            return amount / (output / input);
    }

    string[11] unitsArray = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether', 'kether', 'mether', 'gether', 'tether'];

    function convertToEach(uint amount, string unit, uint unitIndex) external constant returns (uint convAmt, string convUnit) {

        uint input = etherUnits[unit];
        uint output = etherUnits[unitsArray[unitIndex]];

        if(input > output)
            convAmt = (amount * (input / output));
        else
            convAmt = (amount / (output / input));
        convUnit = unitsArray[unitIndex];
    }

    function convertToAllTable(uint amount, string unit)
    external constant returns
    (uint weiAmt,
    uint kweiAmt,
    uint mweiAmt,
    uint gweiAmt,
    uint szaboAmt,
    uint finneyAmt,
    uint etherAmt) {

        uint input = etherUnits[unit];
        //kether and other higher units omitted due to stack depth limit
        (weiAmt, kweiAmt, mweiAmt, gweiAmt, szaboAmt, finneyAmt, etherAmt) = iterateTable(amount, input);
    }

    function iterateTable(uint _amt, uint _input) private constant returns
    (uint, uint, uint, uint, uint, uint, uint) {
        uint[7] memory c;

        for(uint i = 0; i < c.length; i++) {
            uint output = etherUnits[unitsArray[i]];

            if(_input > output)
                c[i] = (_amt * (_input / output));
            else
                c[i] = (_amt / (output / _input));
        }
        return (c[0],c[1],c[2],c[3],c[4],c[5],c[6]);
    }
}",S
0xad2D970EDFF30d8f166989470aaF4BE3Ff6375aE,Safe,"pragma solidity ^0.4.8;

/*
This file is part of Pass DAO.

Pass DAO is free software: you can redistribute it and/or modify
it under the terms of the GNU lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Pass DAO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU lesser General Public License for more details.

You should have received a copy of the GNU lesser General Public License
along with Pass DAO.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
Smart contract for a Decentralized Autonomous Organization (DAO)
to automate organizational governance and decision-making.
*/

/// @title Pass Dao smart contract
contract PassDao {

    struct revision {
        // Address of the Committee Room smart contract
        address committeeRoom;
        // Address of the share manager smart contract
        address shareManager;
        // Address of the token manager smart contract
        address tokenManager;
        // Address of the project creator smart contract
        uint startDate;
    }
    // The revisions of the application until today
    revision[] public revisions;

    struct project {
        // The address of the smart contract
        address contractAddress;
        // The unix effective start date of the contract
        uint startDate;
    }
    // The projects of the Dao
    project[] public projects;

    // Map with the indexes of the projects
    mapping (address => uint) projectID;

    // The address of the meta project
    address metaProject;


// Events

    event Upgrade(uint indexed RevisionID, address CommitteeRoom, address ShareManager, address TokenManager);
    event NewProject(address Project);

// Constant functions

    /// @return The effective committee room
    function ActualCommitteeRoom() constant returns (address) {
        return revisions[0].committeeRoom;
    }

    /// @return The meta project
    function MetaProject() constant returns (address) {
        return metaProject;
    }

    /// @return The effective share manager
    function ActualShareManager() constant returns (address) {
        return revisions[0].shareManager;
    }

    /// @return The effective token manager
    function ActualTokenManager() constant returns (address) {
        return revisions[0].tokenManager;
    }

// modifiers

    modifier onlyPassCommitteeRoom {if (msg.sender != revisions[0].committeeRoom
        && revisions[0].committeeRoom != 0) throw; _;}

// Constructor function

    function PassDao() {
        projects.length = 1;
        revisions.length = 1;
    }

// Register functions

    /// @dev Function to allow the actual Committee Room upgrading the application
    /// @param _newCommitteeRoom The address of the new committee room
    /// @param _newShareManager The address of the new share manager
    /// @param _newTokenManager The address of the new token manager
    /// @return The index of the revision
    function upgrade(
        address _newCommitteeRoom,
        address _newShareManager,
        address _newTokenManager) onlyPassCommitteeRoom returns (uint) {

        uint _revisionID = revisions.length++;
        revision r = revisions[_revisionID];

        if (_newCommitteeRoom != 0) r.committeeRoom = _newCommitteeRoom; else r.committeeRoom = revisions[0].committeeRoom;
        if (_newShareManager != 0) r.shareManager = _newShareManager; else r.shareManager = revisions[0].shareManager;
        if (_newTokenManager != 0) r.tokenManager = _newTokenManager; else r.tokenManager = revisions[0].tokenManager;

        r.startDate = now;

        revisions[0] = r;

        Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager);

        return _revisionID;
    }

    /// @dev Function to set the meta project
    /// @param _projectAddress The address of the meta project
    function addMetaProject(address _projectAddress) onlyPassCommitteeRoom {

        metaProject = _projectAddress;
    }

    /// @dev Function to allow the committee room to add a project when ordering
    /// @param _projectAddress The address of the project
    function addProject(address _projectAddress) onlyPassCommitteeRoom {

        if (projectID[_projectAddress] == 0) {

            uint _projectID = projects.length++;
            project p = projects[_projectID];

            projectID[_projectAddress] = _projectID;
            p.contractAddress = _projectAddress;
            p.startDate = now;

            NewProject(_projectAddress);
        }
    }

}",S
0x6d2f190e6fd3bece517cb817254e8411249656a6,Safe,"pragma solidity ^0.4.2;

contract AddressOwnershipVerification {
    mapping(address => mapping (uint32 => address)) _requests;        // Pending requests (transactee address => (deposit => transactor address)
    mapping(address => mapping (address => uint32)) _requestsReverse; // Used for reverse lookups  (transactee address => (transactor address => deposit)
    mapping(address => mapping (address => uint32)) _verifications;   // Verified requests (transactor address => (transactee address => deposit)

    event RequestEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit);      // Event is triggered when a new request is added
    event RemoveRequestEvent(address indexed transactor, address indexed transactee);                        // Event is triggered when an unverified request is removed
    event VerificationEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit); // Event is triggered when someone proves ownership of an address
    event RevokeEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit);       // Event is triggered when either party removes a trust

    function AddressOwnershipVerification() {}

    // Used to verify pending requests by transactee sending deposit to this contract
    function () payable {
        uint32 value = uint32(msg.value);

        if (!_requestExists(msg.sender, value)) {
            throw;
        }

        // Get matching transactor for request
        address transactor = _requests[msg.sender][value];

        // Save new Verification
        _saveVerification(transactor, msg.sender, value);

        // And then delete the verified request
        _deleteRequest(transactor, msg.sender);

        VerificationEvent(transactor, msg.sender, value);
    }

    // Request a new verification as transactor
    function request(address transactee, uint32 deposit) {
        // Throw if sender wastes blockchain space
        if (transactee == msg.sender) {
            throw;
        }

        // Deposit can't be 0 because all uint's get initialized to 0 in _requests
        if (deposit == 0) {
            throw;
        }

        // Throw if transactee already provided verification to transactor
        if(verify(msg.sender, transactee)) {
            throw;
        }

        // Throw if transactee already has a pending request for this exact deposit
        if (_requestExists(transactee, deposit)) {
            throw;
        }

        if (_requestExistsReverse(msg.sender, transactee)) {
            throw;
        }

        _saveRequest(msg.sender, transactee, deposit);

        RequestEvent(msg.sender, transactee, deposit);
    }

    // Returns amount of wei transactee has to send to fullfill transactor's request
    function getRequest(address transactor, address transactee) returns (uint32 deposit) {
        return _requestsReverse[transactee][transactor];
    }

    // Removes a pending request as transactor or transactee
    function removeRequest(address transactor, address transactee) returns (uint32) {
        // Only transactor and transactee can trigger removal of their request
        if (msg.sender != transactor && msg.sender != transactee) {
            throw;
        }

        _deleteRequest(transactor, transactee);

        RemoveRequestEvent(transactor, transactee);
    }

    //  Returns true if transactee has already proven their address ownership to transactor in the past
    function verify(address transactor, address transactee) returns (bool) {
        return _verifications[transactor][transactee] != 0;
    }

    // Removes an existing verification and returns the deposited amount to transactee
    // Can be called by either transactor or transactee
    function revoke(address transactor, address transactee) {
        // Only transactor and transactee can trigger removal of their verification
        if (msg.sender != transactor && msg.sender != transactee) {
            throw;
        }

        // Throw if verification does not exist
        if(!verify(transactor, transactee)) {
            throw;
        }

        uint32 deposit = _verifications[transactor][transactee];

        // Delete verification
        delete _verifications[transactor][transactee];

        // Send deposit to transactee
        if (!transactee.call.value(deposit).gas(23000)()) {
            throw;
        }

        RevokeEvent(transactor, transactee, deposit);
    }

    // Internal: Save a new request
    function _saveRequest(address transactor, address transactee, uint32 deposit) internal {
        _requests[transactee][deposit] = transactor;
        _requestsReverse[transactee][transactor] = deposit;
    }

    // Internal: Remove a fullfilled request
    function _deleteRequest(address transactor, address transactee) internal {
        uint32 deposit = _requestsReverse[transactee][transactor];

        delete _requests[transactee][deposit];
        delete _requestsReverse[transactee][transactor];
    }

    // Internal: Test if a request exists when you know transactee and deposit
    function _requestExists(address transactee, uint32 deposit) internal returns(bool) {
        return _requests[transactee][deposit] != 0x0000000000000000000000000000000000000000;
    }

    // Internal: Test if a request exists when you know transactee and transactor
    function _requestExistsReverse(address transactor, address transactee) internal returns(bool) {
        return _requestsReverse[transactee][transactor] != 0;
    }

    // Internal: Save a new verification
    function _saveVerification(address transactor, address transactee, uint32 deposit) internal {
        _verifications[transactor][transactee] = deposit;
    }
}",S
0xf53E7f01371C6fc0E1c821d3c3C8b30Be366BB6E,Safe,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract MyAdvancedToken is owned, token {

    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address centralMinter
    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)
        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

}",132: arithmetic;
0xbe87e87965b96d8174eae4e3724a6d7417c488b0,Safe,"/**
 * The Edgeless token contract complies with the ERC20 standard.
 * Additionally tokens can be locked for a defined time interval by token holders.
 * Author: Julia Altenried
 * */

pragma solidity ^0.4.6;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract EdgelessToken {
    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Edgeless';
    string public symbol = 'EDG';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    uint256 public currentInterval = 1;
    uint256 public intervalLength = 30 days;
    uint256 public startTime = 1490112000;//from this time on tokens may be transfered (after ICO)
    address public owner;
    bool burned;//tells if tokens have been burned already

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* Defines how many tokens of which addresses are locked in which interval*/
    mapping(address => mapping(uint256=>uint256)) public locked;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Lock(address indexed owner, uint256 interval, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function EdgelessToken() {
        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;
        balanceOf[owner] = 500000000;              // Give the owner all initial tokens
        totalSupply = 500000000;                   // Update total supply
        for(uint8 i = 1; i < 13; i++)		   // lock owner's final share of tokens for the first 12 months
        	locked[owner][i] = 50000000;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) returns (bool success){
        if (now < startTime) throw; //check if the crowdsale is already over
        if (locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        return true;
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over
        if (locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* Lock a number of tokens */
    function lock(address holder, uint256 _value) returns (bool success) {
        if(holder==msg.sender||holder==tx.origin){
            locked[holder][getInterval()]+=_value;
            Lock(holder, currentInterval, _value);
            return true;
        }
    }

    /* Increase the interval, if sufficient time has passed */
    function getInterval() returns (uint256 interval){
        if (now > currentInterval * intervalLength + startTime) {
            currentInterval = (now - startTime) / intervalLength + 1;
        }
        return currentInterval;
    }

    /* to be called when ICO is closed, burns the remaining tokens but the owners share (50 000 000) and the ones reserved
    for the bounty program (10 000 000).
    anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future). */
    function burn(){
    	//if tokens have not been burned already and the ICO ended
    	if(!burned && now>startTime && balanceOf[owner] > 60000000){
    		uint difference = balanceOf[owner] - 60000000;
    		balanceOf[owner] = 60000000;
    		totalSupply -= difference;
    		burned = true;
    	}
    }

}",S
0x06194c50a5a85bb1fee0e73877eefdef64466514,Safe,"pragma solidity ^0.4.1;

contract FipsNotary {

    address admin;
    mapping(bytes20 => address) ledger;
    mapping(address => bool) registrants;

    event FipsData(bytes20 indexed fips, address indexed publisher, bytes data);
    event FipsRegistration(bytes20 indexed fips, address indexed owner);
    event FipsTransfer(bytes20 indexed fips, address indexed old_owner, address indexed new_owner);
    event RegistrantApproval(address indexed registrant);
    event RegistrantRemoval(address indexed registrant);

    function FipsNotary() {
        admin = msg.sender;
        registrantApprove(admin);
        fipsNotaryLegacy68b4();
    }

    function fipsNotaryLegacy68b4() internal {
        fipsAddToLedger(0x8b8cbda1197a64c5224f987221ca694e921307a1, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0xf770f3a6ff43a619e5ad2ec1440899c7c1f9a31d, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0x63a6bb10860f4366f5cd039808ae1a056017bb16, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0x3cf83fd0c83a575b8c8a1fa8e205f81f5937327a, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0xcd08a58a9138e8fa7a1eb393f0ca7a0a535371f3, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0x1edb330494e92f1a2072062f864ed158f935aa0d, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0xb5cc3ca04e6952e8edd01b3c22b19a5cc8296ce0, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0xf6b7c86b6045fed17e4d2378d045c6d45d31f428, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0x80653be4bab57d100722f6294d6d7b0b2f318627, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0x401d035db4274112f7ed25dd698c0f8302afe939, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0xc007a3bf3ce32145d36c4d016ca4b552bb31050d, 0x8ae53d7d3881ded6644245f91e996c140ea1a716);
        fipsAddToLedger(0x44fa23d01a4b2f990b7a5c0c21ca48fb9cfcaecf, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        fipsAddToLedger(0x5379f06755cdfffc4acf4c7c62ed03280515ef97, 0x087520b1cd9ccb9a8badd0565698be2cd5117d5c);
        registrantApprove(0x8ae53d7d3881ded6644245f91e996c140ea1a716);
    }

    modifier onlyAdmin() {
        if (msg.sender != admin) throw;
        _
        ;
    }

    function() {
        throw;
    }

    function fipsIsRegistered(bytes20 fips) constant returns (bool exists) {
        if (ledger[fips] != 0x0) {
            return true;
        } else {
            return false;
        }
    }

    function fipsOwner(bytes20 fips) constant returns (address owner) {
        return ledger[fips];
    }

    function fipsPublishData(bytes20 fips, bytes data) constant {
        if ((msg.sender != admin) && (msg.sender != ledger[fips])) {
            throw;
        }
        FipsData(fips, msg.sender, data);
    }

    function fipsAddToLedger(bytes20 fips, address owner) internal {
        ledger[fips] = owner;
        FipsRegistration(fips, owner);
    }

    function fipsChangeOwner(bytes20 fips, address old_owner, address new_owner) internal {
        ledger[fips] = new_owner;
        FipsTransfer(fips, old_owner, new_owner);
    }

    function fipsGenerate() internal returns (bytes20 fips) {
        fips = ripemd160(block.blockhash(block.number), sha256(msg.sender, block.number, block.timestamp, msg.gas));
        if (fipsIsRegistered(fips)) {
            return fipsGenerate();
        }
        return fips;
    }

    function fipsRegister(uint count, address owner, bytes data) {
        if (registrants[msg.sender] != true) {
            throw;
        }
        if ((count < 1) || (count > 1000)) {
            throw;
        }
        bytes20 fips;
        for (uint i = 1; i <= count; i++) {
            fips = fipsGenerate();
            fipsAddToLedger(fips, owner);
            if (data.length > 0) {
                FipsData(fips, owner, data);
            }
        }
    }

    function fipsRegister() { fipsRegister(1, msg.sender, """"); }
    function fipsRegister(uint count) { fipsRegister(count, msg.sender, """"); }
    function fipsRegister(uint count, bytes data) { fipsRegister(count, msg.sender, data); }
    function fipsRegister(address owner) { fipsRegister(1, owner, """"); }
    function fipsRegister(address owner, bytes data) { fipsRegister(1, owner, data); }

    function fipsTransfer(bytes20 fips, address new_owner) {
        if (msg.sender != ledger[fips]) {
            throw;
        }
        fipsChangeOwner(fips, msg.sender, new_owner);
    }

    function registrantApprove(address registrant) onlyAdmin {
        if (registrants[registrant] != true) {
            registrants[registrant] = true;
            RegistrantApproval(registrant);
        }
    }

    function registrantRemove(address registrant) onlyAdmin {
        if (registrants[registrant] == true) {
            delete(registrants[registrant]);
            RegistrantRemoval(registrant);
        }
    }

    function withdrawFunds() onlyAdmin {
        if (!admin.send(this.balance)) {
            throw;
        }
    }

}",S
0xb98fdd97f3da105e6b166461afac208981bc786b,Safe,"// Copyright (c) 2016 Chronicled, Inc. All rights reserved.
// http://explorer.chronicled.org
// http://demo.chronicled.org
// http://chronicled.org

contract Registrar {
    address public registrar;

    /**

    * Created event, gets triggered when a new registrant gets created
    * event
    * @param registrant - The registrant address.
    * @param registrar - The registrar address.
    * @param data - The data of the registrant.
    */
    event Created(address indexed registrant, address registrar, bytes data);

    /**
    * Updated event, gets triggered when a new registrant id Updated
    * event
    * @param registrant - The registrant address.
    * @param registrar - The registrar address.
    * @param data - The data of the registrant.
    */
    event Updated(address indexed registrant, address registrar, bytes data, bool active);

    /**
    * Error event.
    * event
    * @param code - The error code.
    * 1: Permission denied.
    * 2: Duplicate Registrant address.
    * 3: No such Registrant.
    */
    event Error(uint code);

    struct Registrant {
        address addr;
        bytes data;
        bool active;
    }

    mapping(address => uint) public registrantIndex;
    Registrant[] public registrants;

    /**
    * Function can't have ether.
    * modifier
    */
    modifier noEther() {
        if (msg.value > 0) throw;
        _
    }

    modifier isRegistrar() {
      if (msg.sender != registrar) {
        Error(1);
        return;
      }
      else {
        _
      }
    }

    /**
    * Construct registry with and starting registrants lenght of one, and registrar as msg.sender
    * constructor
    */
    function Registrar() {
        registrar = msg.sender;
        registrants.length++;
    }

    /**
    * Add a registrant, only registrar allowed
    * public_function
    * @param _registrant - The registrant address.
    * @param _data - The registrant data string.
    */
    function add(address _registrant, bytes _data) isRegistrar noEther returns (bool) {
        if (registrantIndex[_registrant] > 0) {
            Error(2); // Duplicate registrant
            return false;
        }
        uint pos = registrants.length++;
        registrants[pos] = Registrant(_registrant, _data, true);
        registrantIndex[_registrant] = pos;
        Created(_registrant, msg.sender, _data);
        return true;
    }

    /**
    * Edit a registrant, only registrar allowed
    * public_function
    * @param _registrant - The registrant address.
    * @param _data - The registrant data string.
    */
    function edit(address _registrant, bytes _data, bool _active) isRegistrar noEther returns (bool) {
        if (registrantIndex[_registrant] == 0) {
            Error(3); // No such registrant
            return false;
        }
        Registrant registrant = registrants[registrantIndex[_registrant]];
        registrant.data = _data;
        registrant.active = _active;
        Updated(_registrant, msg.sender, _data, _active);
        return true;
    }

    /**
    * Set new registrar address, only registrar allowed
    * public_function
    * @param _registrar - The new registrar address.
    */
    function setNextRegistrar(address _registrar) isRegistrar noEther returns (bool) {
        registrar = _registrar;
        return true;
    }

    /**
    * Get if a regsitrant is active or not.
    * constant_function
    * @param _registrant - The registrant address.
    */
    function isActiveRegistrant(address _registrant) constant returns (bool) {
        uint pos = registrantIndex[_registrant];
        return (pos > 0 && registrants[pos].active);
    }

    /**
    * Get all the registrants.
    * constant_function
    */
    function getRegistrants() constant returns (address[]) {
        address[] memory result = new address[](registrants.length-1);
        for (uint j = 1; j < registrants.length; j++) {
            result[j-1] = registrants[j].addr;
        }
        return result;
    }

    /**
    * Function to reject value sends to the contract.
    * fallback_function
    */
    function () noEther {}

    /**
    * Desctruct the smart contract. Since this is first, alpha release of Open Registry for IoT, updated versions will follow.
    * Registry's discontinue must be executed first.
    */
    function discontinue() isRegistrar noEther {
      selfdestruct(msg.sender);
    }
}",S
0x5bdf79f1e7431edb75537d23d3b404ef86f44316,Safe,"/**
 * The Edgeless token contract complies with the ERC20 standard (see https://github.com/ethereum/EIPs/issues/20).
 * Additionally tokens can be locked for a defined time interval by token holders.
 * The owner's share of tokens is locked for the first 360 days and all tokens not
 * being sold during the crowdsale but 60.000.000 (owner's share + bounty program) are burned.
 * Author: Julia Altenried
 * */

pragma solidity ^0.4.6;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract SafeMath {
  //internals

  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}

contract EdgelessToken is SafeMath {
    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Edgeless';
    string public symbol = 'EDG';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    uint256 public currentInterval = 1;
    uint256 public intervalLength = 30 days;
    address public owner;
    /* from this time on tokens may be transfered (after ICO)*/
    uint256 public startTime = 1490112000;
    /* tells if tokens have been burned already */
    bool burned;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* Defines how many tokens of which addresses are locked in which interval*/
    mapping(address => mapping(uint256=>uint256)) public locked;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Lock(address indexed owner, uint256 interval, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract,
    *  locks the owner's final share of tokens for the first 12 intervals. */
    function EdgelessToken() {
        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;
        balanceOf[owner] = 500000000;              // Give the owner all initial tokens
        totalSupply = 500000000;                   // Update total supply
        for(uint8 i = 1; i < 13; i++)		   // lock owner's final share of tokens for the first 12 months
        	locked[owner][i] = 50000000;
    }

    /* Send some of your tokens to a given address */
    function transfer(address _to, uint256 _value) returns (bool success){
        if (now < startTime) throw; //check if the crowdsale is already over
        if (locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);                     // Subtract from the sender
        balanceOf[_to] = safeAdd(balanceOf[_to],_value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        return true;
    }

    /* Allow another contract or person to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    /* A contract or  person attempts to get the tokens of somebody else.
    *  This is only allowed if the token holder approved. */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over
        if (locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough
        var _allowance = allowance[_from][msg.sender];
        balanceOf[_from] = safeSub(balanceOf[_from],_value); // Subtract from the sender
        balanceOf[_to] = safeAdd(balanceOf[_to],_value);     // Add the same to the recipient
        allowance[_from][msg.sender] = safeSub(_allowance,_value);
        Transfer(_from, _to, _value);
        return true;
    }

    /* Lock a number of tokens. This means, you will not be able to transfer these tokens until
    *  the start of the next interval. */
    function lock(address holder, uint256 _value) returns (bool success) {
        if(holder==msg.sender||holder==tx.origin){
			uint ci = getInterval();
			uint holderLock = locked[holder][ci];
            locked[holder][ci] = safeAdd(holderLock,_value);
            Lock(holder, ci, _value);
            return true;
        }
    }

    /* Increase the interval, if sufficient time has passed.
    *  When a new interval starts, all tokens are unlocked. */
    function getInterval() returns (uint256 interval){
        if (now > safeAdd(safeMul(currentInterval, intervalLength), startTime)) {
            currentInterval = (now - startTime) / intervalLength + 1;
        }
        return currentInterval;
    }

    /* to be called when ICO is closed, burns the remaining tokens but the owners share (50 000 000) and the ones reserved
    *  for the bounty program (10 000 000).
    *  anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).
    *  this ensures that the owner will not posses a majority of the tokens. */
    function burn(){
    	//if tokens have not been burned already and the ICO ended
    	if(!burned && now>startTime){
    		uint difference = safeSub(balanceOf[owner], 60000000);//checked for overflow above
    		balanceOf[owner] = 60000000;
    		totalSupply = safeSub(totalSupply, difference);
    		burned = true;
    	}
    }

}",S
0xba3e14a7f0169d86fc1389ad40ca4356a1404640,Safe,"contract MultiAsset {
    function owner(bytes32 _symbol) constant returns(address);
    function isCreated(bytes32 _symbol) constant returns(bool);
    function totalSupply(bytes32 _symbol) constant returns(uint);
    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);
    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);
    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);
    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);
    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);
    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);
    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);
    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);
}

contract OpenDollar {
    event Transfer(address indexed from, address indexed to, uint value);
    event Approve(address indexed from, address indexed spender, uint value);

    MultiAsset public multiAsset;
    bytes32 public symbol;

    function init(address _multiAsset, bytes32 _symbol) returns(bool) {
        MultiAsset ma = MultiAsset(_multiAsset);
        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {
            return false;
        }
        multiAsset = ma;
        symbol = _symbol;
        return true;
    }

    modifier onlyMultiAsset() {
        if (msg.sender == address(multiAsset)) {
            _
        }
    }

    function totalSupply() constant returns(uint) {
        return multiAsset.totalSupply(symbol);
    }

    function balanceOf(address _owner) constant returns(uint) {
        return multiAsset.balanceOf(_owner, symbol);
    }

    function allowance(address _from, address _spender) constant returns(uint) {
        return multiAsset.allowance(_from, _spender, symbol);
    }

    function transfer(address _to, uint _value) returns(bool) {
        return transferWithReference(_to, _value, """");
    }

    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {
        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {
            return false;
        }
        return true;
    }

    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {
        return transferToICAPWithReference(_icap, _value, """");
    }

    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {
        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {
            return false;
        }
        return true;
    }

    function transferFrom(address _from, address _to, uint _value) returns(bool) {
        return transferFromWithReference(_from, _to, _value, """");
    }

    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {
        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {
            return false;
        }
        return true;
    }

    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {
        return transferFromToICAPWithReference(_from, _icap, _value, """");
    }

    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {
        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {
            return false;
        }
        return true;
    }

    function approve(address _spender, uint _value) returns(bool) {
        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {
            return false;
        }
        return true;
    }

    function setCosignerAddress(address _cosigner) returns(bool) {
        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {
            return false;
        }
        return true;
    }

    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {
        Transfer(_from, _to, _value);
    }

    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {
        Approve(_from, _spender, _value);
    }

    function sendToOwner() returns(bool) {
        return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);
    }
}",S
0x90aa6fb2c2ab2c9e3fd5634c054d636c708cd5f3,Safe,"pragma solidity ^0.4.6;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract BuyerToken is owned {
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    uint256 public buyPrice;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Mint coins */
    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    /* Distroy coins */
    function distroyToken(address target) onlyOwner {
        totalSupply -= balanceOf[target];
        balanceOf[target] = 0;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    /* Approve and then comunicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function setPrices(uint256 newBuyPrice) onlyOwner {
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",54: arithmetic;
0xcab39d1c7383fc9682a1221bffacbce2bdd967ca,Safe,"pragma solidity ^0.4.4;

contract Destination {
    function recover(address _from, address _to) returns(bool);
}

contract RecoveryWithTenant {
    event Recovery(uint indexed nonce, address indexed from, address indexed to);
    event Setup(uint indexed nonce, address indexed user);

    //1: user not existing
    //2: conflict, user exists already
    //3: signature not by tenant
    //4: nonce/signature used before
    //5: contract call failed
    //6: oracle access denied
    //8: requested user not found
    event Error(uint indexed nonce, uint code);

    struct User {
        address addr;
    }

    mapping (address => uint) userIndex;
    User[] public users;

    address public oracle;
    address public tenant;
    mapping(uint => bool) nonceUsed;
    address public callDestination;


    modifier onlyOracle() {
        if (msg.sender == oracle) {
            _;
        }
        Error(0, 6);
    }

    modifier noEther() {
        if (msg.value > 0) throw;
        _;
    }

    function RecoveryWithTenant() {
        oracle = msg.sender;
        tenant = msg.sender;
        users.length++;
    }

    //############# INTERNAL FUNCTIONS

    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {
        address recovered = ecrecover(_hash, _v, _r, _s);

        if (tenant != recovered) {
            Error(_nonce, 3);
            return false;
        }
        if (nonceUsed[_nonce]) {
            Error(_nonce, 4);
            return false;
        }
        nonceUsed[_nonce] = true;
        return true;
    }


    //############# PUBLIC FUNCTIONS

    function setOracle(address _newOracle) noEther onlyOracle {
        oracle = _newOracle;
    }

    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))
            return false;
        tenant = _tenant;
        callDestination = _callDestination;
        return true;
    }


    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(userIndex[_userAddr] > 0) {
            Error(_nonce, 2);
            return false;
        }
        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        uint posUser = users.length++;
        userIndex[_userAddr] = posUser;
        users[posUser] = User(_userAddr);
        Setup(_nonce, _userAddr);
        return true;
    }

    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        uint userPos = userIndex[_oldAddr];
        if (userPos == 0) {
            Error(_nonce, 1); //user doesn't exsit
            return false;
        }

        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);
        if (result) {
            users[userPos].addr = _newAddr;
            delete userIndex[_oldAddr];
            userIndex[_newAddr] = userPos;
            Recovery(_nonce, _oldAddr, _newAddr);
            return true;
        }
        Error(_nonce, 5);
        return false;
    }

    function () noEther {
        throw;
    }

    //############# STATIC FUNCTIONS

    function isUser(address _userAddr) constant returns (bool) {
        return (userIndex[_userAddr] > 0);
    }

}",S
0x6b63ea3612dde97082aab468157950f927618d31,Safe,"contract Mapoc {
    address _owner;
    address _filiate;

    mapping (string => uint) private mapExecs;
    Execution[] private executions;
    event Executed(string Hash);
    event Validated(string Hash);

    struct Execution {
        uint dateCreated;
        string hash;
        bool validated;
        uint dateValidated;
    }


    /* CONSTRUCTOR */
    function Mapoc(/*address filiate*/) {
        _owner = msg.sender;
        _filiate = msg.sender;
    }

    function kill() ownerAllowed() {
        suicide(_owner);
    }

    /* MAPPING */
    function map(string hash) internal returns(uint) {
        uint ret = mapExecs[hash];
        if(ret >= executions.length || !strEqual(executions[ret].hash, hash)) throw;
        return ret;
    }

    /* MODIFIERS */
    modifier bothAllowed() {
        if(msg.sender != _owner && msg.sender != _filiate) throw;
        _;
    }

    modifier ownerAllowed() {
        if(msg.sender != _owner) throw;
        _;
    }

    modifier filiateAllowed() {
        if(msg.sender != _filiate) throw;
        _;
    }

    modifier notYetExist(string hash) {
        uint num = mapExecs[hash];
        if(num < executions.length && strEqual(executions[num].hash, hash)) throw;
        _;
    }

    modifier notYetValidated(string hash) {
        Execution e = executions[map(hash)];
        if(e.validated) throw;
        _;
    }

    modifier orderExist(string hash) {
        Execution e = executions[map(hash)];
        if(!strEqual(e.hash, hash)) throw;
        _;
    }

    /* FONCTIONS */
    function AddExec(string Hash) public ownerAllowed() notYetExist(Hash) {
        uint num = executions.length++;
        mapExecs[Hash] = num;
        Execution e = executions[num];
        e.dateCreated = now;
        e.hash = Hash;
        Executed(Hash);
    }

    function ValidateExec(string Hash) public filiateAllowed() notYetValidated(Hash) {
        Execution e = executions[map(Hash)];
        e.validated = true;
        e.dateValidated = now;
        Validated(Hash);
    }

    function CheckExecution(string Hash) public bothAllowed() constant returns(bool IsExist, uint DateCreated, bool Validated, uint DateValidated){
        uint ret = mapExecs[Hash];
        if(ret >= executions.length || !strEqual(executions[ret].hash, Hash)) return (false, 0, false, 0);
        Execution e = executions[ret];
        return (true, e.dateCreated, e.validated, e.dateValidated);
    }

    function IsValidated(string Hash) public bothAllowed() constant returns(bool) {
        Execution e = executions[map(Hash)];
        return e.validated;
    }

    function LastExecuted() public bothAllowed() constant returns(string Hash, uint DateCreated) {
        DateCreated = 0;
        if(executions.length > 0) {
            if(!executions[0].validated) {
                Hash = executions[0].hash;
                DateCreated = executions[0].dateCreated;
            }
            for(uint i = executions.length - 1; i > 0; i--) {
                if(!executions[i].validated && executions[i].dateCreated > DateCreated) {
                    Hash = executions[i].hash;
                    DateCreated = executions[i].dateCreated;
                    break;
                }
            }
        }
        return (Hash, DateCreated);
    }

    function LastValidated() public bothAllowed() constant returns(string Hash, uint DateValidated) {
        DateValidated = 0;
        for(uint i = 0; i < executions.length; i++) {
            if(executions[i].validated && executions[i].dateValidated > DateValidated) {
                Hash = executions[i].hash;
                DateValidated = executions[i].dateValidated;
            }
        }
        return (Hash, DateValidated);
    }

    function CountExecs() public bothAllowed() constant returns(uint Total, uint NotVal) {
        uint nbNotVal = 0;
        for(uint i = 0; i < executions.length; i++) {
            if(!executions[i].validated) nbNotVal++;
        }
        return (executions.length, nbNotVal);
    }

    function NotValSince(uint timestampFrom) public bothAllowed() constant returns(uint Count, string First, uint DateFirst, string Last, uint DateLast) {
        Count = 0;
        DateFirst = now;
        DateLast = 0;
        for(uint i = 0; i < executions.length; i++) {
            if(!executions[i].validated && executions[i].dateCreated >= timestampFrom) {
                Count++;
                if(executions[i].dateCreated < DateFirst) {
                    First = executions[i].hash;
                    DateFirst = executions[i].dateCreated;
                }
                else if(executions[i].dateCreated > DateLast) {
                    Last = executions[i].hash;
                    DateLast = executions[i].dateCreated;
                }
            }
        }
        return (Count, First, DateFirst, Last, DateLast);
    }

    function ListNotValSince(uint timestampFrom) public bothAllowed() constant returns(uint Count, string List, uint OldestTime) {
        Count = 0;
        List = ""\n"";
        OldestTime = now;
        for(uint i = 0; i < executions.length; i++) {
            if(!executions[i].validated && executions[i].dateCreated >= timestampFrom) {
                Count++;
                List = strConcat(List, executions[i].hash, "" ;\n"");
                if(executions[i].dateCreated < OldestTime)
                    OldestTime = executions[i].dateCreated;
            }
        }
        return (Count, List, OldestTime);
    }

    function ListAllSince(uint timestampFrom) public bothAllowed() constant returns(uint Count, string List) {
        List = ""\n"";
        for(uint i = 0; i < executions.length; i++) {
            string memory val;
            if(executions[i].validated)
                val = ""confirmed\n"";
            else
                val = ""published\n"";

            List = strConcat(List, executions[i].hash, "" : "", val);
        }
        return (executions.length, List);
    }

    /* UTILS */
    function strEqual(string _a, string _b) internal returns(bool) {
		bytes memory a = bytes(_a);
		bytes memory b = bytes(_b);
		if (a.length != b.length)
			return false;

		for (uint i = 0; i < a.length; i ++)
			if (a[i] != b[i])
				return false;
		return true;
	}

	function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns(string) {
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        bytes memory _bc = bytes(_c);
        bytes memory _bd = bytes(_d);
        bytes memory _be = bytes(_e);
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
        bytes memory babcde = bytes(abcde);
        uint k = 0;
        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
        return string(babcde);
    }

    function strConcat(string _a, string _b, string _c, string _d) internal returns(string) {
        return strConcat(_a, _b, _c, _d, """");
    }

    function strConcat(string _a, string _b, string _c) internal returns(string) {
        return strConcat(_a, _b, _c, """", """");
    }

    function strConcat(string _a, string _b) internal returns(string) {
        return strConcat(_a, _b, """", """", """");
    }

}",S
0xE01B770235Bc5db653604e5519F048dF54490B5f,Safe,"pragma solidity ^0.4.8;

// ----------------------------------------------------------------------------------------------
// The Waves Community token smart contract - to find out more, join the Incent Slack; http://incentinvites.herokuapp.com/
// A collaboration between Incent and Bok :)
// Enjoy. (c) Incent Loyalty Pty Ltd and Bok Consulting Pty Ltd 2017. The MIT Licence.
// ----------------------------------------------------------------------------------------------

// Contract configuration
contract TokenConfig {
    string public constant symbol = ""WCT"";
    string public constant name = ""Waves Community Token"";
    uint8 public constant decimals = 2;  // 2 decimal places, the same as tokens on Wave
    uint256 _totalSupply = 1000000000;
}

// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {
    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    // this function is required for some DEX functionality
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract WavesCommunityToken is ERC20Interface, TokenConfig {
    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function WavesCommunityToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
) returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}

contract WavesEthereumSwap is WavesCommunityToken {
    event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);

    function moveToWaves(string wavesAddress, uint256 amount) {
        if (!transfer(owner, amount)) throw;
        WavesTransfer(msg.sender, wavesAddress, amount);
    }
}",S
0xd23f2533B726C9Cb1Fb9ed109b82e5A8F01c881e,Safe,"pragma solidity ^0.4.8;

// ----------------------------------------------------------------------------------------------
// The Waves Community token smart contract - to find out more, join the Incent Slack; http://incentinvites.herokuapp.com/
// A collaboration between Incent and Bok :)
// Enjoy. (c) Incent Loyalty Pty Ltd and Bok Consulting Pty Ltd 2017. The MIT Licence.
// ----------------------------------------------------------------------------------------------

// Contract configuration
contract TokenConfig {
    string public constant symbol = ""WBTC"";
    string public constant name = ""Waves Bitcoin Token"";
    uint8 public constant decimals = 8;  // 8 decimal places, the same as tokens on Wave
    uint256 _totalSupply = 2100000000000000;
}

// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {
    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    // this function is required for some DEX functionality
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract WavesBitcoinToken is ERC20Interface, TokenConfig {
    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function WavesBitcoinToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
) returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}

contract WavesEthereumSwap is WavesBitcoinToken {
    event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);

    function moveToWaves(string wavesAddress, uint256 amount) {
        if (!transfer(owner, amount)) throw;
        WavesTransfer(msg.sender, wavesAddress, amount);
    }
}",S
0xf184279e6d4654890b4410cf300ed55600f018be,Safe,"pragma solidity ^0.4.6;

contract RES {

    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;

    uint public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Bought or sold */

    event Bought(address from, uint amount);
    event Sold(address from, uint amount);
    event BoughtViaJohan(address from, uint amount);

    /* Initializes contract with name, symbol and decimals */

    function RES() {
        name = ""RES"";
        symbol = ""RES"";
        decimals = 18;
    }

    function buy() public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;
      Bought(msg.sender, msg.value);
    }



}

contract SwarmRedistribution is RES {

    address JohanNygren;

    struct dividendPathway {
      address from;
      uint amount;
      uint timeStamp;
    }

    mapping(address => dividendPathway[]) public dividendPathways;

    mapping(address => uint256) public totalBasicIncome;

    uint taxRate;

    struct Node {
      address node;
      address parent;
      uint index;
    }

    /* Generate a swarm tree */
    Node[] public swarmTree;

    mapping(address => bool) inSwarmTree;

    bool JohanInSwarm;

    event Swarm(address indexed leaf, address indexed node, uint256 share);

    function SwarmRedistribution() {

    /* Tax-rate in parts per thousand */
    taxRate = 20;
    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;
    }

    modifier onlyJohan {
      if(msg.sender != JohanNygren) throw;
      _;
    }

    function changeJohanNygrensAddress(address _newAddress) onlyJohan {
      JohanNygren = _newAddress;
    }

    function buyViaJohan() public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;

      /* Create the dividend pathway */
      dividendPathways[msg.sender].push(dividendPathway({
                                      from: JohanNygren,
                                      amount:  msg.value,
                                      timeStamp: now
                                    }));

      BoughtViaJohan(msg.sender, msg.value);
    }

    function sell(uint256 _value) public {
      if(balanceOf[msg.sender] < _value) throw;
      balanceOf[msg.sender] -= _value;

      totalSupply -= _value;
      Sold(msg.sender, _value);

    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        /* reject transaction to self to prevent dividend pathway loops*/
        if(_to == msg.sender) throw;

        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;

        /* Calculate tax */
        uint256 taxCollected = _value * taxRate / 1000;
        uint256 sentAmount;

        /* Create the dividend pathway */
        dividendPathways[_to].push(dividendPathway({
                                        from: msg.sender,
                                        amount:  _value,
                                        timeStamp: now
                                      }));

        if(swarmRedistribution(_to, taxCollected) == true) {
          sentAmount = _value;
        }
        else {
          /* Return tax */
          sentAmount = _value - taxCollected;
        }

          /* Add and subtract new balances */

          balanceOf[msg.sender] -= sentAmount;
          balanceOf[_to] += _value - taxCollected;


        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, sentAmount);
    }

    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {
           iterateThroughSwarm(_to, now);
           if(swarmTree.length != 0) {
           return doSwarm(_to, _taxCollected);
           }
           else return false;
      }

    function iterateThroughSwarm(address _node, uint _timeStamp) internal {
      if(dividendPathways[_node].length != 0) {
        for(uint i = 0; i < dividendPathways[_node].length; i++) {
          if(inSwarmTree[dividendPathways[_node][i].from] == false) {

            uint timeStamp = dividendPathways[_node][i].timeStamp;
            if(timeStamp <= _timeStamp) {

              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;

                Node memory node = Node({
                            node: dividendPathways[_node][i].from,
                            parent: _node,
                            index: i
                          });

                  swarmTree.push(node);
                  iterateThroughSwarm(node.node, timeStamp);
              }
          }
        }
      }
    }

    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {

      uint256 share;
      if(JohanInSwarm) share = _taxCollected;
      else share = 0;

      for(uint i = 0; i < swarmTree.length; i++) {

        address node = swarmTree[i].node;
        address parent = swarmTree[i].parent;
        uint index = swarmTree[i].index;

        bool isJohan;
        if(node == JohanNygren) isJohan = true;

        if(isJohan) {
          balanceOf[swarmTree[i].node] += share;
        totalBasicIncome[node] += share;
        }

        if(dividendPathways[parent][index].amount - _taxCollected > 0) {
          dividendPathways[parent][index].amount -= _taxCollected;
        }
        else removeDividendPathway(parent, index);

        /* Notifiy anyone listening that this swarm took place */
        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);
      }
      delete swarmTree;
      bool JohanWasInSwarm = JohanInSwarm;
      delete JohanInSwarm;

      if(!JohanWasInSwarm) return false;
      return true;
    }

    function removeDividendPathway(address node, uint index) internal {
                delete dividendPathways[node][index];
                for (uint i = index; i < dividendPathways[node].length - 1; i++) {
                        dividendPathways[node][i] = dividendPathways[node][i + 1];
                }
                dividendPathways[node].length--;
        }

}",S
0x83d904a2489bae727c1037469206891d8d058d92,Safe,"contract Destination {
    function recover(address _from, address _to) returns(bool);
}

contract RecoveryWithTenant {
    event Recovery(uint indexed nonce, address indexed from, address indexed to);
    event Setup(uint indexed nonce, address indexed user);

    //1: user not existing
    //2: conflict, user exists already
    //3: signature not by tenant
    //4: nonce/signature used before
    //5: contract call failed
    //6: oracle access denied
    //8: requested user not found
    event Error(uint indexed nonce, uint code);

    struct User {
        address addr;
    }

    mapping (address => uint) userIndex;
    User[] public users;

    address public oracle;
    address public tenant;
    mapping(uint => bool) nonceUsed;
    address public callDestination;


    modifier onlyOracle() {
        if (msg.sender == oracle) {
            _
        }
        Error(0, 6);
    }

    modifier noEther() {
        if (msg.value > 0) throw;
        _
    }

    function RecoveryWithTenant() {
        oracle = msg.sender;
        tenant = msg.sender;
        users.length++;
    }

    //############# INTERNAL FUNCTIONS

    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {
        address recovered = ecrecover(_hash, _v, _r, _s);

        if (tenant != recovered) {
            Error(_nonce, 3);
            return false;
        }
        if (nonceUsed[_nonce]) {
            Error(_nonce, 4);
            return false;
        }
        nonceUsed[_nonce] = true;
        return true;
    }


    //############# PUBLIC FUNCTIONS

    function setOracle(address _newOracle) noEther onlyOracle {
        oracle = _newOracle;
    }

    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))
            return false;
        tenant = _tenant;
        callDestination = _callDestination;
        return true;
    }


    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(userIndex[_userAddr] > 0) {
            Error(_nonce, 2);
            return false;
        }
        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        uint posUser = users.length++;
        userIndex[_userAddr] = posUser;
        users[posUser] = User(_userAddr);
        Setup(_nonce, _userAddr);
        return true;
    }

    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        uint userPos = userIndex[_oldAddr];
        if (userPos == 0) {
            Error(_nonce, 1); //user doesn't exsit
            return false;
        }

        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);
        if (result) {
            users[userPos].addr = _newAddr;
            delete userIndex[_oldAddr];
            userIndex[_newAddr] = userPos;
            Recovery(_nonce, _oldAddr, _newAddr);
            return true;
        }
        Error(_nonce, 5);
        return false;
    }

    function () noEther {
        throw;
    }

    //############# STATIC FUNCTIONS

    function isUser(address _userAddr) constant returns (bool) {
        return (userIndex[_userAddr] > 0);
    }

}",S
0x3B6d241e1b38776C2eFE944E7012239ed59334c1,Safe,"pragma solidity ^0.4.8;

// ----------------------------------------------------------------------------------------------
// A collaboration between Incent and Bok :)
// Enjoy. (c) Incent Loyalty Pty Ltd, and Bok Consulting Pty Ltd 2017. The MIT Licence.
// ----------------------------------------------------------------------------------------------

//config contract
contract TokenConfig {

    string public constant name = ""Incent Coffee Token"";
    string public constant symbol = ""INCOF"";
    uint8 public constant decimals = 0;  // 0 decimal places, the same as tokens on Wave
    uint256 _totalSupply = 824;

}


// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {

    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract IncentCoffeeToken is ERC20Interface, TokenConfig {

    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function IncentCoffeeToken() {

        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) returns (bool success) {

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }


}

contract WavesEthereumSwap is IncentCoffeeToken {

 event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);

 function moveToWaves(string wavesAddress, uint256 amount) {

     if (!transfer(owner, amount)) throw;
     WavesTransfer(msg.sender, wavesAddress, amount);

 }

}",93: arithmetic;
0xade85d1796008281dbf4baaedb2790d3fea8d89d,Safe,"pragma solidity ^0.4.4;

contract Destination {
    function recover(address _from, address _to) returns(bool);
}

contract RecoveryWithTenant {
    event Recovery(uint indexed nonce, address indexed from, address indexed to);
    event Setup(uint indexed nonce, address indexed user);

    //1: user not existing
    //2: conflict, user exists already
    //3: signature not by tenant
    //4: nonce/signature used before
    //5: contract call failed
    //6: oracle access denied
    //8: requested user not found
    event Error(uint indexed nonce, uint code);

    struct User {
        address addr;
    }

    mapping (address => uint) userIndex;
    User[] public users;

    address public oracle;
    address public tenant;
    mapping(uint => bool) nonceUsed;
    address public callDestination;


    modifier onlyOracle() {
        if (msg.sender == oracle) {
            _;
        }
        Error(0, 6);
    }

    modifier noEther() {
        if (msg.value > 0) throw;
        _;
    }

    function RecoveryWithTenant() {
        oracle = msg.sender;
        tenant = msg.sender;
        users.length++;
    }

    //############# INTERNAL FUNCTIONS

    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {
        address recovered = ecrecover(_hash, _v, _r, _s);

        if (tenant != recovered) {
            Error(_nonce, 3);
            return false;
        }
        if (nonceUsed[_nonce]) {
            Error(_nonce, 4);
            return false;
        }
        nonceUsed[_nonce] = true;
        return true;
    }


    //############# PUBLIC FUNCTIONS

    function setOracle(address _newOracle) noEther onlyOracle {
        oracle = _newOracle;
    }

    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(tenant != oracle && !_checkSigned(sha3(tenant, _callDestination, _nonce), _nonce, _v, _r, _s))
            return false;
        tenant = _tenant;
        callDestination = _callDestination;
        return true;
    }


    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(userIndex[_userAddr] > 0) {
            Error(_nonce, 2);
            return false;
        }
        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        uint posUser = users.length++;
        userIndex[_userAddr] = posUser;
        users[posUser] = User(_userAddr);
        Setup(_nonce, _userAddr);
        return true;
    }

    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        uint userPos = userIndex[_oldAddr];
        if (userPos == 0) {
            Error(_nonce, 1); //user doesn't exsit
            return false;
        }

        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);
        if (result) {
            users[userPos].addr = _newAddr;
            delete userIndex[_oldAddr];
            userIndex[_newAddr] = userPos;
            Recovery(_nonce, _oldAddr, _newAddr);
            return true;
        }
        Error(_nonce, 5);
        return false;
    }

    function () noEther {
        throw;
    }

    //############# STATIC FUNCTIONS

    function isUser(address _userAddr) constant returns (bool) {
        return (userIndex[_userAddr] > 0);
    }

}",S
0xfa7b9770ca4cb04296cac84f37736d4041251cdf,Safe,"// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

// ReleaseOracle is an Ethereum contract to store the current and previous
// versions of the go-ethereum implementation. Its goal is to allow Geth to
// check for new releases automatically without the need to consult a central
// repository.
//
// The contract takes a vote based approach on both assigning authorised signers
// as well as signing off on new Geth releases.
//
// Note, when a signer is demoted, the currently pending release is auto-nuked.
// The reason is to prevent suprises where a demotion actually tilts the votes
// in favor of one voter party and pushing out a new release as a consequence of
// a simple demotion.
contract ReleaseOracle {
  // Votes is an internal data structure to count votes on a specific proposal
  struct Votes {
    address[] pass; // List of signers voting to pass a proposal
    address[] fail; // List of signers voting to fail a proposal
  }

  // Version is the version details of a particular Geth release
  struct Version {
    uint32  major;  // Major version component of the release
    uint32  minor;  // Minor version component of the release
    uint32  patch;  // Patch version component of the release
    bytes20 commit; // Git SHA1 commit hash of the release

    uint64  time;  // Timestamp of the release approval
    Votes   votes; // Votes that passed this release
  }

  // Oracle authorization details
  mapping(address => bool) authorised; // Set of accounts allowed to vote on updating the contract
  address[]                voters;     // List of addresses currently accepted as signers

  // Various proposals being voted on
  mapping(address => Votes) authProps; // Currently running user authorization proposals
  address[]                 authPend;  // List of addresses being voted on (map indexes)

  Version   verProp;  // Currently proposed release being voted on
  Version[] releases; // All the positively voted releases

  // isSigner is a modifier to authorize contract transactions.
  modifier isSigner() {
    if (authorised[msg.sender]) {
      _
    }
  }

  // Constructor to assign the initial set of signers.
  function ReleaseOracle(address[] signers) {
    // If no signers were specified, assign the creator as the sole signer
    if (signers.length == 0) {
      authorised[msg.sender] = true;
      voters.push(msg.sender);
      return;
    }
    // Otherwise assign the individual signers one by one
    for (uint i = 0; i < signers.length; i++) {
      authorised[signers[i]] = true;
      voters.push(signers[i]);
    }
  }

  // signers is an accessor method to retrieve all te signers (public accessor
  // generates an indexed one, not a retreive-all version).
  function signers() constant returns(address[]) {
    return voters;
  }

  // authProposals retrieves the list of addresses that authorization proposals
  // are currently being voted on.
  function authProposals() constant returns(address[]) {
    return authPend;
  }

  // authVotes retrieves the current authorization votes for a particular user
  // to promote him into the list of signers, or demote him from there.
  function authVotes(address user) constant returns(address[] promote, address[] demote) {
    return (authProps[user].pass, authProps[user].fail);
  }

  // currentVersion retrieves the semantic version, commit hash and release time
  // of the currently votec active release.
  function currentVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, uint time) {
    if (releases.length == 0) {
      return (0, 0, 0, 0, 0);
    }
    var release = releases[releases.length - 1];

    return (release.major, release.minor, release.patch, release.commit, release.time);
  }

  // proposedVersion retrieves the semantic version, commit hash and the current
  // votes for the next proposed release.
  function proposedVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, address[] pass, address[] fail) {
    return (verProp.major, verProp.minor, verProp.patch, verProp.commit, verProp.votes.pass, verProp.votes.fail);
  }

  // promote pitches in on a voting campaign to promote a new user to a signer
  // position.
  function promote(address user) {
    updateSigner(user, true);
  }

  // demote pitches in on a voting campaign to demote an authorised user from
  // its signer position.
  function demote(address user) {
    updateSigner(user, false);
  }

  // release votes for a particular version to be included as the next release.
  function release(uint32 major, uint32 minor, uint32 patch, bytes20 commit) {
    updateRelease(major, minor, patch, commit, true);
  }

  // nuke votes for the currently proposed version to not be included as the next
  // release. Nuking doesn't require a specific version number for simplicity.
  function nuke() {
    updateRelease(0, 0, 0, 0, false);
  }

  // updateSigner marks a vote for changing the status of an Ethereum user, either
  // for or against the user being an authorised signer.
  function updateSigner(address user, bool authorize) internal isSigner {
    // Gather the current votes and ensure we don't double vote
    Votes votes = authProps[user];
    for (uint i = 0; i < votes.pass.length; i++) {
      if (votes.pass[i] == msg.sender) {
        return;
      }
    }
    for (i = 0; i < votes.fail.length; i++) {
      if (votes.fail[i] == msg.sender) {
        return;
      }
    }
    // If no authorization proposal is open, add the user to the index for later lookups
    if (votes.pass.length == 0 && votes.fail.length == 0) {
      authPend.push(user);
    }
    // Cast the vote and return if the proposal cannot be resolved yet
    if (authorize) {
      votes.pass.push(msg.sender);
      if (votes.pass.length <= voters.length / 2) {
        return;
      }
    } else {
      votes.fail.push(msg.sender);
      if (votes.fail.length <= voters.length / 2) {
        return;
      }
    }
    // Proposal resolved in our favor, execute whatever we voted on
    if (authorize && !authorised[user]) {
      authorised[user] = true;
      voters.push(user);
    } else if (!authorize && authorised[user]) {
      authorised[user] = false;

      for (i = 0; i < voters.length; i++) {
        if (voters[i] == user) {
          voters[i] = voters[voters.length - 1];
          voters.length--;

          delete verProp; // Nuke any version proposal (no suprise releases!)
          break;
        }
      }
    }
    // Finally delete the resolved proposal, index and garbage collect
    delete authProps[user];

    for (i = 0; i < authPend.length; i++) {
      if (authPend[i] == user) {
        authPend[i] = authPend[authPend.length - 1];
        authPend.length--;
        break;
      }
    }
  }

  // updateRelease votes for a particular version to be included as the next release,
  // or for the currently proposed release to be nuked out.
  function updateRelease(uint32 major, uint32 minor, uint32 patch, bytes20 commit, bool release) internal isSigner {
    // Skip nuke votes if no proposal is pending
    if (!release && verProp.votes.pass.length == 0) {
      return;
    }
    // Mark a new release if no proposal is pending
    if (verProp.votes.pass.length == 0) {
      verProp.major  = major;
      verProp.minor  = minor;
      verProp.patch  = patch;
      verProp.commit = commit;
    }
    // Make sure positive votes match the current proposal
    if (release && (verProp.major != major || verProp.minor != minor || verProp.patch != patch || verProp.commit != commit)) {
      return;
    }
    // Gather the current votes and ensure we don't double vote
    Votes votes = verProp.votes;
    for (uint i = 0; i < votes.pass.length; i++) {
      if (votes.pass[i] == msg.sender) {
        return;
      }
    }
    for (i = 0; i < votes.fail.length; i++) {
      if (votes.fail[i] == msg.sender) {
        return;
      }
    }
    // Cast the vote and return if the proposal cannot be resolved yet
    if (release) {
      votes.pass.push(msg.sender);
      if (votes.pass.length <= voters.length / 2) {
        return;
      }
    } else {
      votes.fail.push(msg.sender);
      if (votes.fail.length <= voters.length / 2) {
        return;
      }
    }
    // Proposal resolved in our favor, execute whatever we voted on
    if (release) {
      verProp.time = uint64(now);
      releases.push(verProp);
      delete verProp;
    } else {
      delete verProp;
    }
  }
}",S
0x873c58020bcb114b4fea456cef93aaf58e8e305d,Safe,"pragma solidity ^0.4.8;

// ----------------------------------------------------------------------------------------------
// The Ripto Bux smart contract - to find out more, join the Incent Slack; http://incentinvites.herokuapp.com/
// A collaboration between Incent and Bok :)
// Enjoy. (c) Incent Loyalty Pty Ltd and Bok Consulting Pty Ltd 2017. The MIT Licence.
// ----------------------------------------------------------------------------------------------

// Contract configuration
contract TokenConfig {
    string public constant symbol = ""RBUX"";
    string public constant name = ""Ripto Bux"";
    uint8 public constant decimals = 8;  // 0 decimal places, the same as tokens on Wave
    uint256 _totalSupply = 100000000000000000;
}

// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {
    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    // this function is required for some DEX functionality
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract RiptoBuxToken is ERC20Interface, TokenConfig {
    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function RiptoBuxToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
) returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}

contract WavesEthereumSwap is RiptoBuxToken {
    event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);

    function moveToWaves(string wavesAddress, uint256 amount) {
        if (!transfer(owner, amount)) throw;
        WavesTransfer(msg.sender, wavesAddress, amount);
    }
}",S
0x3efd578b271d034a69499e4a2d933c631d44b9ad,Safe,"pragma solidity ^0.4.0;

/**
 * ERC-20 Token Interface
 *
 * https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 {

  /// @return total amount of tokens
  function totalSupply() constant returns (uint256 supply) {}

  /// @param _owner The address from which the balance will be retrieved
  /// @return The balance
  function balanceOf(address _owner) constant returns (uint256 balance) {}

  /// @notice send `_value` token to `_to` from `msg.sender`
  /// @param _to The address of the recipient
  /// @param _value The amount of token to be transferred
  /// @return Whether the transfer was successful or not
  function transfer(address _to, uint256 _value) returns (bool success) {}

  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
  /// @param _from The address of the sender
  /// @param _to The address of the recipient
  /// @param _value The amount of token to be transferred
  /// @return Whether the transfer was successful or not
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
  /// @param _spender The address of the account able to transfer the tokens
  /// @param _value The amount of wei to be approved for transfer
  /// @return Whether the approval was successful or not
  function approve(address _spender, uint256 _value) returns (bool success) {}

  /// @param _owner The address of the account owning tokens
  /// @param _spender The address of the account able to transfer the tokens
  /// @return Amount of remaining tokens allowed to spent
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}

/**
 * Standard ERC-20 token
 */
 contract StandardToken is ERC20 {

  uint256 public totalSupply;
  mapping(address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;


  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function transfer(address _to, uint256 _value) returns (bool success) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else {
      return false;
    }
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
}


contract TST is StandardToken {
    string public name = 'Test Standard Token';
    string public symbol = 'TST';
    uint public decimals = 18;

    function showMeTheMoney(address _to, uint256 _value) {
        totalSupply += _value;
        balances[_to] += _value;
        Transfer(0, _to, _value);
    }
}",S
0x74Aca0F1a40F7e0F3845DadF52C65060dE7749AF,Safe,"pragma solidity ^0.4.8;

// ----------------------------------------------------------------------------------------------
// The Ripto Bux smart contract - to find out more, join the Incent Slack; http://incentinvites.herokuapp.com/
// A collaboration between Incent and Bok :)
// Enjoy. (c) Incent Loyalty Pty Ltd and Bok Consulting Pty Ltd 2017. The MIT Licence.
// ----------------------------------------------------------------------------------------------

// Contract configuration
contract TokenConfig {
    string public constant symbol = ""RBX"";
    string public constant name = ""Ripto Bux"";
    uint8 public constant decimals = 8;  // 8 decimal places, the same as tokens on Wave
    uint256 _totalSupply = 100000000000000000;
}

// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {
    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    // this function is required for some DEX functionality
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract RiptoBuxToken is ERC20Interface, TokenConfig {
    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function RiptoBuxToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
) returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}

contract WavesEthereumSwap is RiptoBuxToken {
    event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);

    function moveToWaves(string wavesAddress, uint256 amount) {
        if (!transfer(owner, amount)) throw;
        WavesTransfer(msg.sender, wavesAddress, amount);
    }
}",S
0x2c875e5ea4706b1978a41b59edf2d3af31d60e70,Safe,"pragma solidity ^0.4.2;

// ----------------------------------------------------------------------------------------------
// Basic ERC20 Token Contract For **TESTING ONLY** on Testnet or Dev blockchain.
//
// Enjoy. (c) Bok Consulting Pty Ltd 2016. The MIT Licence.
// ----------------------------------------------------------------------------------------------

// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {

    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract IncentCoffeeToken is ERC20Interface {

    /* copied from Bok's github - https://github.com/bokkypoobah/TokenTrader/wiki/GNT-%E2%80%90-Golem-Network-Token */
    string public constant name = ""Incent Coffee Token"";
    string public constant symbol = ""INCOF"";
    uint8 public constant decimals = 0;  // 0 decimal places, the same as tokens on Wave

    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Total supply
    uint256 _totalSupply;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function IncentCoffeeToken() {

        _totalSupply = 824;
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) returns (bool success) {

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }


}

contract WavesEthereumSwap is IncentCoffeeToken {

 event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);

 function moveToWaves(string wavesAddress, uint256 amount) {

     if (!transfer(owner, amount)) throw;
     WavesTransfer(msg.sender, wavesAddress, amount);

 }

}",S
0x08711d3b02c8758f2fb3ab4e80228418a7f8e39c,Safe,"/**
 * The Edgeless token contract complies with the ERC20 standard (see https://github.com/ethereum/EIPs/issues/20).
 * Additionally tokens can be locked for a defined time interval by token holders.
 * The owner's share of tokens is locked for the first year and all tokens not
 * being sold during the crowdsale but 60.000.000 (owner's share + bounty program) are burned.
 * Author: Julia Altenried
 * */

pragma solidity ^0.4.6;

contract SafeMath {
  //internals

  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}

contract EdgelessToken is SafeMath {
    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Edgeless';
    string public symbol = 'EDG';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    address public owner;
    /* from this time on tokens may be transfered (after ICO)*/
    uint256 public startTime = 1490112000;
    /* tells if tokens have been burned already */
    bool burned;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;


    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
	event Burned(uint amount);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function EdgelessToken() {
        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;
        balanceOf[owner] = 500000000;              // Give the owner all initial tokens
        totalSupply = 500000000;                   // Update total supply
    }

    /* Send some of your tokens to a given address */
    function transfer(address _to, uint256 _value) returns (bool success){
        if (now < startTime) throw; //check if the crowdsale is already over
        if(msg.sender == owner && now < startTime + 1 years && safeSub(balanceOf[msg.sender],_value) < 50000000) throw; //prevent the owner of spending his share of tokens within the first year
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);                     // Subtract from the sender
        balanceOf[_to] = safeAdd(balanceOf[_to],_value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        return true;
    }

    /* Allow another contract or person to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    /* A contract or  person attempts to get the tokens of somebody else.
    *  This is only allowed if the token holder approved. */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over
        if(_from == owner && now < startTime + 1 years && safeSub(balanceOf[_from],_value) < 50000000) throw; //prevent the owner of spending his share of tokens within the first year
        var _allowance = allowance[_from][msg.sender];
        balanceOf[_from] = safeSub(balanceOf[_from],_value); // Subtract from the sender
        balanceOf[_to] = safeAdd(balanceOf[_to],_value);     // Add the same to the recipient
        allowance[_from][msg.sender] = safeSub(_allowance,_value);
        Transfer(_from, _to, _value);
        return true;
    }


    /* to be called when ICO is closed, burns the remaining tokens but the owners share (50 000 000) and the ones reserved
    *  for the bounty program (10 000 000).
    *  anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).
    *  this ensures that the owner will not posses a majority of the tokens. */
    function burn(){
    	//if tokens have not been burned already and the ICO ended
    	if(!burned && now>startTime){
    		uint difference = safeSub(balanceOf[owner], 60000000);//checked for overflow above
    		balanceOf[owner] = 60000000;
    		totalSupply = safeSub(totalSupply, difference);
    		burned = true;
    		Burned(difference);
    	}
    }

}",S
0xdb6d68e1d8c3f69d32e2d83065492e502b4c67ba,Safe,"contract Devcon2Interface {
    function isTokenOwner(address _owner) constant returns (bool);
    function ownedToken(address _owner) constant returns (bytes32 tokenId);
}


contract Survey {
    Devcon2Interface public devcon2Token;

    // Mapping from tokenId to boolean noting whether this token has responded.
    mapping (bytes32 => bool) public hasResponded;

    // The timestamp when this survey will end.
    uint public surveyEndAt;

    // The question we wish to ask the token holders.
    string public question;

    // An array of answer options.
    bytes32[] public responseOptions;

    // Helper for accessing the number of options programatically.
    uint public numResponseOptions;

    // Histogram of the responses as a mapping from option index to number of
    // responses for that option.
    mapping (uint => uint) public responseCounts;

    // Total number of responses.
    uint public numResponses;

    // Event for logging response submissions.
    event Response(bytes32 indexed tokenId, uint responseId);

    /// @dev Sets up the survey contract
    /// @param tokenAddress Address of Devcon2 Identity Token contract.
    /// @param duration Integer duration the survey should remain open and accept answers.
    /// @param _question String the survey question.
    /// @param _responseOptions Array of Bytes32 allowed survey response options.
    function Survey(address tokenAddress, uint duration, string _question, bytes32[] _responseOptions) {
        devcon2Token = Devcon2Interface(tokenAddress);
        question = _question;
        numResponseOptions = _responseOptions.length;
        for (uint i=0; i < numResponseOptions; i++) {
            responseOptions.push(_responseOptions[i]);
        }
        surveyEndAt = now + duration;
    }

    /// @dev Respond to the survey
    /// @param responseId Integer index of the response option being submitted.
    function respond(uint responseId) returns (bool) {
        // Check our survey hasn't ended.
        if (now >= surveyEndAt) return false;

        // Only allow token holders
        if (!devcon2Token.isTokenOwner(msg.sender)) return false;

        // Each token has a unique bytes32 identifier.  Since tokens are
        // transferable, we want to use this value instead of the owner address
        // for preventing the same owner from responding multiple times.
        var tokenId = devcon2Token.ownedToken(msg.sender);

        // Sanity check.  The 0x0 token is invalid which means something went
        // wrong.
        if (tokenId == 0x0) throw;

        // verify that this token has not yet responded.
        if (hasResponded[tokenId]) return false;

        // verify the response is valid
        if (responseId >= responseOptions.length) return false;

        responseCounts[responseId] += 1;

        // log the response.
        Response(tokenId, responseId);

        // Mark this token as having responded to the question.
        hasResponded[tokenId] = true;

        // increment the response counter
        numResponses += 1;
    }
}


contract MainnetSurvey is Survey {
    function MainnetSurvey(uint duration, string _question, bytes32[] _responseOptions) Survey(0xabf65a51c7adc3bdef0adf8992884be38072c184, duration, _question, _responseOptions) {
    }
}


contract ETCSurvey is MainnetSurvey {
    function ETCSurvey() MainnetSurvey(
            2 weeks,
            ""Do plan to pursue any development or involvement on the Ethereum Classic blockchain"",
            _options
        )
    {
        bytes32[] memory _options = new bytes32[](4);
        _options[0] = ""No Answer"";
        _options[1] = ""Yes"";
        _options[2] = ""No"";
        _options[3] = ""Undecided"";
    }
}",S
0x84d50ebf4737331fb41ff9e3c6c324262c5b661c,Safe,"pragma solidity ^0.4.1;

contract Destination {
    function recover(address _from, address _to) returns(bool);
}

contract RecoveryWithTenant {
    event Recovery(uint indexed nonce, address indexed from, address indexed to);
    event Setup(uint indexed nonce, address indexed user);

    //1: user not existing
    //2: conflict, user exists already
    //3: signature not by tenant
    //4: nonce/signature used before
    //5: contract call failed
    //6: oracle access denied
    //8: requested user not found
    event Error(uint indexed nonce, uint code);

    struct User {
        address addr;
    }

    mapping (address => uint) userIndex;
    User[] public users;

    address public oracle;
    address public tenant;
    mapping(uint => bool) nonceUsed;
    address public callDestination;


    modifier onlyOracle() {
        if (msg.sender == oracle) {
            _;
        }
        Error(0, 6);
    }

    modifier noEther() {
        if (msg.value > 0) throw;
        _;
    }

    function RecoveryWithTenant() {
        oracle = msg.sender;
        tenant = msg.sender;
        users.length++;
    }

    //############# INTERNAL FUNCTIONS

    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {
        address recovered = ecrecover(_hash, _v, _r, _s);

        if (tenant != recovered) {
            Error(_nonce, 3);
            return false;
        }
        if (nonceUsed[_nonce]) {
            Error(_nonce, 4);
            return false;
        }
        nonceUsed[_nonce] = true;
        return true;
    }


    //############# PUBLIC FUNCTIONS

    function setOracle(address _newOracle) noEther onlyOracle {
        oracle = _newOracle;
    }

    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))
            return false;
        tenant = _tenant;
        callDestination = _callDestination;
        return true;
    }


    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(userIndex[_userAddr] > 0) {
            Error(_nonce, 2);
            return false;
        }
        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        uint posUser = users.length++;
        userIndex[_userAddr] = posUser;
        users[posUser] = User(_userAddr);
        Setup(_nonce, _userAddr);
        return true;
    }

    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        uint userPos = userIndex[_oldAddr];
        if (userPos == 0) {
            Error(_nonce, 1); //user doesn't exsit
            return false;
        }

        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);
        if (result) {
            users[userPos].addr = _newAddr;
            delete userIndex[_oldAddr];
            userIndex[_newAddr] = userPos;
            Recovery(_nonce, _oldAddr, _newAddr);
            return true;
        }
        Error(_nonce, 5);
        return false;
    }

    function () noEther {
        throw;
    }

    //############# STATIC FUNCTIONS

    function isUser(address _userAddr) constant returns (bool) {
        return (userIndex[_userAddr] > 0);
    }

}",S
0x4bd4afa9b213b5184c995aaef4982ce564121d20,Safe,"contract Destination {
    function recover(address _from, address _to) returns(bool);
}

contract RecoveryWithTenant {
    event Recovery(uint indexed nonce, address indexed from, address indexed to);
    event Setup(uint indexed nonce, address indexed user);

    //1: user not existing
    //2: conflict, user exists already
    //3: signature not by tenant
    //4: nonce/signature used before
    //5: contract call failed
    //6: oracle access denied
    //8: requested user not found
    event Error(uint indexed nonce, uint code);

    struct User {
        address addr;
    }

    mapping (address => uint) userIndex;
    User[] public users;

    address public oracle;
    address public tenant;
    mapping(uint => bool) nonceUsed;
    address public callDestination;


    modifier onlyOracle() {
        if (msg.sender == oracle) {
            _
        }
        Error(0, 6);
    }

    modifier noEther() {
        if (msg.value > 0) throw;
        _
    }

    function RecoveryWithTenant() {
        oracle = msg.sender;
        tenant = msg.sender;
        users.length++;
    }

    //############# INTERNAL FUNCTIONS

    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {
        address recovered = ecrecover(_hash, _v, _r, _s);

        if (tenant != recovered) {
            Error(_nonce, 3);
            return false;
        }
        if (nonceUsed[_nonce]) {
            Error(_nonce, 4);
            return false;
        }
        nonceUsed[_nonce] = true;
        return true;
    }


    //############# PUBLIC FUNCTIONS

    function setOracle(address _newOracle) noEther onlyOracle {
        oracle = _newOracle;
    }

    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))
            return false;
        tenant = _tenant;
        callDestination = _callDestination;
        return true;
    }


    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        if(userIndex[_userAddr] > 0) {
            Error(_nonce, 2);
            return false;
        }
        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        uint posUser = users.length++;
        userIndex[_userAddr] = posUser;
        users[posUser] = User(_userAddr);
        Setup(_nonce, _userAddr);
        return true;
    }

    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {
        uint userPos = userIndex[_oldAddr];
        if (userPos == 0) {
            Error(_nonce, 1); //user doesn't exsit
            return false;
        }

        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))
            return false;
        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);
        if (result) {
            users[userPos].addr = _newAddr;
            Recovery(_nonce, _oldAddr, _newAddr);
            return true;
        }
        Error(_nonce, 5);
        return false;
    }

    function () noEther {
        throw;
    }

    //############# STATIC FUNCTIONS

    function isUser(address _userAddr) constant returns (bool) {
        return (userIndex[_userAddr] > 0);
    }

}",S
0x23141df767233776f7cbbec497800ddedaa4c684,Safe,"// Simple smart contract that allows anyone to send ether from one address to
// another in certain branch of the blockchain only.  This contract is supposed
// to be used after hard forks to clearly separate ""classic"" ether from ""new""
// ether.
contract BranchSender {
  // Is set to true if and only if we are currently in the ""right"" branch of
  // the blockchain, i.e. the branch this contract allows sending money in.
  bool public isRightBranch;

  // Instantiate the contract.
  //
  // @param blockNumber number of block in the ""right"" blockchain whose hash is
  //        known
  // @param blockHash known hash of the given block in the ""right"" blockchain
  function BranchSender(uint blockNumber, bytes32 blockHash) {
    if (msg.value > 0) throw; // We do not accept any money here

    isRightBranch = (block.number < 256 || blockNumber > block.number - 256) &&
                    (blockNumber < block.number) &&
                    (block.blockhash (blockNumber) == blockHash);
  }

  // Default function just throw.
  function () {
    throw;
  }

  // If we are currently in the ""right"" branch of the blockchain, send money to
  // the given recipient.  Otherwise, throw.
  //
  // @param recipient address to send money to if we are currently in the
  //                  ""right"" branch of the blockchain
  function send (address recipient) {
    if (!isRightBranch) throw;
    if (!recipient.send (msg.value)) throw;
  }
}",S
0xd43cbd8a74535327a8a196ea36cd44fc799ca289,Safe,"contract SimpleLotto {
    int playCount = 0;
    address owner = msg.sender;
    mapping (address => uint) public players;

    modifier onlyBy(address _account) {
        if (msg.sender != _account)
            throw;
        _
    }

    event Sent(address from, address to, int amount);

    function play(address receiver, uint amount) external constant returns (int playCount){
        playCount++;
      Sent(owner, receiver, playCount);
      players[receiver] += amount;
      return playCount;
    }

    function play1(address receiver, uint amount) external  returns (int playCount){
        playCount++;
      Sent(owner, receiver, playCount);
      players[receiver] += amount;
      return playCount;
    }

    function play2(address receiver, uint amount) public returns (int playCount){
        playCount++;
        Sent(owner, receiver, playCount);
        players[receiver] += amount;
        return playCount;
    }

        function play4(address receiver, uint amount) returns (int playCount){
        playCount++;
        Sent(owner, receiver, playCount);
        players[receiver] += amount;
        return playCount;
    }

    function terminate() {
        if (msg.sender == owner)
            suicide(owner);
    }

    function terminateAlt() onlyBy(owner) {
            suicide(owner);
    }
}",S
0x1c3c643f49be262c3040e917e7d2299b9bc081a1,Safe,"pragma solidity ^0.4.6;

/**
 *
 * EventInfo - imutable class that denotes
 * the time of the virtual accelerator hack
 * event
 *
 */
contract EventInfo{


    uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5;
    uint constant T_1_WEEK = 60 * 60 * 24 * 7;

    uint eventStart = 1479391200; // Thu, 17 Nov 2016 14:00:00 GMT
    uint eventEnd = eventStart + HACKATHON_5_WEEKS;


    /**
     * getEventStart - return the start of the event time
     */
    function getEventStart() constant returns (uint result){
       return eventStart;
    }

    /**
     * getEventEnd - return the end of the event time
     */
    function getEventEnd() constant returns (uint result){
       return eventEnd;
    }


    /**
     * getVotingStart - the voting starts 1 week after the
     *                  event starts
     */
    function getVotingStart() constant returns (uint result){
        return eventStart+ T_1_WEEK;
    }

    /**
     * getTradingStart - the DST tokens trading starts 1 week
     *                   after the event starts
     */
    function getTradingStart() constant returns (uint result){
        return eventStart+ T_1_WEEK;
    }

    /**
     * getNow - helper class to check what time the contract see
     */
    function getNow() constant returns (uint result){
       return now;
    }

}",S
0x3e72548c1535beadcdf084ec13fd7850c49050ed,Safe,"contract testExpensiveFallback {
    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;
    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;
    address constant veox = 0x1488e30b386903964b2797c97c9a3a678cf28eca;

    // public, so accessors available
    bool public ran;
    bool public forked;
    bool public notforked;

    modifier before_dao_hf_block {
        if (block.number >= 1920000) throw;
        _
    }

    modifier run_once {
        if (ran) throw;
        _
    }

    modifier has_millions(address _addr, uint _millions) {
        if (_addr.balance >= (_millions * 1000000 ether)) _
    }

    // 10M ether is ~ 2M less than would be available for a short
    // while in WithdrawDAO after the HF, but probably more than
    // anyone is willing to drop into WithdrawDAO in Classic
    function check_withdrawdao() internal
        has_millions(WithdrawDAO, 10) {
        forked = true;
    }

    // failsafe: if the above assumption is incorrect, HF tine
    // won't have balance in DarkDAO anyway, and Classic has a
    // sliver of time before DarkDAO split happens
    function check_darkdao() internal
        has_millions(DarkDAO, 3) {
        notforked = true;
    }

    function kill1() { suicide(veox); }
    function kill2() { selfdestruct(veox); }

    // running is possible only once
    // after that the dapp can only throw
    function ()
        before_dao_hf_block run_once {
        ran = true;

        check_withdrawdao();
        check_darkdao();

        // if both flags are same, then something went wrong
        if (forked == notforked) throw;
    }
}",S
0x124446eff5787b036aa062a2ef5321ce607437ba,Safe,"pragma solidity ^0.4.8;

contract mortal {
	address owner;

	function mortal() {
		owner = msg.sender;
	}

	function kill()  {
	    if(msg.sender==owner)
		    suicide(owner);
	}
}

contract Aquarium{
  function receive(address receiver, uint8 animalType, uint32[] ids) payable {}
}


contract Intermediary is mortal{
  Aquarium aquarium;
  uint[] values;

  function Intermediary(){

    values =  [95000000000000000, 190000000000000000, 475000000000000000, 950000000000000000, 4750000000000000000];
  }
  function transfer(uint8[] animalTypes, uint8[] numsXType, uint32[] ids) payable{
    uint needed;
     for(uint8 i = 0; i < animalTypes.length; i++){
      needed+=values[animalTypes[i]]*numsXType[i];
    }
    if (msg.value<needed) throw;

    uint8 from;
    for(i = 0; i < animalTypes.length; i++){
      aquarium.receive.value(values[animalTypes[i]]*numsXType[i])(msg.sender,animalTypes[i],slice(ids,from,numsXType[i]));
      from+=numsXType[i];
    }
  }

  function setAquarium(address aqua){
      if(msg.sender==owner)
        aquarium = Aquarium(aqua);
  }

  function slice(uint32[] array, uint8 from, uint8 number) returns (uint32[] sliced){
    sliced = new uint32[](number);
    for(uint8 i = from; i < from+number; i++){
      sliced[i-from] = array[i];
    }
  }
}",S
0x5Bc7e5694ee5D6ea32A0dA36EFb56A177190A53a,Safe,"contract WavesPresale {
    address public owner;

    struct Sale
    {
        uint amount;
        uint date;
    }

    mapping (bytes16 => Sale) public sales;
    uint32 public numberOfSales;
    uint public totalTokens;

    function WavesPresale() {
        owner = msg.sender;
        numberOfSales = 0;
    }

    function changeOwner(address newOwner) {
        if (msg.sender != owner) return;

        owner = newOwner;
    }

    function newSale(bytes16 txidHash, uint amount, uint timestamp) {
        if (msg.sender != owner) return;

        if (sales[txidHash].date == 0) {
            sales[txidHash] = Sale({
                    amount: amount,
                    date: timestamp
                });
            numberOfSales += 1;
            totalTokens += amount;
        } else {
            throw;
        }
    }

    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {
    	return (sales[txidHash].amount, sales[txidHash].date);
    }

    function () {
        // This function gets executed if a
        // transaction with invalid data is sent to
        // the contract or just ether without data.
        // We revert the send so that no-one
        // accidentally loses money when using the
        // contract.
        throw;
    }

}",34: arithmetic;
0xe8e506306ddb78ee38c9b0d86c257bd97c2536b3,Safe,"contract TheDAOHardForkOracle {
    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;
    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;

    // public, so accessors available
    bool public ran;
    bool public forked;
    bool public notforked;

    modifier after_dao_hf_block {
        if (block.number < 1920000) throw;
        _
    }

    modifier run_once {
        if (ran) throw;
        _
    }

    modifier has_millions(address _addr, uint _millions) {
        if (_addr.balance >= (_millions * 1000000 ether)) _
    }

    // 10M ether is ~ 2M less than would be available for a short
    // while in WithdrawDAO after the HF, but probably more than
    // anyone is willing to drop into WithdrawDAO in Classic
    function check_withdrawdao() internal
        has_millions(WithdrawDAO, 10) {
        forked = true;
    }

    // failsafe: if the above assumption is incorrect, HF tine
    // won't have balance in DarkDAO anyway, and Classic has a
    // sliver of time before DarkDAO split happens
    function check_darkdao() internal
        has_millions(DarkDAO, 3) {
        notforked = true;
    }

    // running is possible only once
    // after that the dapp can only throw
    function ()
        after_dao_hf_block run_once {
        ran = true;

        check_withdrawdao();
        check_darkdao();

        // if both flags are same, then something went wrong
        if (forked == notforked) throw;
    }
}",S
0xcd820a2f792f429bf95e6d0de909d06110b44123,Safe,"contract RequiringFunds {
   modifier NeedEth () {
       if (msg.value <= 0 ) throw;
       _
   }
}

contract AmIOnTheFork {
   function forked() constant returns(bool);
}

contract ReplaySafeSplit is RequiringFunds {
   // address private constant oracleAddress = 0x8128B12cABc6043d94BD3C4d9B9455077Eb18807;    // testnet
   address private constant oracleAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;   // mainnet

   // Fork oracle to use
   AmIOnTheFork amIOnTheFork = AmIOnTheFork(oracleAddress);

   // Splits the funds into 2 addresses
   function split(address targetFork, address targetNoFork) NeedEth returns(bool) {
       // The 2 checks are to ensure that users provide BOTH addresses
       // and prevent funds to be sent to 0x0 on one fork or the other.
       if (targetFork == 0) throw;
       if (targetNoFork == 0) throw;

       if (amIOnTheFork.forked()                   // if we are on the fork
           && targetFork.send(msg.value)) {        // send the ETH to the targetFork address
           return true;
       } else if (!amIOnTheFork.forked()           // if we are NOT on the fork
           && targetNoFork.send(msg.value)) {      // send the ETH to the targetNoFork address
           return true;
       }

       throw;                                      // don't accept value transfer, otherwise it would be trapped.
   }

   // Reject value transfers.
   function() {
       throw;
   }
}",S
0x8d7b6fb1523f04e644085e14d5e49b1c6278c92e,Safe,"contract Token {
    event Transfer(address indexed from, address indexed to, uint256 value);
    function transfer(address _to, uint256 _value);
    function balanceOf(address) returns (uint256);
}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract TokenSale is owned {

	address public asset;
	uint256 public price;

	function TokenSale()
	{
	      asset =  0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A; // DGX
	      price = 750000000; // 0.75 ETH
	}


	function transfer_token(address _token, address _to, uint256 _value)
	onlyOwner()
	{
		Token(_token).transfer(_to,_value);
	}

	function transfer_eth(address _to, uint256 _value)
	onlyOwner()
	{
		if(this.balance >= _value) {
                    _to.send(_value);
                }
	}

   	function () {

		uint order   = msg.value / price;

		if(order == 0) throw;

		uint256 balance = Token(asset).balanceOf(address(this));

		if(balance == 0) throw;

		if(order > balance )
		{
		    order = balance;
		    uint256 change = msg.value - order * price;
		    msg.sender.send(change);
		}

		Token(asset).transfer(msg.sender,order);
    	}
}",S
0xaBbb6bEbFA05aA13e908EaA492Bd7a8343760477,Safe,"contract RequiringFunds {
    modifier NeedEth () {
        if (msg.value <= 0 ) throw;
        _
    }
}

contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract ReplaySafeSplit is RequiringFunds {
    //address private constant oracleAddress = 0x8128B12cABc6043d94BD3C4d9B9455077Eb18807;    // testnet
    address private constant oracleAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;   // mainnet

    // Fork oracle to use
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(oracleAddress);

    // Splits the funds into 2 addresses
    function split(address targetFork, address targetNoFork) NeedEth returns(bool) {
        // The 2 checks are to ensure that users provide BOTH addresses
        // and prevent funds to be sent to 0x0 on one fork or the other.
        if (targetFork == 0) throw;
        if (targetNoFork == 0) throw;

        if (amIOnTheFork.forked()                   // if we are on the fork
            && targetFork.send(msg.value)) {        // send the ETH to the targetFork address
            return true;
        } else if (!amIOnTheFork.forked()           // if we are NOT on the fork
            && targetNoFork.send(msg.value)) {      // send the ETH to the targetNoFork address
            return true;
        }

        throw;                                      // don't accept value transfer, otherwise it would be trapped.
    }

    // Reject value transfers.
    function() {
        throw;
    }
}",S
0x39aa4006ee5941c0c0e41b924fdafcb2c4c918e8,Safe,"contract Soleau {

  uint price = 0.001 ether;
  struct Record {
    address holder;
    bool exists;
    uint createdAt; /* Time */
    uint createdIn; /* Block number */
  }
  mapping (string => Record) _records;

  function record(string hash) returns (bool success, bool already, uint theBlock) {
    if (msg.value < price) {
      success = false;
      msg.sender.send(msg.value); /* We're nice, we refund */
      return;
    } /* Else we keep the money but there is currently no way to use
	 it: it is locked in the contract for ever */
    if (_records[hash].exists) {
      success = true;
      already = true;
      theBlock = _records[hash].createdIn;
    } else {
      _records[hash].exists = true;
      _records[hash].holder = msg.sender;
      _records[hash].createdAt = now;
      _records[hash].createdIn = block.number;
      success = true;
      already = false;
      theBlock = _records[hash].createdIn;
    }
  }

  function get(string hash) constant returns (bool success, uint theBlock, uint theTime, address holder) {
    if (_records[hash].exists) {
      success = true;
      theBlock = _records[hash].createdIn;
      theTime = _records[hash].createdAt;
      holder = _records[hash].holder;
    } else {
      success = false;
    }
  }

  /* No fallback function */
  function () {
    throw;
  }

}",15: unchecked;
0xBDf12A64B482D292f6a45eb8db1809ABCD1bB8d1,Safe,"pragma solidity ^0.4.8;

/// @title Oracle contract where m of n predetermined voters determine a value
contract FederatedOracleBytes8 {
    struct Voter {
        bool isVoter;
        bool hasVoted;
    }

    event VoterAdded(address account);
    event VoteSubmitted(address account, bytes8 value);
    event ValueFinalized(bytes8 value);

    mapping(address => Voter) public voters;
    mapping(bytes8 => uint8) public votes;

    uint8 public m;
    uint8 public n;
    bytes8 public finalValue;

    uint8 private voterCount;
    address private creator;

    function FederatedOracleBytes8(uint8 m_, uint8 n_) {
        creator = msg.sender;
        m = m_;
        n = n_;
    }

    function addVoter(address account) {
        if (msg.sender != creator) {
            throw;
        }
        if (voterCount == n) {
            throw;
        }

        var voter = voters[account];
        if (voter.isVoter) {
            throw;
        }

        voter.isVoter = true;
        voterCount++;
        VoterAdded(account);
    }

    function submitValue(bytes8 value) {
        var voter = voters[msg.sender];
        if (!voter.isVoter) {
            throw;
        }
        if (voter.hasVoted) {
            throw;
        }

        voter.hasVoted = true;
        votes[value]++;
        VoteSubmitted(msg.sender, value);

        if (votes[value] == m) {
            finalValue = value;
            ValueFinalized(value);
        }
    }
}",S
0x75f398D5B9E92D17EE307268c28779DA26508F54,Safe,"contract Token {
    event Transfer(address indexed from, address indexed to, uint256 value);
    function transfer(address _to, uint256 _value);
    function balanceOf(address) returns (uint256);
}

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract TokenSale is owned {

	address public asset;
	uint256 public price;

	function TokenSale()
	{
	      asset =  0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A; // DGD
	      price = 1030000000; // 1.03 ETH
	}


	function transfer_token(address _token, address _to, uint256 _value)
	onlyOwner()
	{
		Token(_token).transfer(_to,_value);
	}

	function transfer_eth(address _to, uint256 _value)
	onlyOwner()
	{
		if(this.balance >= _value) {
                    _to.send(_value);
                }
	}

   	function () {

		uint order   = msg.value / price;

		if(order == 0) throw;

		uint256 balance = Token(asset).balanceOf(address(this));

		if(balance == 0) throw;

		if(order > balance )
		{
		    order = balance;
		    uint256 change = msg.value - order * price;
		    msg.sender.send(change);
		}

		Token(asset).transfer(msg.sender,order);
    	}
}",46: unchecked;
0x6adF9E666e3e85876B1Ba25eDB31799FaAd8417b,Safe,"pragma solidity ^0.4.6;
//
// Social Experiment - Finished (or is it... ;)
//
// This contract returns ether (plus bonus) to the ""participant"" who had contributed 100 ether to ""my evil plan""
//
// Status FreeEtherADay:  SUCCESS
// Status HelpMeSave: FAILURE
// Status Free_Ether_A_Day_Funds_Return: TBD......
//
// But is this the end... we'll see. ;)
//
// Watch out for my blog report, will post link via PM to ppl involved
// and here https://www.reddit.com/r/ethtrader/comments/5foa5p/daily_discussion_30nov2016/dalsir4/
// And thanks to everyone who participated. Special mention goes out to /u/WhySoS3rious
// and to 0xb7b8f253f9Df281EFE9E34F07F598f9817D6eb83
//
// Questions: drether00@gmail.com
//

contract Free_Ether_A_Day_Funds_Return {
   address owner;
   address poorguy = 0xb7b8f253f9Df281EFE9E34F07F598f9817D6eb83;

   function Free_Ether_A_Day_Funds_Return() {
        owner = msg.sender;
   }

  // send 100 ether, I'll send back 210 ether ;)
  // thats an additional 10 on top of your 100 for the inconvenience.
  //   truuuuuuuust me....... no bugs this time ;---)

   function return_funds() payable {

       if (msg.sender != poorguy) throw;

       if (msg.value == 100 ether){
             bool success = poorguy.send(210 ether);
             if (!success) throw;
       }
       else throw;
   }

   function() payable {}

   function kill(){
       if (msg.sender == owner)
           selfdestruct(owner);
   }
}",S
0x319af0f8552e2caceb6a8b2541ef00239a6ae1cc,Safe,"pragma solidity ^0.4.6;

/*
    There is a limit of how much gas can be spent in a single block. This limit is flexible, but it is quite hard to increase it.
    This means that every single function in your contract should stay below a certain amount of gas in all (reasonable) situations.
    This applies to anything that uses loops.

    https://blog.ethereum.org/2016/06/10/smart-contract-security/

    Looper is a public utility which can be used to put a limit on loops, so that they stay within the gas limit
*/

contract Looper {

function maximumNumberOfLoops(uint _costSansLoops, uint _loopCost) public constant returns (uint loopLimit) {
    uint gasLimit = getGasLimit();
    uint gasForLoops = gasLimit - _costSansLoops;
    return loopLimit = getLoopLimit(gasForLoops, _loopCost);
}

function canDoLoop(uint _costSansLoops, uint _loopCost, uint _numberOfLoops) public constant returns (bool) {
    uint loopLimit = maximumNumberOfLoops(_costSansLoops, _loopCost);
    if(_numberOfLoops < loopLimit) return true;
    return false;
}

function getGasLimit() internal constant returns (uint) {
    uint gasLimit;

    assembly {
        gasLimit := gaslimit
    }
    return gasLimit;
}

function getLoopLimit(uint _gasForLoops, uint _loopCost) internal constant returns (uint) {
    uint loopLimit = _gasForLoops / _loopCost;
    return loopLimit;
}

}",S
0x82df5022fbcfdd877830371d7713f0181a554c9c,Safe,"pragma solidity ^0.4.8;

contract mortal {
	address owner;

	function mortal() {
		owner = msg.sender;
	}

	function kill()  {
	    if(msg.sender==owner)
		    suicide(owner);
	}
}



contract Aquarium{
  function receive(address receiver, uint8 animalType, uint32[] ids) payable {}
}


contract Intermediary is mortal{
  Aquarium aquarium;
  uint[] values;

  event NewAquarium(address aqua);

  function Intermediary(){

    values =  [95000000000000000, 190000000000000000, 475000000000000000, 950000000000000000, 4750000000000000000];
  }
  function transfer(uint8[] animalTypes, uint8[] numsXType, uint32[] ids) payable{
    uint needed;
     for(uint8 i = 0; i < animalTypes.length; i++){
      needed+=values[animalTypes[i]]*numsXType[i];
    }
    if (msg.value<needed) throw;

    uint8 from;
    for(i = 0; i < animalTypes.length; i++){
      aquarium.receive.value(values[animalTypes[i]]*numsXType[i])(msg.sender,animalTypes[i],slice(ids,from,numsXType[i]));
      from+=numsXType[i];
    }
  }

  function setAquarium(address aqua){
    if(msg.sender==owner){
      aquarium = Aquarium(aqua);
      NewAquarium(aqua);
    }

  }

  function slice(uint32[] array, uint8 from, uint8 number) returns (uint32[] sliced){
    sliced = new uint32[](number);
    for(uint8 i = from; i < from+number; i++){
      sliced[i-from] = array[i];
    }
  }
}",S
0xaced90c414006b622a4b1ce74fa34b1f650ab319,Safe,"pragma solidity ^0.4.0;

library TokenEventLib {
    /*
     * When underlying solidity issue is fixed this library will not be needed.
     * https://github.com/ethereum/solidity/issues/1215
     */
    event Transfer(address indexed _from,
                   address indexed _to);
    event Approval(address indexed _owner,
                   address indexed _spender);

    function _Transfer(address _from, address _to) internal {
        Transfer(_from, _to);
    }

    function _Approval(address _owner, address _spender) internal {
        Approval(_owner, _spender);
    }
}

contract TokenInterface {
    /*
     *  Events
     */
    event Mint(address indexed _owner);
    event Destroy(address _owner);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event MinterAdded(address who);
    event MinterRemoved(address who);

    /*
     *  Minting
     */
    /// @dev Mints a new token.
    /// @param _owner Address of token owner.
    function mint(address _owner) returns (bool success);

    /// @dev Destroy a token
    /// @param _owner Bytes32 id of the owner of the token
    function destroy(address _owner) returns (bool success);

    /// @dev Add a new minter
    /// @param who Address the address that can now mint tokens.
    function addMinter(address who) returns (bool);

    /// @dev Remove a minter
    /// @param who Address the address that will no longer be a minter.
    function removeMinter(address who) returns (bool);

    /*
     *  Read and write storage functions
     */

    /// @dev Return the number of tokens
    function totalSupply() constant returns (uint supply);

    /// @dev Transfers sender token to given address. Returns success.
    /// @param _to Address of new token owner.
    /// @param _value Bytes32 id of the token to transfer.
    function transfer(address _to, uint256 _value) returns (bool success);

    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.
    /// @param _from Address of token owner.
    /// @param _to Address of new token owner.
    /// @param _value Bytes32 id of the token to transfer.
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    /// @dev Sets approval spender to transfer ownership of token. Returns success.
    /// @param _spender Address of spender..
    /// @param _value Bytes32 id of token that can be spend.
    function approve(address _spender, uint256 _value) returns (bool success);

    /*
     * Read storage functions
     */
    /// @dev Returns id of token owned by given address (encoded as an integer).
    /// @param _owner Address of token owner.
    function balanceOf(address _owner) constant returns (uint256 balance);

    /// @dev Returns the token id that may transfer from _owner account by _spender..
    /// @param _owner Address of token owner.
    /// @param _spender Address of token spender.
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    /*
     *  Extra non ERC20 functions
     */
    /// @dev Returns whether the address owns a token.
    /// @param _owner Address to check.
    function isTokenOwner(address _owner) constant returns (bool);
}

contract IndividualityTokenInterface {
    /*
     * Read storage functions
     */

    /// @dev Returns id of token owned by given address (encoded as an integer).
    /// @param _owner Address of token owner.
    function balanceOf(address _owner) constant returns (uint256 balance);

    /// @dev Returns the token id that may transfer from _owner account by _spender..
    /// @param _owner Address of token owner.
    /// @param _spender Address of token spender.
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    /*
     *  Write storage functions
     */

    /// @dev Transfers sender token to given address. Returns success.
    /// @param _to Address of new token owner.
    /// @param _value Bytes32 id of the token to transfer.
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transfer(address _to) public returns (bool success);

    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.
    /// @param _from Address of token owner.
    /// @param _to Address of new token owner.
    /// @param _value Bytes32 id of the token to transfer.
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to) public returns (bool success);

    /// @dev Sets approval spender to transfer ownership of token. Returns success.
    /// @param _spender Address of spender..
    /// @param _value Bytes32 id of token that can be spend.
    function approve(address _spender, uint256 _value) public returns (bool success);
    function approve(address _spender) public returns (bool success);

    /*
     *  Extra non ERC20 functions
     */

    /// @dev Returns whether the address owns a token.
    /// @param _owner Address to check.
    function isTokenOwner(address _owner) constant returns (bool);
}


contract IndividualityToken is TokenInterface, IndividualityTokenInterface {
    function IndividualityToken() {
        minters[msg.sender] = true;
        MinterAdded(msg.sender);
    }

    modifier minterOnly {
        if(!minters[msg.sender]) throw;
        _;
    }

    // address => canmint
    mapping (address => bool) minters;

    // owner => balance
    mapping (address => uint) balances;

    // owner => spender => balance
    mapping (address => mapping (address => uint)) approvals;

    uint numTokens;

    /// @dev Mints a new token.
    /// @param _to Address of token owner.
    function mint(address _to) minterOnly returns (bool success) {
        // ensure that the token owner doesn't already own a token.
        if (balances[_to] != 0x0) return false;

        balances[_to] = 1;

        // log the minting of this token.
        Mint(_to);
        Transfer(0x0, _to, 1);
        TokenEventLib._Transfer(0x0, _to);

        // increase the supply.
        numTokens += 1;

        return true;
    }

    // @dev Mint many new tokens
    function mint(address[] _to) minterOnly returns (bool success) {
        for(uint i = 0; i < _to.length; i++) {
            if(balances[_to[i]] != 0x0) return false;
            balances[_to[i]] = 1;
            Mint(_to[i]);
            Transfer(0x0, _to[i], 1);
            TokenEventLib._Transfer(0x0, _to[i]);
        }
        numTokens += _to.length;
        return true;
    }

    /// @dev Destroy a token
    /// @param _owner address owner of the token to destroy
    function destroy(address _owner) minterOnly returns (bool success) {
        if(balances[_owner] != 1) throw;

        balances[_owner] = 0;
        numTokens -= 1;
        Destroy(_owner);
        return true;
    }

    /// @dev Add a new minter
    /// @param who Address the address that can now mint tokens.
    function addMinter(address who) minterOnly returns (bool) {
        minters[who] = true;
        MinterAdded(who);
    }

    /// @dev Remove a minter
    /// @param who Address the address that will no longer be a minter.
    function removeMinter(address who) minterOnly returns (bool) {
        minters[who] = false;
        MinterRemoved(who);
    }

    /// @dev Return the number of tokens
    function totalSupply() constant returns (uint supply) {
        return numTokens;
    }

    /// @dev Returns id of token owned by given address (encoded as an integer).
    /// @param _owner Address of token owner.
    function balanceOf(address _owner) constant returns (uint256 balance) {
        if (_owner == 0x0) {
            return 0;
        } else {
            return balances[_owner];
        }
    }

    /// @dev Returns the token id that may transfer from _owner account by _spender..
    /// @param _owner Address of token owner.
    /// @param _spender Address of token spender.
    function allowance(address _owner,
                       address _spender) constant returns (uint256 remaining) {
        return approvals[_owner][_spender];
    }

    /// @dev Transfers sender token to given address. Returns success.
    /// @param _to Address of new token owner.
    /// @param _value Bytes32 id of the token to transfer.
    function transfer(address _to,
                      uint256 _value) public returns (bool success) {
        if (_value != 1) {
            // 1 is the only value that makes any sense here.
            return false;
        } else if (_to == 0x0) {
            // cannot transfer to the null address.
            return false;
        } else if (balances[msg.sender] == 0x0) {
            // msg.sender is not a token owner
            return false;
        } else if (balances[_to] != 0x0) {
            // cannot transfer to an address that already owns a token.
            return false;
        }

        balances[msg.sender] = 0;
        balances[_to] = 1;
        Transfer(msg.sender, _to, 1);
        TokenEventLib._Transfer(msg.sender, _to);

        return true;
    }

    /// @dev Transfers sender token to given address. Returns success.
    /// @param _to Address of new token owner.
    function transfer(address _to) public returns (bool success) {
        return transfer(_to, 1);
    }

    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.
    /// @param _from Address of token owner.
    /// @param _to Address of new token owner.
    /// @param _value Bytes32 id of the token to transfer.
    function transferFrom(address _from,
                          address _to,
                          uint256 _value) public returns (bool success) {
        if (_value != 1) {
            // Cannot transfer anything other than 1 token.
            return false;
        } else if (_to == 0x0) {
            // Cannot transfer to the null address
            return false;
        } else if (balances[_from] == 0x0) {
            // Cannot transfer if _from is not a token owner
            return false;
        } else if (balances[_to] != 0x0) {
            // Cannot transfer to an existing token owner
            return false;
        } else if (approvals[_from][msg.sender] == 0) {
            // The approved token doesn't match the token being transferred.
            return false;
        }

        // null out the approval
        approvals[_from][msg.sender] = 0x0;

        // remove the token from the sender.
        balances[_from] = 0;

        // assign the token to the new owner
        balances[_to] = 1;

        // log the transfer
        Transfer(_from, _to, 1);
        TokenEventLib._Transfer(_from, _to);

        return true;
    }

    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.
    /// @param _from Address of token owner.
    /// @param _to Address of new token owner.
    function transferFrom(address _from, address _to) public returns (bool success) {
        return transferFrom(_from, _to, 1);
    }

    /// @dev Sets approval spender to transfer ownership of token. Returns success.
    /// @param _spender Address of spender..
    /// @param _value Bytes32 id of token that can be spend.
    function approve(address _spender,
                     uint256 _value) public returns (bool success) {
        if (_value != 1) {
            // cannot approve any value other than 1
            return false;
        } else if (_spender == 0x0) {
            // cannot approve the null address as a spender.
            return false;
        } else if (balances[msg.sender] == 0x0) {
            // cannot approve if not a token owner.
            return false;
        }

        approvals[msg.sender][_spender] = 1;

        Approval(msg.sender, _spender, 1);
        TokenEventLib._Approval(msg.sender, _spender);

        return true;
    }

    /// @dev Sets approval spender to transfer ownership of token. Returns success.
    /// @param _spender Address of spender..
    function approve(address _spender) public returns (bool success) {
        return approve(_spender, 1);
    }

    /*
     *  Extra non ERC20 functions
     */
    /// @dev Returns whether the address owns a token.
    /// @param _owner Address to check.
    function isTokenOwner(address _owner) constant returns (bool) {
        return balances[_owner] != 0;
    }
}",S
0x911143d946ba5d467bfc476491fdb235fef4d667,Safe,"pragma solidity ^0.4.4;


/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.
/// @author Stefan George - <stefan.george@consensys.net>
contract MultiSigWallet {

    uint constant public MAX_OWNER_COUNT = 50;

    event Confirmation(address indexed sender, uint indexed transactionId);
    event Revocation(address indexed sender, uint indexed transactionId);
    event Submission(uint indexed transactionId);
    event Execution(uint indexed transactionId);
    event ExecutionFailure(uint indexed transactionId);
    event Deposit(address indexed sender, uint value);
    event OwnerAddition(address indexed owner);
    event OwnerRemoval(address indexed owner);
    event RequirementChange(uint required);

    mapping (uint => Transaction) public transactions;
    mapping (uint => mapping (address => bool)) public confirmations;
    mapping (address => bool) public isOwner;
    address[] public owners;
    uint public required;
    uint public transactionCount;

    struct Transaction {
        address destination;
        uint value;
        bytes data;
        bool executed;
    }

    modifier onlyWallet() {
        if (msg.sender != address(this))
            throw;
        _;
    }

    modifier ownerDoesNotExist(address owner) {
        if (isOwner[owner])
            throw;
        _;
    }

    modifier ownerExists(address owner) {
        if (!isOwner[owner])
            throw;
        _;
    }

    modifier transactionExists(uint transactionId) {
        if (transactions[transactionId].destination == 0)
            throw;
        _;
    }

    modifier confirmed(uint transactionId, address owner) {
        if (!confirmations[transactionId][owner])
            throw;
        _;
    }

    modifier notConfirmed(uint transactionId, address owner) {
        if (confirmations[transactionId][owner])
            throw;
        _;
    }

    modifier notExecuted(uint transactionId) {
        if (transactions[transactionId].executed)
            throw;
        _;
    }

    modifier notNull(address _address) {
        if (_address == 0)
            throw;
        _;
    }

    modifier validRequirement(uint ownerCount, uint _required) {
        if (   ownerCount > MAX_OWNER_COUNT
            || _required > ownerCount
            || _required == 0
            || ownerCount == 0)
            throw;
        _;
    }

    /// @dev Fallback function allows to deposit ether.
    function()
        payable
    {
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }

    /*
     * Public functions
     */
    /// @dev Contract constructor sets initial owners and required number of confirmations.
    /// @param _owners List of initial owners.
    /// @param _required Number of required confirmations.
    function MultiSigWallet(address[] _owners, uint _required)
        public
        validRequirement(_owners.length, _required)
    {
        for (uint i=0; i<_owners.length; i++) {
            if (isOwner[_owners[i]] || _owners[i] == 0)
                throw;
            isOwner[_owners[i]] = true;
        }
        owners = _owners;
        required = _required;
    }

    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.
    /// @param owner Address of new owner.
    function addOwner(address owner)
        public
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        OwnerAddition(owner);
    }

    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.
    /// @param owner Address of owner.
    function removeOwner(address owner)
        public
        onlyWallet
        ownerExists(owner)
    {
        isOwner[owner] = false;
        for (uint i=0; i<owners.length - 1; i++)
            if (owners[i] == owner) {
                owners[i] = owners[owners.length - 1];
                break;
            }
        owners.length -= 1;
        if (required > owners.length)
            changeRequirement(owners.length);
        OwnerRemoval(owner);
    }

    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.
    /// @param owner Address of owner to be replaced.
    /// @param owner Address of new owner.
    function replaceOwner(address owner, address newOwner)
        public
        onlyWallet
        ownerExists(owner)
        ownerDoesNotExist(newOwner)
    {
        for (uint i=0; i<owners.length; i++)
            if (owners[i] == owner) {
                owners[i] = newOwner;
                break;
            }
        isOwner[owner] = false;
        isOwner[newOwner] = true;
        OwnerRemoval(owner);
        OwnerAddition(newOwner);
    }

    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.
    /// @param _required Number of required confirmations.
    function changeRequirement(uint _required)
        public
        onlyWallet
        validRequirement(owners.length, _required)
    {
        required = _required;
        RequirementChange(_required);
    }

    /// @dev Allows an owner to submit and confirm a transaction.
    /// @param destination Transaction target address.
    /// @param value Transaction ether value.
    /// @param data Transaction data payload.
    /// @return Returns transaction ID.
    function submitTransaction(address destination, uint value, bytes data)
        public
        returns (uint transactionId)
    {
        transactionId = addTransaction(destination, value, data);
        confirmTransaction(transactionId);
    }

    /// @dev Allows an owner to confirm a transaction.
    /// @param transactionId Transaction ID.
    function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }

    /// @dev Allows an owner to revoke a confirmation for a transaction.
    /// @param transactionId Transaction ID.
    function revokeConfirmation(uint transactionId)
        public
        ownerExists(msg.sender)
        confirmed(transactionId, msg.sender)
        notExecuted(transactionId)
    {
        confirmations[transactionId][msg.sender] = false;
        Revocation(msg.sender, transactionId);
    }

    /// @dev Allows anyone to execute a confirmed transaction.
    /// @param transactionId Transaction ID.
    function executeTransaction(uint transactionId)
        public
        notExecuted(transactionId)
    {
        if (isConfirmed(transactionId)) {
            Transaction tx = transactions[transactionId];
            tx.executed = true;
            if (tx.destination.call.value(tx.value)(tx.data))
                Execution(transactionId);
            else {
                ExecutionFailure(transactionId);
                tx.executed = false;
            }
        }
    }

    /// @dev Returns the confirmation status of a transaction.
    /// @param transactionId Transaction ID.
    /// @return Confirmation status.
    function isConfirmed(uint transactionId)
        public
        constant
        returns (bool)
    {
        uint count = 0;
        for (uint i=0; i<owners.length; i++) {
            if (confirmations[transactionId][owners[i]])
                count += 1;
            if (count == required)
                return true;
        }
    }

    /*
     * Internal functions
     */
    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.
    /// @param destination Transaction target address.
    /// @param value Transaction ether value.
    /// @param data Transaction data payload.
    /// @return Returns transaction ID.
    function addTransaction(address destination, uint value, bytes data)
        internal
        notNull(destination)
        returns (uint transactionId)
    {
        transactionId = transactionCount;
        transactions[transactionId] = Transaction({
            destination: destination,
            value: value,
            data: data,
            executed: false
        });
        transactionCount += 1;
        Submission(transactionId);
    }

    /*
     * Web3 call functions
     */
    /// @dev Returns number of confirmations of a transaction.
    /// @param transactionId Transaction ID.
    /// @return Number of confirmations.
    function getConfirmationCount(uint transactionId)
        public
        constant
        returns (uint count)
    {
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionId][owners[i]])
                count += 1;
    }

    /// @dev Returns total number of transactions after filers are applied.
    /// @param pending Include pending transactions.
    /// @param executed Include executed transactions.
    /// @return Total number of transactions after filters are applied.
    function getTransactionCount(bool pending, bool executed)
        public
        constant
        returns (uint count)
    {
        for (uint i=0; i<transactionCount; i++)
            if (   pending && !transactions[i].executed
                || executed && transactions[i].executed)
                count += 1;
    }

    /// @dev Returns list of owners.
    /// @return List of owner addresses.
    function getOwners()
        public
        constant
        returns (address[])
    {
        return owners;
    }

    /// @dev Returns array with owner addresses, which confirmed transaction.
    /// @param transactionId Transaction ID.
    /// @return Returns array of owner addresses.
    function getConfirmations(uint transactionId)
        public
        constant
        returns (address[] _confirmations)
    {
        address[] memory confirmationsTemp = new address[](owners.length);
        uint count = 0;
        uint i;
        for (i=0; i<owners.length; i++)
            if (confirmations[transactionId][owners[i]]) {
                confirmationsTemp[count] = owners[i];
                count += 1;
            }
        _confirmations = new address[](count);
        for (i=0; i<count; i++)
            _confirmations[i] = confirmationsTemp[i];
    }

    /// @dev Returns list of transaction IDs in defined range.
    /// @param from Index start position of transaction array.
    /// @param to Index end position of transaction array.
    /// @param pending Include pending transactions.
    /// @param executed Include executed transactions.
    /// @return Returns array of transaction IDs.
    function getTransactionIds(uint from, uint to, bool pending, bool executed)
        public
        constant
        returns (uint[] _transactionIds)
    {
        uint[] memory transactionIdsTemp = new uint[](transactionCount);
        uint count = 0;
        uint i;
        for (i=0; i<transactionCount; i++)
            if (   pending && !transactions[i].executed
                || executed && transactions[i].executed)
            {
                transactionIdsTemp[count] = i;
                count += 1;
            }
        _transactionIds = new uint[](to - from);
        for (i=from; i<to; i++)
            _transactionIds[i - from] = transactionIdsTemp[i];
    }
}",S
0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18,Safe,"pragma solidity ^0.4.8;

contract SmartRouletteToken {
	//Tokens data
	string public standard = 'ERC20';
    string public name;
    string public symbol;
    uint8 public decimals;

	struct holderData {
		uint256 tokens_count;
		bool init;
	}

	struct tempHolderData {
		uint256 tokens_count;
		uint256 start_date;
		uint256 end_date;
	}

	address[] listAddrHolders;

	mapping( address => holderData ) _balances;
	mapping( address => tempHolderData ) _temp_balance;
	mapping( address => mapping( address => uint256 ) ) _approvals;

	bool stop_operation;

	uint256 _supply;
	uint256 _init_count_tokens;
	uint256 public costOfOneToken; //the cost of one token in wei

	address wallet_ICO;
	bool enableICO;
	uint256 min_value_buyToken; //in wei
	uint256 max_value_buyToken; //in wei

	address fond_wallet;
	address developer_wallet;

	address divident_contract = address(0x0);

	event TokenBuy(address buyer, uint256 amountOfTokens);

    //Contract data
	address developer;
	address manager;

	struct gamesData {
		bool init;
	}

	mapping( address => gamesData) listGames;
	address[] addrGames;


	function SmartRouletteToken()
	{
		_supply = 100000000000000000;
		_init_count_tokens = 100000000000000000;

		developer_wallet = address(0x8521E1f9220A251dE0ab78f6a2E8754Ca9E75242);
		_balances[developer_wallet] = holderData((_supply*20)/100, true);

		wallet_ICO = address(0x2dff87f8892d65f7a97b1287e795405098ae7b7f);
		_balances[wallet_ICO] = holderData((_supply*60)/100, true);

		fond_wallet = address(0x3501DD2B515EDC1920f9007782Da5ac018922502);
		_balances[fond_wallet] = holderData((_supply*20)/100, true);

		listAddrHolders.push(developer_wallet);
		listAddrHolders.push(wallet_ICO);
		listAddrHolders.push(fond_wallet);

        name = 'Roulette Token';
        symbol = 'RLT';
        decimals = 10;
        costOfOneToken = 1500000000000000;

		developer = msg.sender;
		manager = msg.sender;

		enableICO = false;
		min_value_buyToken = 1000000000000000000;
		max_value_buyToken = 500000000000000000000;

		stop_operation = false;
	}

	modifier isDeveloper(){
		if (msg.sender!=developer) throw;
		_;
	}

	modifier isManager(){
		if (msg.sender!=manager && msg.sender!=developer) throw;
		_;
	}

	modifier isAccessStopOperation(){
		if (msg.sender!=manager && msg.sender!=developer && (msg.sender!=divident_contract || divident_contract==address(0x0))) throw;
		_;
	}

	function changeDeveloper(address new_developer)
	isDeveloper
	{
		if(new_developer == address(0x0)) throw;
		developer = new_developer;
	}

	function changeManager(address new_manager)
	isDeveloper
	{
		if(new_manager == address(0x0)) throw;
		manager = new_manager;
	}

	function changeDividentContract(address new_contract) isManager
	{
		if(divident_contract!=address(0x0)) throw;
		if(divident_contract==address(0x0)) throw;
		divident_contract = new_contract;
	}

	function newCostToken(uint256 new_cost)
	isManager
	{
		if(new_cost == 0) throw;
		costOfOneToken = new_cost;
	}

	function getostToken() external constant returns(uint256)
	{
		return costOfOneToken;
	}

	function addNewGame(address new_game)
	isManager
	{
		if(new_game == address(0x0)) throw;
		listGames[new_game] = gamesData(true);
		addrGames.push(new_game);
	}

	function deleteGame(address game)
	isManager
	{
		if(game == address(0x0)) throw;
		if(listGames[game].init){
			listGames[game].init = false;
		}
	}

	function kill() isDeveloper {
		suicide(developer);
	}

	function addUserToList(address user) internal {
		if(!_balances[user].init){
			listAddrHolders.push(user);
		}
	}

	function gameListOf( address who ) external constant returns (bool value) {
		gamesData game_data = listGames[who];
		return game_data.init;
	}

	//------------------------------------
	// Tokens Functions
	//------------------------------------
	event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function stopOperation() isAccessStopOperation {
		stop_operation = true;
	}

	function startOperation() isAccessStopOperation {
		stop_operation = false;
	}

	function isOperationBlocked() external constant returns (bool){
		return stop_operation;
	}

	function runICO() isManager {
		enableICO = true;
	}

	function stopICO() isManager {
		enableICO = false;
	}

	function infoICO() constant returns (bool){
		return enableICO;
	}

	function totalSupply() constant returns (uint256 supply) {
		return _supply;
	}

	function initCountTokens() constant returns (uint256 init_count) {
		return _init_count_tokens;
	}

	function balanceOf( address who ) external constant returns (uint256 value) {
		return _balances[who].tokens_count;
	}

	function allowance(address owner, address spender) constant returns (uint256 _allowance) {
		return _approvals[owner][spender];
	}

	// overflow check
	function safeToAdd(uint256 a, uint256 b) internal returns (bool) {
		return (a + b >= a && a + b >= b);
	}

	function transfer( address to, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		if( _balances[msg.sender].tokens_count < value ) {
		    throw;
		}
		if( !safeToAdd(_balances[to].tokens_count, value) ) {
		    throw;
		}

		_balances[msg.sender].tokens_count -= value;
		if(_balances[to].init){
			_balances[to].tokens_count += value;
		}
		else{
			addUserToList(to);
			_balances[to] = holderData(value, true);
		}

		Transfer( msg.sender, to, value );
		return true;
	}

	function transferFrom( address from, address to, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		if( _balances[from].tokens_count < value ) {
		    throw;
		}

		if( _approvals[from][msg.sender] < value ) {
		    throw;
		}
		if( !safeToAdd(_balances[to].tokens_count, value) ) {
		    throw;
		}
		// transfer and return true
		_approvals[from][msg.sender] -= value;
		_balances[from].tokens_count -= value;
		if(_balances[to].init){
			_balances[to].tokens_count += value;
		}
		else{
			addUserToList(to);
			_balances[to] = holderData(value, true);
		}

		Transfer( from, to, value );
		return true;
	}

	function approve(address spender, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		_approvals[msg.sender][spender] = value;
		Approval( msg.sender, spender, value );
		return true;
	}

	event Emission(address indexed to, uint256 value, uint256 bet, uint256 coef, uint256 decimals, uint256 cost_token);

	function emission(address player, address partner, uint256 value_bet, uint16 coef_player, uint16 coef_partner) external returns(uint256) {
		if(stop_operation) throw;

		if(listGames[msg.sender].init == false) throw;
		if(player == address(0x0)) throw;
		if(value_bet == 0) throw;

		uint256 decimals_token = 10**uint256(decimals);

		uint256 player_token = ((value_bet*coef_player*decimals_token)/10000)/costOfOneToken;
		if(_balances[player].init){
			_balances[player].tokens_count += player_token;
		}
		else{
			addUserToList(player);
			_balances[player] = holderData(player_token, true);
		}
		Emission(player, player_token, value_bet, coef_player, decimals_token, costOfOneToken);

		uint256 partner_token = 0;
		if(partner != address(0x0)){
			partner_token = ((value_bet*coef_partner*decimals_token)/10000)/costOfOneToken;
			if(_balances[partner].init){
				_balances[partner].tokens_count += partner_token;
			}
			else{
				addUserToList(partner);
				_balances[partner] = holderData(partner_token, true);
			}
			Emission(partner, partner_token, value_bet, coef_partner, decimals_token, costOfOneToken);
		}

		_supply += (player_token+partner_token);

		return player_token;
	}

	//------------------------------------
	// Temporary Tokens
	//------------------------------------
	address[] listAddrTempHolders;
	event TempTokensSend(address indexed recipient, uint256 count, uint256 start, uint256 end);

	function sendTempTokens(address recipient, uint256 count, uint256 period) isManager {
		if(stop_operation) throw;

		if(count==0 || period==0) throw;

		uint256 decimals_token = 10**uint256(decimals);
		count = count*decimals_token;

		if(_balances[fond_wallet].tokens_count < count) throw;
		if(_temp_balance[recipient].tokens_count > 0) throw;

		_temp_balance[recipient] = tempHolderData(count, now, now + period);
		listAddrTempHolders.push(recipient);
		_balances[fond_wallet].tokens_count -= count;
		TempTokensSend(recipient, count, _temp_balance[recipient].start_date, _temp_balance[recipient].end_date);
	}

	function tempTokensBalanceOf( address who ) external constant returns (uint256) {
		//tempHolderData data_holder = __temp_balance[who];
		if(_temp_balance[who].end_date < now) return 0;
		else return _temp_balance[who].tokens_count;
	}

	function tempTokensPeriodOf( address who ) external constant returns (uint256) {
		if(_temp_balance[who].end_date < now) return 0;
		else return _temp_balance[who].end_date;
	}

	function returnTempTokens(address recipient) isManager {
		if(stop_operation) throw;

		if(_temp_balance[recipient].tokens_count == 0) throw;

		_balances[fond_wallet].tokens_count += _temp_balance[recipient].tokens_count;
		_temp_balance[recipient] = tempHolderData(0, 0, 0);
	}

	function getListTempHolders() constant returns(address[]){
		return listAddrTempHolders;
	}

	function getCountTempHolders() external constant returns(uint256){
		return listAddrTempHolders.length;
	}

	function getItemTempHolders(uint256 index) external constant returns(address){
		if(index >= listAddrTempHolders.length) return address(0x0);
		else return listAddrTempHolders[index];
	}

	//------------------------------------
	// Invest Functions
	//------------------------------------
	/*event SuccessProfitSend(address indexed holder, uint value);
	event FailProfitSend(address indexed holder, uint value);*/

	function() payable
	{
		if(stop_operation) throw;
		if(msg.sender == developer) throw;
		if(msg.sender == manager) throw;
		if(msg.sender == developer_wallet) throw;
		if(msg.sender == wallet_ICO) throw;
		if(msg.sender == fond_wallet) throw;

		if(listGames[msg.sender].init) throw;

		if(enableICO == false) throw;

		if(msg.value < min_value_buyToken) throw;

		uint256 value_send = msg.value;
		if(value_send > max_value_buyToken){
			value_send = max_value_buyToken;
			if(msg.sender.send(msg.value-max_value_buyToken)==false) throw;
		}

		uint256 decimals_token = 10**uint256(decimals);

		uint256 count_tokens = (value_send*decimals_token)/costOfOneToken;

		if(count_tokens >_balances[wallet_ICO].tokens_count ){
			count_tokens = _balances[wallet_ICO].tokens_count;
		}
		if(value_send > (count_tokens*costOfOneToken)/decimals_token){
			if(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;
			value_send = (count_tokens*costOfOneToken)/decimals_token;
		}

		if(!_balances[msg.sender].init){
			addUserToList(msg.sender);
			_balances[wallet_ICO].tokens_count -= count_tokens;
			_balances[msg.sender] = holderData(count_tokens, true);
		}
		else{
			if(((_balances[msg.sender].tokens_count*costOfOneToken)/decimals_token)+((count_tokens*costOfOneToken)/decimals_token)>max_value_buyToken) {
				count_tokens = ((max_value_buyToken*decimals_token)/costOfOneToken)-_balances[msg.sender].tokens_count;
				if(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;
				value_send = (count_tokens*costOfOneToken)/decimals_token;
			}

			_balances[wallet_ICO].tokens_count -= count_tokens;
			_balances[msg.sender].tokens_count += count_tokens;
		}

		if(value_send>0){
			if(wallet_ICO.send(value_send)==false) throw;
		}

		if(count_tokens>0){
			TokenBuy(msg.sender, count_tokens);
		}

		if(_balances[wallet_ICO].tokens_count == 0){
			enableICO = false;
		}
	}

	function getListAddressHolders() constant returns(address[]){
		return listAddrHolders;
	}

	function getCountHolders() external constant returns(uint256){
		return listAddrHolders.length;
	}

	function getItemHolders(uint256 index) external constant returns(address){
		if(index >= listAddrHolders.length) return address(0x0);
		else return listAddrHolders[index];
	}
}",S
0xa3d4d7df3988d48c48728787cb5910a8a4cc4d26,Safe,"contract Etheropt {

  struct Option {
    int strike;
  }
  struct Position {
    mapping(uint => int) positions;
    int cash;
    bool expired;
    bool hasPosition;
  }
  struct OptionChain {
    uint expiration;
    string underlying;
    uint margin;
    uint realityID;
    bytes32 factHash;
    address ethAddr;
    mapping(uint => Option) options;
    uint numOptions;
    bool expired;
    mapping(address => Position) positions;
    uint numPositions;
    uint numPositionsExpired;
  }
  mapping(uint => OptionChain) optionChains;
  uint numOptionChains;
  struct Account {
    address user;
    int capital;
  }
  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills
  struct MarketMaker {
    address user;
    string server;
  }
  mapping(uint => MarketMaker) marketMakers; //starts at 1
  uint public numMarketMakers = 0;
  mapping(address => uint) marketMakerIDs;
  mapping(uint => Account) accounts;
  uint public numAccounts;
  mapping(address => uint) accountIDs; //starts at 1

  function Market() {
  }

  function getAccountID(address user) constant returns(uint) {
    return accountIDs[user];
  }

  function getAccount(uint accountID) constant returns(address) {
    return accounts[accountID].user;
  }

  function addFunds() {
    if (accountIDs[msg.sender]>0) {
      accounts[accountIDs[msg.sender]].capital += int(msg.value);
    } else {
      uint accountID = ++numAccounts;
      accounts[accountID].user = msg.sender;
      accounts[accountID].capital += int(msg.value);
      accountIDs[msg.sender] = accountID;
    }
  }

  function withdrawFunds(uint amount) {
    if (accountIDs[msg.sender]>0) {
      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
        accounts[accountIDs[msg.sender]].capital -= int(amount);
        msg.sender.send(amount);
      }
    }
  }

  function getFunds(address user, bool onlyAvailable) constant returns(int) {
    if (accountIDs[user]>0) {
      if (onlyAvailable == false) {
        return accounts[accountIDs[user]].capital;
      } else {
        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);
      }
    } else {
      return 0;
    }
  }

  function getFundsAndAvailable(address user) constant returns(int, int) {
    return (getFunds(user, false), getFunds(user, true));
  }

  function marketMaker(string server) {
    if (msg.value>0) throw;
    if (marketMakerIDs[msg.sender]>0) {
      marketMakers[marketMakerIDs[msg.sender]].server = server;
    } else {
      int funds = getFunds(marketMakers[i].user, false);
      uint marketMakerID = 0;
      if (numMarketMakers<6) {
        marketMakerID = ++numMarketMakers;
      } else {
        for (uint i=2; i<=numMarketMakers; i++) {
          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {
            marketMakerID = i;
          }
        }
      }
      if (marketMakerID>0) {
        marketMakerIDs[marketMakers[marketMakerID].user] = 0;
        marketMakers[marketMakerID].user = msg.sender;
        marketMakers[marketMakerID].server = server;
        marketMakerIDs[msg.sender] = marketMakerID;
      } else {
        throw;
      }
    }
  }

  function getMarketMakers() constant returns(string, string, string, string, string, string) {
    string[] memory servers = new string[](6);
    for (uint i=1; i<=numMarketMakers; i++) {
      servers[i-1] = marketMakers[i].server;
    }
    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);
  }

  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {
    int[] memory funds = new int[](6);
    for (uint i=1; i<=numMarketMakers; i++) {
      funds[i-1] = getFunds(marketMakers[i].user, false);
    }
    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);
  }

  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {
    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);
  }

  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {
    uint[] memory optionIDs = new uint[](60);
    int[] memory strikes = new int[](60);
    int[] memory positions = new int[](60);
    int[] memory cashes = new int[](60);
    uint z = 0;
    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {
      if (optionChains[uint(optionChainID)].expired == false) {
        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {
          optionIDs[z] = uint(optionChainID)*1000 + optionID;
          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;
          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];
          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;
          z++;
        }
      }
    }
    return (optionIDs, strikes, positions, cashes);
  }

  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
    if (optionChains[optionChainID].expired == false) {
      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {
        uint lastAccount = numAccounts;
        if (accountID==0) {
          accountID = 1;
        } else {
          lastAccount = accountID;
        }
        for (accountID=accountID; accountID<=lastAccount; accountID++) {
          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {
            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;
            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {
              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);
              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
            }
            accounts[accountID].capital = accounts[accountID].capital + result;
            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;
            optionChains[optionChainID].numPositionsExpired++;
          }
        }
        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {
          optionChains[optionChainID].expired = true;
        }
      }
    }
  }

  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {
    if (strike>=0) { //call
      if (settlement>uint(strike)) {
        if (settlement-uint(strike)<margin) {
          return int(settlement-uint(strike));
        } else {
          return int(margin);
        }
      } else {
        return 0;
      }
    } else { //put
      if (settlement<uint(-strike)) {
        if (uint(-strike)-settlement<margin) {
          return int(uint(-strike)-settlement);
        } else {
          return int(margin);
        }
      } else {
        return 0;
      }
    }
  }

  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {
    uint optionChainID = 6;
    if (numOptionChains<6) {
      optionChainID = numOptionChains++;
    } else {
      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {
        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {
          optionChainID = i;
        }
      }
    }
    if (optionChainID<6) {
      delete optionChains[optionChainID];
      optionChains[optionChainID].expiration = expiration;
      optionChains[optionChainID].underlying = underlying;
      optionChains[optionChainID].margin = margin;
      optionChains[optionChainID].realityID = realityID;
      optionChains[optionChainID].factHash = factHash;
      optionChains[optionChainID].ethAddr = ethAddr;
      for (i=0; i < strikes.length; i++) {
        if (optionChains[optionChainID].numOptions<10) {
          uint optionID = optionChains[optionChainID].numOptions++;
          Option option = optionChains[optionChainID].options[i];
          option.strike = strikes[i];
          optionChains[optionChainID].options[i] = option;
        }
      }
    }
  }

  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {
    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {
      return true;
    }
    return false;
  }

  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {
    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);
    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {
      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {
        optionChains[optionChainID].positions[msg.sender].hasPosition = true;
        optionChains[optionChainID].numPositions++;
      }
      if (optionChains[optionChainID].positions[addr].hasPosition == false) {
        optionChains[optionChainID].positions[addr].hasPosition = true;
        optionChains[optionChainID].numPositions++;
      }
      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;
      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);
      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;
      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);
      orderFills[hash] -= matchSize;
    }
  }

  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {
    int totalMaxLoss = 0;
    for (uint i=0; i<numOptionChains; i++) {
      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {
        bool maxLossInitialized = false;
        int maxLoss = 0;
        for (uint s=0; s<optionChains[i].numOptions; s++) {
          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;
          if (i==optionChainID) {
            pnl += cashChange / 1000000000000000000;
          }
          uint settlement = 0;
          if (optionChains[i].options[s].strike<0) {
            settlement = uint(-optionChains[i].options[s].strike);
          } else {
            settlement = uint(optionChains[i].options[s].strike);
          }
          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);
          if (pnl<maxLoss || maxLossInitialized==false) {
            maxLossInitialized = true;
            maxLoss = pnl;
          }
          pnl = optionChains[i].positions[user].cash / 1000000000000000000;
          if (i==optionChainID) {
            pnl += cashChange / 1000000000000000000;
          }
          settlement = 0;
          if (optionChains[i].options[s].strike<0) {
            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {
              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;
            } else {
              settlement = 0;
            }
          } else {
            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;
          }
          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);
          if (pnl<maxLoss) {
            maxLoss = pnl;
          }
        }
        totalMaxLoss += maxLoss;
      }
    }
    return totalMaxLoss;
  }

  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {
    int pnl = 0;
    for (uint j=0; j<optionChains[i].numOptions; j++) {
      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;
      if (i==optionChainID && j==optionID) {
        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;
      }
    }
    return pnl;
  }

  function min(uint a, uint b) constant returns(uint) {
    if (a<b) {
      return a;
    } else {
      return b;
    }
  }
}",70: unchecked;
0xb961339f6f7f3b020255d9281fdd3bf2eb9b4d1e,Safe,"pragma solidity ^0.4.8;

contract SmartRouletteToken {
	//Tokens data
	string public standard = 'ERC20';
    string public name;
    string public symbol;
    uint8 public decimals;

	struct holderData {
		uint256 tokens_count;
		bool init;
	}

	struct tempHolderData {
		uint256 tokens_count;
		uint256 start_date;
		uint256 end_date;
	}

	address[] listAddrHolders;

	mapping( address => holderData ) _balances;
	mapping( address => tempHolderData ) _temp_balance;
	mapping( address => mapping( address => uint256 ) ) _approvals;

	bool stop_operation;

	uint256 _supply;
	uint256 _init_count_tokens;
	uint256 public costOfOneToken; //the cost of one token in wei

	address wallet_ICO;
	bool enableICO;
	uint256 min_value_buyToken; //in wei
	uint256 max_value_buyToken; //in wei

	address fond_wallet;
	address developer_wallet;

	address divident_contract = address(0x0);

	event TokenBuy(address buyer, uint256 amountOfTokens);

    //Contract data
	address developer;
	address manager;

	struct gamesData {
		bool init;
	}

	mapping( address => gamesData) listGames;
	address[] addrGames;


	function SmartRouletteToken()
	{
		_supply = 100000000000000000;
		_init_count_tokens = 100000000000000000;

		developer_wallet = address(0x8521E1f9220A251dE0ab78f6a2E8754Ca9E75242);
		_balances[developer_wallet] = holderData((_supply*20)/100, true);

		wallet_ICO = address(0x2dff87f8892d65f7a97b1287e795405098ae7b7f);
		_balances[wallet_ICO] = holderData((_supply*60)/100, true);

		fond_wallet = address(0x3501DD2B515EDC1920f9007782Da5ac018922502);
		_balances[fond_wallet] = holderData((_supply*20)/100, true);

		listAddrHolders.push(developer_wallet);
		listAddrHolders.push(wallet_ICO);
		listAddrHolders.push(fond_wallet);

        name = 'Roulette Token';
        symbol = 'RLT';
        decimals = 10;
        costOfOneToken = 1500000000000000;

		developer = msg.sender;
		manager = msg.sender;

		enableICO = false;
		min_value_buyToken = 1000000000000000000;
		max_value_buyToken = 500000000000000000000;

		stop_operation = false;
	}

	modifier isDeveloper(){
		if (msg.sender!=developer) throw;
		_;
	}

	modifier isManager(){
		if (msg.sender!=manager && msg.sender!=developer) throw;
		_;
	}

	modifier isAccessStopOperation(){
		if (msg.sender!=manager && msg.sender!=developer && (msg.sender!=divident_contract || divident_contract==address(0x0))) throw;
		_;
	}

	function changeDeveloper(address new_developer)
	isDeveloper
	{
		if(new_developer == address(0x0)) throw;
		developer = new_developer;
	}

	function changeManager(address new_manager)
	isDeveloper
	{
		if(new_manager == address(0x0)) throw;
		manager = new_manager;
	}

	function changeDividentContract(address new_contract) isManager
	{
		if(divident_contract!=address(0x0)) throw;
		if(divident_contract==address(0x0)) throw;
		divident_contract = new_contract;
	}

	function newCostToken(uint256 new_cost)
	isManager
	{
		if(new_cost == 0) throw;
		costOfOneToken = new_cost;
	}

	function getostToken() external constant returns(uint256)
	{
		return costOfOneToken;
	}

	function addNewGame(address new_game)
	isManager
	{
		if(new_game == address(0x0)) throw;
		listGames[new_game] = gamesData(true);
		addrGames.push(new_game);
	}

	function deleteGame(address game)
	isManager
	{
		if(game == address(0x0)) throw;
		if(listGames[game].init){
			listGames[game].init = false;
		}
	}

	function kill() isDeveloper {
		suicide(developer);
	}

	function addUserToList(address user) internal {
		if(!_balances[user].init){
			listAddrHolders.push(user);
		}
	}

	function gameListOf( address who ) external constant returns (bool value) {
		gamesData game_data = listGames[who];
		return game_data.init;
	}

	//------------------------------------
	// Tokens Functions
	//------------------------------------
	event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function stopOperation() isAccessStopOperation {
		stop_operation = true;
	}

	function startOperation() isAccessStopOperation {
		stop_operation = false;
	}

	function isOperationBlocked() external constant returns (bool){
		return stop_operation;
	}

	function runICO() isManager {
		enableICO = true;
	}

	function stopICO() isManager {
		enableICO = false;
	}

	function infoICO() constant returns (bool){
		return enableICO;
	}

	function totalSupply() constant returns (uint256 supply) {
		return _supply;
	}

	function initCountTokens() constant returns (uint256 init_count) {
		return _init_count_tokens;
	}

	function balanceOf( address who ) external constant returns (uint256 value) {
		return _balances[who].tokens_count;
	}

	function allowance(address owner, address spender) constant returns (uint256 _allowance) {
		return _approvals[owner][spender];
	}

	// overflow check
	function safeToAdd(uint256 a, uint256 b) internal returns (bool) {
		return (a + b >= a && a + b >= b);
	}

	function transfer( address to, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		if( _balances[msg.sender].tokens_count < value ) {
		    throw;
		}
		if( !safeToAdd(_balances[to].tokens_count, value) ) {
		    throw;
		}

		_balances[msg.sender].tokens_count -= value;
		if(_balances[to].init){
			_balances[to].tokens_count += value;
		}
		else{
			addUserToList(to);
			_balances[to] = holderData(value, true);
		}

		Transfer( msg.sender, to, value );
		return true;
	}

	function transferFrom( address from, address to, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		if( _balances[from].tokens_count < value ) {
		    throw;
		}

		if( _approvals[from][msg.sender] < value ) {
		    throw;
		}
		if( !safeToAdd(_balances[to].tokens_count, value) ) {
		    throw;
		}
		// transfer and return true
		_approvals[from][msg.sender] -= value;
		_balances[from].tokens_count -= value;
		if(_balances[to].init){
			_balances[to].tokens_count += value;
		}
		else{
			addUserToList(to);
			_balances[to] = holderData(value, true);
		}

		Transfer( from, to, value );
		return true;
	}

	function approve(address spender, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		_approvals[msg.sender][spender] = value;
		Approval( msg.sender, spender, value );
		return true;
	}

	event Emission(address indexed to, uint256 value, uint256 bet, uint256 coef, uint256 decimals, uint256 cost_token);

	function emission(address player, address partner, uint256 value_bet, uint16 coef_player, uint16 coef_partner) external returns(uint256) {
		if(stop_operation) throw;

		if(listGames[msg.sender].init == false) throw;
		if(player == address(0x0)) throw;
		if(value_bet == 0) throw;

		uint256 decimals_token = 10**uint256(decimals);

		uint256 player_token = ((value_bet*coef_player*decimals_token)/10000)/costOfOneToken;
		if(_balances[player].init){
			_balances[player].tokens_count += player_token;
		}
		else{
			addUserToList(player);
			_balances[player] = holderData(player_token, true);
		}
		Emission(player, player_token, value_bet, coef_player, decimals_token, costOfOneToken);

		uint256 partner_token = 0;
		if(partner != address(0x0)){
			partner_token = ((value_bet*coef_partner*decimals_token)/10000)/costOfOneToken;
			if(_balances[partner].init){
				_balances[partner].tokens_count += partner_token;
			}
			else{
				addUserToList(partner);
				_balances[partner] = holderData(partner_token, true);
			}
			Emission(partner, partner_token, value_bet, coef_partner, decimals_token, costOfOneToken);
		}

		_supply += (player_token+partner_token);

		return player_token;
	}

	//------------------------------------
	// Temporary Tokens
	//------------------------------------
	address[] listAddrTempHolders;
	event TempTokensSend(address indexed recipient, uint256 count, uint256 start, uint256 end);

	function sendTempTokens(address recipient, uint256 count, uint256 period) isManager {
		if(stop_operation) throw;

		if(count==0 || period==0) throw;

		uint256 decimals_token = 10**uint256(decimals);
		count = count*decimals_token;

		if(_balances[fond_wallet].tokens_count < count) throw;
		if(_temp_balance[recipient].tokens_count > 0) throw;

		_temp_balance[recipient] = tempHolderData(count, now, now + period);
		listAddrTempHolders.push(recipient);
		_balances[fond_wallet].tokens_count -= count;
		TempTokensSend(recipient, count, _temp_balance[recipient].start_date, _temp_balance[recipient].end_date);
	}

	function tempTokensBalanceOf( address who ) external constant returns (uint256) {
		//tempHolderData data_holder = __temp_balance[who];
		if(_temp_balance[who].end_date < now) return 0;
		else return _temp_balance[who].tokens_count;
	}

	function tempTokensPeriodOf( address who ) external constant returns (uint256) {
		if(_temp_balance[who].end_date < now) return 0;
		else return _temp_balance[who].end_date;
	}

	function returnTempTokens(address recipient) isManager {
		if(stop_operation) throw;

		if(_temp_balance[recipient].tokens_count == 0) throw;

		_balances[fond_wallet].tokens_count += _temp_balance[recipient].tokens_count;
		_temp_balance[recipient] = tempHolderData(0, 0, 0);
	}

	function getListTempHolders() constant returns(address[]){
		return listAddrTempHolders;
	}

	function getCountTempHolders() external constant returns(uint256){
		return listAddrTempHolders.length;
	}

	function getItemTempHolders(uint256 index) external constant returns(address){
		if(index >= listAddrTempHolders.length) return address(0x0);
		else return listAddrTempHolders[index];
	}

	//------------------------------------
	// Invest Functions
	//------------------------------------
	/*event SuccessProfitSend(address indexed holder, uint value);
	event FailProfitSend(address indexed holder, uint value);*/

	function() payable
	{
		if(stop_operation) throw;
		if(msg.sender == developer) throw;
		if(msg.sender == manager) throw;
		if(msg.sender == developer_wallet) throw;
		if(msg.sender == wallet_ICO) throw;
		if(msg.sender == fond_wallet) throw;

		if(listGames[msg.sender].init) throw;

		if(enableICO == false) throw;

		if(msg.value < min_value_buyToken) throw;

		uint256 value_send = msg.value;
		if(value_send > max_value_buyToken){
			value_send = max_value_buyToken;
			if(msg.sender.send(msg.value-max_value_buyToken)==false) throw;
		}

		uint256 decimals_token = 10**uint256(decimals);

		uint256 count_tokens = (value_send*decimals_token)/costOfOneToken;

		if(count_tokens >_balances[wallet_ICO].tokens_count ){
			count_tokens = _balances[wallet_ICO].tokens_count;
		}
		if(value_send > (count_tokens*costOfOneToken)/decimals_token){
			if(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;
			value_send = value_send - ((count_tokens*costOfOneToken)/decimals_token);
		}

		if(!_balances[msg.sender].init){
			addUserToList(msg.sender);
			_balances[wallet_ICO].tokens_count -= count_tokens;
			_balances[msg.sender] = holderData(count_tokens, true);
		}
		else{
			if(((_balances[msg.sender].tokens_count*costOfOneToken)/decimals_token)+((count_tokens*costOfOneToken)/decimals_token)>max_value_buyToken) {
				count_tokens = ((max_value_buyToken*decimals_token)/costOfOneToken)-_balances[msg.sender].tokens_count;
				if(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;
				value_send = ((count_tokens*costOfOneToken)/decimals_token);
			}

			_balances[wallet_ICO].tokens_count -= count_tokens;
			_balances[msg.sender].tokens_count += count_tokens;
		}

		if(value_send>0){
			if(wallet_ICO.send(value_send)==false) throw;
		}

		if(count_tokens>0){
			TokenBuy(msg.sender, count_tokens);
		}

		if(_balances[wallet_ICO].tokens_count == 0){
			enableICO = false;
		}
	}

	function getListAddressHolders() constant returns(address[]){
		return listAddrHolders;
	}

	function getCountHolders() external constant returns(uint256){
		return listAddrHolders.length;
	}

	function getItemHolders(uint256 index) external constant returns(address){
		if(index >= listAddrHolders.length) return address(0x0);
		else return listAddrHolders[index];
	}
}",S
0xac44b0c61c20c5063e22d3a0ff67f13afdfed103,Safe,"pragma solidity ^0.4.2;

// ----------------------------------------------------------------------------------------------
// Basic ERC20 Token Contract For **TESTING ONLY** on Testnet or Dev blockchain.
//
// Enjoy. (c) Bok Consulting Pty Ltd 2016. The MIT Licence.
// ----------------------------------------------------------------------------------------------

// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/issues/20
contract ERC20Interface {

    // Get the total token supply
    function totalSupply() constant returns (uint256 totalSupply);

    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);

    // Send _value amount of tokens to address _to
    function transfer(address _to, uint256 _value) returns (bool success);

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _value) returns (bool success);

    // Returns the amount which _spender is still allowed to withdraw from _owner
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    // Triggered when tokens are transferred.
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract IncentCoffeeToken is ERC20Interface {

    /* copied from Bok's github - https://github.com/bokkypoobah/TokenTrader/wiki/GNT-%E2%80%90-Golem-Network-Token */
    string public constant name = ""Incent Coffee Token"";
    string public constant symbol = ""INCOF"";
    string public constant wavesAssetId = ""4rmhfoscYcjz1imNDvtz45doouvrQqDpbX7xdfLB4guF"";
    uint8 public constant decimals = 0;  // 0 decimal places, the same as tokens on Wave

    // Owner of this contract
    address public owner;

    // Balances for each account
    mapping(address => uint256) balances;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    // Total supply
    uint256 _totalSupply;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    // Constructor
    function IncentCoffeeToken() {

        _totalSupply = 824;
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    // What is the balance of a particular account?
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to ""deposit"" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) returns (bool success) {

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }


}

contract WavesEthereumSwap is IncentCoffeeToken {

 event WavesTransfer(address indexed _from, string indexed wavesAddress, uint256 amount);

 function moveToWaves(string wavesAddress, uint256 amount) {

     if (!transfer(owner, amount)) throw;
     WavesTransfer(msg.sender, wavesAddress, amount);

 }

}",S
0x7dd8d4c556d2005c5bafc3d5449a99fb46279e6b,Safe,"pragma solidity ^0.4.8;

contract SmartRouletteToken {
	//Tokens data
	string public standard = 'ERC20';
    string public name;
    string public symbol;
    uint8 public decimals;

	struct holderData {
		uint256 tokens_count;
		bool init;
	}

	struct tempHolderData {
		uint256 tokens_count;
		uint256 start_date;
		uint256 end_date;
	}

	address[] listAddrHolders;

	mapping( address => holderData ) _balances;
	mapping( address => tempHolderData ) _temp_balance;
	mapping( address => mapping( address => uint256 ) ) _approvals;

	bool stop_operation;

	uint256 _supply;
	uint256 _init_count_tokens;
	uint256 public costOfOneToken; //the cost of one token in wei

	address wallet_ICO;
	bool enableICO;
	uint256 min_value_buyToken; //in wei
	uint256 max_value_buyToken; //in wei

	address fond_wallet;
	address developer_wallet;

	address divident_contract = address(0x0);

	event TokenBuy(address buyer, uint256 amountOfTokens);

    //Contract data
	address developer;
	address manager;

	struct gamesData {
		bool init;
	}

	mapping( address => gamesData) listGames;
	address[] addrGames;


	function SmartRouletteToken()
	{
		_supply = 100000000000000000;
		_init_count_tokens = 100000000000000000;

		developer_wallet = address(0x8521E1f9220A251dE0ab78f6a2E8754Ca9E75242);
		_balances[developer_wallet] = holderData((_supply*20)/100, true);

		wallet_ICO = address(0x2dff87f8892d65f7a97b1287e795405098ae7b7f);
		_balances[wallet_ICO] = holderData((_supply*60)/100, true);

		fond_wallet = address(0x3501DD2B515EDC1920f9007782Da5ac018922502);
		_balances[fond_wallet] = holderData((_supply*20)/100, true);

		listAddrHolders.push(developer_wallet);
		listAddrHolders.push(wallet_ICO);
		listAddrHolders.push(fond_wallet);

        name = 'Roulette Token';
        symbol = 'RLT';
        decimals = 10;
        costOfOneToken = 1500000000000000;

		developer = msg.sender;
		manager = msg.sender;

		enableICO = false;
		min_value_buyToken = 1000000000000000000;
		max_value_buyToken = 500000000000000000000;

		stop_operation = false;
	}

	modifier isDeveloper(){
		if (msg.sender!=developer) throw;
		_;
	}

	modifier isManager(){
		if (msg.sender!=manager && msg.sender!=developer) throw;
		_;
	}

	modifier isAccessStopOperation(){
		if (msg.sender!=manager && msg.sender!=developer && (msg.sender!=divident_contract || divident_contract==address(0x0))) throw;
		_;
	}

	function changeDeveloper(address new_developer)
	isDeveloper
	{
		if(new_developer == address(0x0)) throw;
		developer = new_developer;
	}

	function changeManager(address new_manager)
	isDeveloper
	{
		if(new_manager == address(0x0)) throw;
		manager = new_manager;
	}

	function changeDividentContract(address new_contract) isManager
	{
		if(divident_contract!=address(0x0)) throw;
		if(divident_contract==address(0x0)) throw;
		divident_contract = new_contract;
	}

	function newCostToken(uint256 new_cost)
	isManager
	{
		if(new_cost == 0) throw;
		costOfOneToken = new_cost;
	}

	function getostToken() external constant returns(uint256)
	{
		return costOfOneToken;
	}

	function addNewGame(address new_game)
	isManager
	{
		if(new_game == address(0x0)) throw;
		listGames[new_game] = gamesData(true);
		addrGames.push(new_game);
	}

	function deleteGame(address game)
	isManager
	{
		if(game == address(0x0)) throw;
		if(listGames[game].init){
			listGames[game].init = false;
		}
	}

	function kill() isDeveloper {
		/*uint256 token_price = this.balance/_supply;
		for(uint256 i = 0; i < listAddrHolders.length; i++){
			if(_balances[listAddrHolders[i]].tokens_count>0){
				if(listAddrHolders[i].send(token_price*_balances[listAddrHolders[i]].tokens_count)==false){ throw; }
				else{
					_balances[listAddrHolders[i]].tokens_count = 0;
				}
			}
		}*/
		suicide(developer);
	}

	function getListGames() constant returns(address[]){
		return addrGames;
	}

	function addUserToList(address user) internal {
		if(!_balances[user].init){
			listAddrHolders.push(user);
		}
	}

	function gameListOf( address who ) external constant returns (bool value) {
		gamesData game_data = listGames[who];
		return game_data.init;
	}

	//------------------------------------
	// Tokens Functions
	//------------------------------------
	event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function stopOperation() isAccessStopOperation {
		stop_operation = true;
	}

	function startOperation() isAccessStopOperation {
		stop_operation = false;
	}

	function statusOperation() constant returns (bool){
		return stop_operation;
	}

	function runICO() isManager {
		enableICO = true;
	}

	function stopICO() isManager {
		enableICO = false;
	}

	function infoICO() constant returns (bool){
		return enableICO;
	}

	function totalSupply() constant returns (uint256 supply) {
		return _supply;
	}

	function initCountTokens() constant returns (uint256 init_count) {
		return _init_count_tokens;
	}

	function balanceOf( address who ) external constant returns (uint256 value) {
		//holderData data_holder = _balances[who];
		return _balances[who].tokens_count;
	}

	function allowance(address owner, address spender) constant returns (uint256 _allowance) {
		return _approvals[owner][spender];
	}

	// overflow check
	function safeToAdd(uint256 a, uint256 b) internal returns (bool) {
		return (a + b >= a && a + b >= b);
	}

	function transfer( address to, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		if( _balances[msg.sender].tokens_count < value ) {
		    throw;
		}
		if( !safeToAdd(_balances[to].tokens_count, value) ) {
		    throw;
		}

		_balances[msg.sender].tokens_count -= value;
		if(_balances[to].init){
			_balances[to].tokens_count += value;
		}
		else{
			addUserToList(to);
			_balances[to] = holderData(value, true);
		}

		Transfer( msg.sender, to, value );
		return true;
	}

	function transferFrom( address from, address to, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		if( _balances[from].tokens_count < value ) {
		    throw;
		}

		if( _approvals[from][msg.sender] < value ) {
		    throw;
		}
		if( !safeToAdd(_balances[to].tokens_count, value) ) {
		    throw;
		}
		// transfer and return true
		_approvals[from][msg.sender] -= value;
		_balances[from].tokens_count -= value;
		if(_balances[to].init){
			_balances[to].tokens_count += value;
		}
		else{
			addUserToList(to);
			_balances[to] = holderData(value, true);
		}

		Transfer( from, to, value );
		return true;
	}

	function approve(address spender, uint256 value) returns (bool ok) {
		if(stop_operation) throw;

		_approvals[msg.sender][spender] = value;
		Approval( msg.sender, spender, value );
		return true;
	}

	event Emission(address indexed to, uint256 value, uint256 bet, uint256 coef, uint256 decimals, uint256 cost_token);

	function emission(address player, address partner, uint256 value_bet, uint16 coef_player, uint16 coef_partner) external returns(uint256) {
		if(stop_operation) throw;

		if(listGames[msg.sender].init == false) throw;
		if(player == address(0x0)) throw;
		if(value_bet == 0) throw;

		uint256 decimals_token = 10**uint256(decimals);

		uint256 player_token = ((value_bet*coef_player*decimals_token)/10000)/costOfOneToken;
		if(_balances[player].init){
			_balances[player].tokens_count += player_token;
		}
		else{
			addUserToList(player);
			_balances[player] = holderData(player_token, true);
		}
		Emission(player, player_token, value_bet, coef_player, decimals_token, costOfOneToken);

		uint256 partner_token = 0;
		if(partner != address(0x0)){
			partner_token = ((value_bet*coef_partner*decimals_token)/10000)/costOfOneToken;
			if(_balances[partner].init){
				_balances[partner].tokens_count += partner_token;
			}
			else{
				addUserToList(partner);
				_balances[partner] = holderData(partner_token, true);
			}
			Emission(partner, partner_token, value_bet, coef_partner, decimals_token, costOfOneToken);
		}

		_supply += (player_token+partner_token);

		return player_token;
	}

	//------------------------------------
	// Temporary Tokens
	//------------------------------------
	address[] listAddrTempHolders;
	event TempTokensSend(address indexed recipient, uint256 count, uint256 start, uint256 end);

	function sendTempTokens(address recipient, uint256 count, uint256 period) isManager {
		if(!stop_operation) throw;

		if(count==0 || period==0) throw;

		uint256 decimals_token = 10**uint256(decimals);
		count = count*decimals_token;

		if(_balances[fond_wallet].tokens_count < count) throw;
		if(_temp_balance[recipient].tokens_count > 0) throw;

		_temp_balance[recipient] = tempHolderData(count, now, now + period);
		listAddrTempHolders.push(recipient);
		_balances[fond_wallet].tokens_count -= count;
		TempTokensSend(recipient, count, _temp_balance[recipient].start_date, _temp_balance[recipient].end_date);
	}

	function tempTokensBalanceOf( address who ) external constant returns (uint256) {
		//tempHolderData data_holder = __temp_balance[who];
		if(_temp_balance[who].end_date < now) return 0;
		else return _temp_balance[who].tokens_count;
	}

	function tempTokensPeriodOf( address who ) external constant returns (uint256) {
		if(_temp_balance[who].end_date < now) return 0;
		else return _temp_balance[who].end_date;
	}

	function returnTempTokens(address recipient) isManager {
		if(!stop_operation) throw;

		if(_temp_balance[recipient].tokens_count == 0) throw;

		_balances[fond_wallet].tokens_count += _temp_balance[recipient].tokens_count;
		_temp_balance[recipient] = tempHolderData(0, 0, 0);
	}

	function getListTempHolders() constant returns(address[]){
		return listAddrTempHolders;
	}

	function getCountTempHolders() external constant returns(uint256){
		return listAddrTempHolders.length;
	}

	function getItemTempHolders(uint256 index) external constant returns(address){
		if(index >= listAddrTempHolders.length) return address(0x0);
		else return listAddrTempHolders[index];
	}

	//------------------------------------
	// Invest Functions
	//------------------------------------
	/*event SuccessProfitSend(address indexed holder, uint value);
	event FailProfitSend(address indexed holder, uint value);*/

	function() payable
	{
		if(!stop_operation) throw;
		if(msg.sender == developer) throw;
		if(msg.sender == manager) throw;
		if(msg.sender == developer_wallet) throw;
		if(msg.sender == wallet_ICO) throw;
		if(msg.sender == fond_wallet) throw;

		/*if(listGames[msg.sender].init){
			uint256 profit_one_token = (msg.value+this.balance)/_supply;
			for(uint256 i = 0; i < listAddrHolders.length; i++){
				if(_balances[listAddrHolders[i]].tokens_count>0){
					if(listAddrHolders[i].send(profit_one_token*_balances[listAddrHolders[i]].tokens_count)){
						SuccessProfitSend(listAddrHolders[i], profit_one_token*_balances[listAddrHolders[i]].tokens_count);
					}
					else{
						FailProfitSend(listAddrHolders[i], profit_one_token*_balances[listAddrHolders[i]].tokens_count);
					}
				}
			}
		}*/
		if(listGames[msg.sender].init) throw;

		if(enableICO == false) throw;

		if(msg.value < min_value_buyToken) throw;

		uint256 value_send = msg.value;
		if(value_send > max_value_buyToken){
			value_send = max_value_buyToken;
			if(msg.sender.send(msg.value-max_value_buyToken)==false) throw;
		}

		uint256 decimals_token = 10**uint256(decimals);

		uint256 count_tokens = (value_send*decimals_token)/costOfOneToken;

		if(count_tokens >_balances[wallet_ICO].tokens_count ){
			count_tokens = _balances[wallet_ICO].tokens_count;
		}
		if(value_send > (count_tokens*costOfOneToken)/decimals_token){
			if(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;
			value_send = value_send - ((count_tokens*costOfOneToken)/decimals_token);
		}

		if(!_balances[msg.sender].init){
			addUserToList(msg.sender);
			_balances[wallet_ICO].tokens_count -= count_tokens;
			_balances[msg.sender] = holderData(count_tokens, true);
		}
		else{
			if(((_balances[msg.sender].tokens_count*costOfOneToken)/decimals_token)+((count_tokens*costOfOneToken)/decimals_token)>max_value_buyToken) {
				count_tokens = ((max_value_buyToken*decimals_token)/costOfOneToken)-_balances[msg.sender].tokens_count;
				if(msg.sender.send(value_send-((count_tokens*costOfOneToken)/decimals_token))==false) throw;
				value_send = ((count_tokens*costOfOneToken)/decimals_token);
			}

			_balances[wallet_ICO].tokens_count -= count_tokens;
			_balances[msg.sender].tokens_count += count_tokens;
		}

		if(value_send>0){
			if(wallet_ICO.send(value_send)==false) throw;
		}

		if(count_tokens>0){
			TokenBuy(msg.sender, count_tokens);
		}

		if(_balances[wallet_ICO].tokens_count == 0){
			enableICO = false;
		}
	}

	function getListAddressHolders() constant returns(address[]){
		return listAddrHolders;
	}

	function getCountHolders() external constant returns(uint256){
		return listAddrHolders.length;
	}

	function getItemHolders(uint256 index) external constant returns(address){
		if(index >= listAddrHolders.length) return address(0x0);
		else return listAddrHolders[index];
	}
}",S
0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5,Safe,"// This multisignature wallet is based on the wallet contract by Gav Wood.
// Only one single change was made: The contract creator is not automatically one of the wallet owners.

//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
pragma solidity ^0.4.6;

contract multisig {
    // EVENTS

    // this contract can accept a confirmation, in which case
    // we record owner and operation (hash) alongside it.
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);

    // some others are in the case of an owner changing.
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);

    // the last one is emitted if the required signatures change
    event RequirementChanged(uint newRequirement);

    // Funds has arrived into the wallet (record how much).
    event Deposit(address _from, uint value);
    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
    event SingleTransact(address owner, uint value, address to, bytes data);
    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
    // Confirmation still needed for a transaction.
    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
}

contract multisigAbi is multisig {
    function isOwner(address _addr) returns (bool);

    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool);

    function confirm(bytes32 _h) returns(bool);

    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit);

    function addOwner(address _owner);

    function removeOwner(address _owner);

    function changeRequirement(uint _newRequired);

    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation);

    function changeOwner(address _from, address _to);

    function execute(address _to, uint _value, bytes _data) returns(bool);
}

contract WalletLibrary is multisig {
    // TYPES

    // struct for the status of a pending operation.
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

    // Transaction structure to remember details of transaction lest it need be saved for a later call.
    struct Transaction {
        address to;
        uint value;
        bytes data;
    }

    /******************************
     ***** MULTI OWNED SECTION ****
     ******************************/

    // MODIFIERS

    // simple single-sig function modifier.
    modifier onlyowner {
        if (isOwner(msg.sender))
            _;
    }
    // multi-sig function modifier: the operation must have an intrinsic hash in order
    // that later attempts can be realised as the same underlying operation and
    // thus count as confirmations.
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _;
    }

    // METHODS

    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
    // as well as the selection of addresses capable of confirming them.
    // change from original: msg.sender is not automatically owner
    function initMultiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length ;
        m_required = _required;

        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[1 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 1 + i;
        }
    }

    // Revokes a prior confirmation of the given operation
    function revoke(bytes32 _operation) {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }

    // Replaces an owner `_from` with another `_to`.
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }

    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }

    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
        OwnerRemoved(_owner);
    }

    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }

    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }


    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        // make sure they're an owner
        if (ownerIndex == 0) return false;

        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        return !(pending.ownersDone & ownerIndexBit == 0);
    }

    // INTERNAL METHODS

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        // determine what index the present sender is:
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        // make sure they're an owner
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        // if we're not yet working on this operation, switch over and reset the confirmation status.
        if (pending.yetNeeded == 0) {
            // reset count of confirmations needed.
            pending.yetNeeded = m_required;
            // reset which owners have confirmed (none) - set our bitmap to 0.
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        // determine the bit to set for this owner.
        uint ownerIndexBit = 2**ownerIndex;
        // make sure we (the message sender) haven't confirmed this operation previously.
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1) {
                // enough confirmations: reset and run interior.
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                // not enough: record that this owner in particular confirmed.
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }

    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }


    /******************************
     ****** DAY LIMIT SECTION *****
     ******************************/

    // MODIFIERS

    // simple modifier for daily limit.
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _;
    }

    // METHODS

    // constructor - stores initial daily limit and records the present day's index.
    function initDaylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) {
        m_dailyLimit = _newLimit;
    }
    // resets the amount already spent today. needs many of the owners to confirm.
    function resetSpentToday() onlymanyowners(sha3(msg.data)) {
        m_spentToday = 0;
    }

    // INTERNAL METHODS

    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
    // returns true. otherwise just returns false.
    function underLimit(uint _value) internal onlyowner returns (bool) {
        // reset the spend limit if we're on a different day to last time.
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        // check to see if there's enough left - if so, subtract and return true.
        // overflow protection                    // dailyLimit check
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }

    // determines today's index.
    function today() private constant returns (uint) { return now / 1 days; }


    /******************************
     ********* WALLET SECTION *****
     ******************************/

    // METHODS

    // constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function initWallet(address[] _owners, uint _required, uint _daylimit) {
        initMultiowned(_owners, _required);
        initDaylimit(_daylimit) ;
    }

    // kills the contract sending everything to `_to`.
    function kill(address _to) onlymanyowners(sha3(msg.data)) {
        suicide(_to);
    }

    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(address _to, uint _value, bytes _data) onlyowner returns(bool _callValue) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _callValue =_to.call.value(_value)(_data);
        } else {
            // determine our operation hash.
            bytes32 _r = sha3(msg.data, block.number);
            if (!confirm(_r) && m_txs[_r].to == 0) {
                m_txs[_r].to = _to;
                m_txs[_r].value = _value;
                m_txs[_r].data = _data;
                ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
            }
        }
    }

    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
    // to determine the body of the transaction from the hash provided.
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }

    // INTERNAL METHODS

    function clearWalletPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingIndex[i]];
        clearPending();
    }

    // FIELDS
    address constant _walletLibrary = 0x4f2875f631f4fc66b8e051defba0c9f9106d7d5a;

    // the number of owners that must confirm the same operation before it is run.
    uint m_required;
    // pointer used to find a free slot in m_owners
    uint m_numOwners;

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;

    // list of owners
    uint[256] m_owners;
    uint constant c_maxOwners = 250;

    // index on the list of owners to allow reverse lookup
    mapping(uint => uint) m_ownerIndex;
    // the ongoing operations.
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;

    // pending transactions we have at present.
    mapping (bytes32 => Transaction) m_txs;
}


contract Wallet is multisig {

    // WALLET CONSTRUCTOR
    //   calls the `initWallet` method of the Library in this context
    function Wallet(address[] _owners, uint _required, uint _daylimit) {
        // Signature of the Wallet Library's init function
        bytes4 sig = bytes4(sha3(""initWallet(address[],uint256,uint256)""));
        address target = _walletLibrary;

        // Compute the size of the call data : arrays has 2
        // 32bytes for offset and length, plus 32bytes per element ;
        // plus 2 32bytes for each uint
        uint argarraysize = (2 + _owners.length);
        uint argsize = (2 + argarraysize) * 32;

        assembly {
            // Add the signature first to memory
            mstore(0x0, sig)
            // Add the call data, which is at the end of the
            // code
            codecopy(0x4,  sub(codesize, argsize), argsize)
            // Delegate call to the library
            delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)
        }
    }

    // METHODS

    // gets called when no other function matches
    function() payable {
        // just being sent some cash?
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
        else if (msg.data.length > 0)
            _walletLibrary.delegatecall(msg.data);
    }

    // Gets an owner by 0-indexed position (using numOwners as the count)
    function getOwner(uint ownerIndex) constant returns (address) {
        return address(m_owners[ownerIndex + 1]);
    }

    // As return statement unavailable in fallback, explicit the method here

    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        return _walletLibrary.delegatecall(msg.data);
    }

    function isOwner(address _addr) returns (bool) {
        return _walletLibrary.delegatecall(msg.data);
    }

    // FIELDS
    address constant _walletLibrary = 0x4f2875f631f4fc66b8e051defba0c9f9106d7d5a;

    // the number of owners that must confirm the same operation before it is run.
    uint public m_required;
    // pointer used to find a free slot in m_owners
    uint public m_numOwners;

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;

    // list of owners
    uint[256] m_owners;
}",418: unchecked; 430: unchecked;
0x0f170120733474c6ec7daf6ae6aeeeb8b645e92c,Safe,"pragma solidity ^0.4.6;

contract RES {

    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;

    uint public totalSupply;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);


    /* Bought or sold */

    event Bought(address from, uint amount);
    event Sold(address from, uint amount);

    /* Initializes contract with name, symbol and decimals */

    function RES() {
        name = ""RES"";
        symbol = ""RES"";
        decimals = 18;
    }

    function buy() public payable {
      balanceOf[msg.sender] = msg.value;
      totalSupply += msg.value;
      Bought(msg.sender, msg.value);
    }

}

contract SwarmRedistribution is RES {

    address JohanNygren;

    struct dividendPathway {
      address from;
      uint amount;
      uint timeStamp;
    }

    mapping(address => dividendPathway[]) public dividendPathways;

    mapping(address => uint256) public totalBasicIncome;

    uint taxRate;

    struct Node {
      address node;
      address parent;
      uint index;
    }

    /* Generate a swarm tree */
    Node[] public swarmTree;

    mapping(address => bool) inSwarmTree;

    bool JohanInSwarm;

    event Swarm(address indexed leaf, address indexed node, uint256 share);

    function SwarmRedistribution() {

    /* Tax-rate in parts per thousand */
    taxRate = 20;
    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;
    }

    modifier onlyJohan {
      if(msg.sender != JohanNygren) throw;
      _;
    }

    function changeJohanNygrensAddress(address _newAddress) onlyJohan {
      JohanNygren = _newAddress;
    }


    function sell(uint256 _value) public {
      if(balanceOf[msg.sender] < _value) throw;
      balanceOf[msg.sender] -= _value;

      totalSupply -= _value;
      Sold(msg.sender, _value);

    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        /* reject transaction to self to prevent dividend pathway loops*/
        if(_to == msg.sender) throw;

        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;

        /* Calculate tax */
        uint256 taxCollected = _value * taxRate / 1000;
        uint256 sentAmount;

        /* Create the dividend pathway */
        dividendPathways[_to].push(dividendPathway({
                                        from: msg.sender,
                                        amount:  _value,
                                        timeStamp: now
                                      }));

        if(swarmRedistribution(_to, taxCollected) == true) {
          sentAmount = _value;
        }
        else {
          /* Return tax */
          sentAmount = _value - taxCollected;
        }

          /* Add and subtract new balances */

          balanceOf[msg.sender] -= sentAmount;
          balanceOf[_to] += _value - taxCollected;


        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, sentAmount);
    }

    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {
           iterateThroughSwarm(_to, now);
           if(swarmTree.length != 0) {
           return doSwarm(_to, _taxCollected);
           }
           else return false;
      }

    function iterateThroughSwarm(address _node, uint _timeStamp) internal {
      if(dividendPathways[_node].length != 0) {
        for(uint i = 0; i < dividendPathways[_node].length; i++) {
          if(inSwarmTree[dividendPathways[_node][i].from] == false) {

            uint timeStamp = dividendPathways[_node][i].timeStamp;
            if(timeStamp <= _timeStamp) {

              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;

                Node memory node = Node({
                            node: dividendPathways[_node][i].from,
                            parent: _node,
                            index: i
                          });

                  swarmTree.push(node);
                  iterateThroughSwarm(node.node, timeStamp);
              }
          }
        }
      }
    }

    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {

      uint256 share;
      if(JohanInSwarm) share = _taxCollected;
      else share = 0;

      for(uint i = 0; i < swarmTree.length; i++) {

        address node = swarmTree[i].node;
        address parent = swarmTree[i].parent;
        uint index = swarmTree[i].index;

        bool isJohan;
        if(node == JohanNygren) isJohan = true;

        if(isJohan) {
          balanceOf[swarmTree[i].node] += share;
        totalBasicIncome[node] += share;
        }

        if(dividendPathways[parent][index].amount - _taxCollected > 0) {
          dividendPathways[parent][index].amount -= _taxCollected;
        }
        else removeDividendPathway(parent, index);

        /* Notifiy anyone listening that this swarm took place */
        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);
      }
      delete swarmTree;
      bool JohanWasInSwarm = JohanInSwarm;
      delete JohanInSwarm;

      if(!JohanWasInSwarm) return false;
      return true;
    }

    function removeDividendPathway(address node, uint index) internal {
                delete dividendPathways[node][index];
                for (uint i = index; i < dividendPathways[node].length - 1; i++) {
                        dividendPathways[node][i] = dividendPathways[node][i + 1];
                }
                dividendPathways[node].length--;
        }

}",34: arithmetic;
0x4671ebe586199456ca28ac050cc9473cbac829eb,Safe,"contract Mortal {
        address public owner;
        function mortal() { owner = msg.sender; }
        function kill() { if (msg.sender == owner) suicide(owner); }
}

contract Thing is Mortal {
        enum Mood { Agree, Disagree, Funny, Sad, Angry, Nothing }
        // URL of the reaction - optional
        string public url;
        // Content of the reaction - optional
        string public data;
        // MIME type of the content - optional, default is text/plain
        string public mimetype;
        // Mood of the reaction - Mood.Nothing by default
        Mood public mood;
        Thing[] public reactions;

        function thing( string _url
                          , string _data
                          , Mood _mood
                          , string _mimetype) {
                url = _url;
                data = _data;
                mimetype = _mimetype;
                mood = _mood;
        }

        function react(Thing reaction) {
                if (msg.sender != reaction.owner()) throw;

                reactions.push(reaction);
        }

        function withdraw() {
                if (msg.sender != owner) throw;

                owner.send(this.balance);
        }
}",38: unchecked;
0xd7bf41bbc8979b3821851b871f055f4ae62b2299,Safe,"/*
    This contracts holds the JamCoin.
*/


contract JamCoin {
    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function JamCoin() {
        /* Unless you add other functions these variables will never change */
        balanceOf[msg.sender] = 10000;
        name = ""Jam Coin"";
        symbol = ""5ea56e7bfd92b168fc18e421da0088bf"";
        decimals = 2;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        /* if the sender doenst have enough balance then stop */
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;

        /* Add and subtract new balances */
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        /* Notifiy anyone listening that this transfer took place */
        Transfer(msg.sender, _to, _value);
    }
}",S
0xde5ebd0b8879b0a42b23b37e4d76a5e21a0bef4b,Safe,"/* This contract is the API for blockchain2email.com,
   which allows you to send emails from your smart contract.
   Check out http://blockchain2email.com/ fpr info on how to
   include API reference into your contract.

   Version 1.1      */


contract depletable {
    address owner;
    function depletable() {
        owner = msg.sender;
    }
    function withdraw() {
        if (msg.sender == owner) {
            while(!owner.send(this.balance)){}
        }
    }
}

contract blockchain2email is depletable {
	event EmailSent(address Sender, string EmailAddress, string Message);

	function SendEmail(string EmailAddress, string Message) returns (bool) {
		if(msg.value>999999999999999){
			EmailSent(msg.sender, EmailAddress, Message);
			return (true);
		}else{
		    while(!msg.sender.send(msg.value)){}
		    return (false);
		}
    }
}",S
0xf9ac5e26d7ec113f42b18c78c05fab68181adfbf,Safe,"// The contract that allows DTH that held DAO at a contract address to
// authorize an enduser-account to do the withdrawal for them
//
// License: BSD3

contract WHAuthorizeAddress {

    modifier noEther() {if (msg.value > 0) throw; _}

    event Authorize(address indexed dthContract, address indexed authorizedAddress);

    /// @notice Authorizes a regular account to act on behalf of a contract
    /// @param _authorizedAddress The address of the regular account that will
    ///                           act on behalf of the msg.sender contract.
    function authorizeAddress(address _authorizedAddress) noEther() {

        // sender must be a contract and _authorizedAddress must be a user account
        if  (getCodeSize(msg.sender) == 0 || getCodeSize(_authorizedAddress) > 0) {
            throw;
        }

        Authorize(msg.sender, _authorizedAddress);
    }

    function() {
        throw;
    }

    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }
}",S
0xc70fd22c9821006fb469e4ed14324a991d0296cc,Safe,"contract AssetStorage {
    function addTrustedIssuer(address addr, string name);
    function removeTrustedIssuer(address addr, string name);
    function assertFact(uint id, string fact);
}

contract KittenRegistry is AssetStorage {
   address owner;
   modifier onlyowner { if(msg.sender == owner) _ }

   struct KittenAuthority {
       string name;
       bool trusted;
       uint timestamp;
   }
   struct KittenFact {
       address issuer;
       bool trusted;
       string fact;
       uint timestamp;
   }

   mapping(address => KittenAuthority) authorities;
   mapping(uint => KittenFact[]) facts;
   mapping(uint => uint) factCounts;
   uint totalKittens;

   function KittenRegistry() {
       owner = msg.sender;
   }
   function addTrustedIssuer(address addr, string name) onlyowner {
       authorities[addr] = KittenAuthority({ name: name, timestamp: now, trusted: true });
   }
   function removeTrustedIssuer(address addr, string name) onlyowner {
       delete authorities[addr];
   }
   function assertFact(uint id /* kittenId */, string fact) {
       if(facts[id].length == 0) {
           totalKittens++;
       }
       factCounts[id] = facts[id].push(KittenFact({
           issuer: msg.sender,
           trusted: authorities[msg.sender].trusted,
           timestamp: now,
           fact: fact
       }));
   }
}",S
0x50c5712624b58905c19aee87deca593a2690e3f4,Safe,"contract Docsign
{
    //Fire when document hash is added to contract
    event Added(address indexed _from);

    //Fire when contract is deployed on the blockchain
    event Created(address indexed _from);


    struct Document {
        uint version;
        string name;
        address creator;
        string hash;
        uint date;
    }
    Document[] public a_document;
    uint length;

    // Constructor. Can be used to track contract deployment
    function Docsign() {
        Created(msg.sender);
    }

    function Add(uint _version, string _name, string _hash) {
        a_document.push(Document(_version,_name,msg.sender, _hash, now));
        Added(msg.sender);
    }
    // Get number of element in Array a_document (does not used GAS)
    function getCount() public constant returns(uint) {
        return a_document.length;
    }

    // fallback function (send back ether if contrat is used as wallet contract)
    function() { throw; }

}",S
0x5d951e9377ec3383808d842fb37182c1363ca34b,Safe,"pragma solidity ^0.4.4;

contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}




contract BananaBasket is mortal {
    event HistoryUpdated(string picId, uint[] result);
    address _owner;

    struct BasketState
    {
        //string picHash;
        mapping (uint=>uint) ratings;
    }

    mapping (string=>BasketState) basketStateHistory;



    function BananaBasket()
    {
        _owner = msg.sender;
    }

    function addNewState(string id, uint[] memory ratings)
    {
        basketStateHistory[id] = BasketState();

        for (var index = 0;  index < ratings.length; ++index) {
            basketStateHistory[id].ratings[index + 1] = ratings[index];
        }

        HistoryUpdated(id, ratings);
    }



    function getHistory(string id) constant
    returns(uint[5] ratings)
    {
        //pichash = id;
        for (var index = 0;  index < 5; ++index) {
            ratings[index] = basketStateHistory[id].ratings[index + 1];
        }
    }
}",S
0xbD37672116c2F4C14BA5a23921BDC57860e64Aa0,Safe,"contract WavesPresale {
    address public owner;

    struct Sale
    {
        uint amount;
        uint date;
    }

    mapping (bytes16 => Sale) public sales;
    uint32 public numberOfSales;
    uint public totalTokens;

    function WavesPresale() {
        owner = msg.sender;
        numberOfSales = 0;
    }

    function changeOwner(address newOwner) {
        if (msg.sender != owner) return;

        owner = newOwner;
    }

    function newSale(bytes16 txidHash, uint amount, uint timestamp) {
        if (msg.sender != owner) return;

        sales[txidHash] = Sale({
                amount: amount,
                date: timestamp
            });
        numberOfSales += 1;
        totalTokens += amount;
    }

    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {
    	return (sales[txidHash].amount, sales[txidHash].date);
    }

    function () {
        // This function gets executed if a
        // transaction with invalid data is sent to
        // the contract or just ether without data.
        // We revert the send so that no-one
        // accidentally loses money when using the
        // contract.
        throw;
    }

}",S
0x79ec9B050Ec82C31D4fc90FB169d968256C5Cb11,Safe,"contract StakeProver {

    struct info_pair {
        address publisher;
        uint stake; // how much was in the account at the time of transaction
        uint burned; // you can optionally burn Ether by sending it when calling the publish function
        uint timestamp;
    }

    mapping(bytes32 => info_pair) public hash_db;

    function publish(bytes32 hashed_val) {
        if (hash_db[hashed_val].publisher != address(0)) {
            // You can only publish the message once
            throw;
        }
        hash_db[hashed_val].publisher = msg.sender;
        hash_db[hashed_val].stake = msg.sender.balance;
        hash_db[hashed_val].burned = msg.value;
        hash_db[hashed_val].timestamp = now;
    }

   function get_publisher(bytes32 hashed_val) constant returns (address) {
        return hash_db[hashed_val].publisher;
    }

    function get_stake(bytes32 hashed_val) constant returns (uint) {
        return hash_db[hashed_val].stake;
    }

    function get_timestamp(bytes32 hashed_val) constant returns (uint) {
        return hash_db[hashed_val].timestamp;
    }

    function get_burned(bytes32 hashed_val) constant returns (uint) {
        return hash_db[hashed_val].burned;
    }
}",S
0xd39fe1cffd8f070429169b416b7e07f486d553cf,Safe,"contract store {

    address owner;

    uint public contentCount = 0;

    event content(string datainfo, uint indexed version, address indexed sender, uint indexed datatype, uint timespan, uint payment);
    modifier onlyowner { if (msg.sender == owner) _ }

    function store() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo, uint version, uint datatype, uint timespan) {
        //item listing
        if(datatype == 1) {
          //2 weeks listing costs 0,04 USD = 0,004 ether
          if(timespan <= 1209600) {
            if(msg.value < (4 finney)) return;
          //4 weeks listing costs 0,06 USD = 0,006 ether
          } else if(timespan <= 2419200) {
            if(msg.value < (6 finney)) return;
          //limit 4 weeks max
          } else {
            timespan = 2419200;
            if(msg.value < (6 finney)) return;
          }
        }

        //revert higher payment transactions
        if(msg.value > (6 finney)) throw;

        contentCount++;
        content(datainfo, version, msg.sender, datatype, timespan, msg.value);
    }
}",16: unchecked;
0x2f81a082e11ee3ab3b063bb9605affc8e3121926,Safe,"pragma solidity 0.4.4;

contract AddressNames{

	mapping(address => string) addressNames;
	address[] namedAddresses;

	function setName(string name){
		_setNameToAddress(msg.sender,name);
	}

	function hasName(address who) constant returns (bool hasAName){
		hasAName = _hasName(who);
	}

	function getName(address who) constant returns (string name){
		name = addressNames[who];
	}

	function getNamedAddresses() constant returns (address[] addresses){
		addresses = namedAddresses;
	}

	function _setNameToAddress(address who, string name) internal returns (bool valid){
		if (bytes(name).length < 3){
		valid = false;
		}

		if (!_hasName(who)){
			namedAddresses.push(who);
		}
		addressNames[msg.sender] = name;

		valid = true;
	}

	function _hasName(address who) internal returns (bool hasAName){
		hasAName = bytes(addressNames[who]).length != 0;
	}

}",S
0x755cdba6ae4f479f7164792b318b2a06c759833b,Safe,"// Refund contract for extraBalance
// Amounts to be paid are tokenized in another contract and allow using the same refund contract as for theDAO
// Though it may be misleading, the names 'DAO', 'mainDAO' are kept here for the ease of code review

contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
    uint public totalSupply;
}

contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x5c40ef6f527f4fba68368774e6130ce6515123f2);
    address constant public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    /**
    * Return funds back to the curator.
    */
    function clawback() external {
        if (msg.sender != trustee) throw;
        if (!trustee.send(this.balance)) throw;
    }
}",S
0xad2b1feb2153cd5a6b8a5f37a820ba013a89cabf,Safe,"pragma solidity 0.4.4;

contract Reward{

    function reward(uint32[] rewardsDistribution, address[] winners) payable{

        if(rewardsDistribution.length == 0 || rewardsDistribution.length > 64){ // do not risk gas shortage on reward
			throw;
		}
		//ensure rewardsDistribution give always something and do not give more to a lower scoring player
		uint32 prev = 0;
		for(uint8 i = 0; i < rewardsDistribution.length; i++){
			if(rewardsDistribution[i] == 0 ||  (prev != 0 && rewardsDistribution[i] > prev)){
				throw;
			}
			prev = rewardsDistribution[i];
		}

        uint8 numWinners = uint8(rewardsDistribution.length);

		if(numWinners > uint8(winners.length)){
			numWinners = uint8(winners.length);
		}

        uint forJack = msg.value;
		uint64 total = 0;
		for(uint8 j=0; j<numWinners; j++){ // distribute all the winning even if there is not enought winners
			total += rewardsDistribution[j];
		}
		for(uint8 k=0; k<numWinners; k++){
			uint value = (msg.value * rewardsDistribution[k]) / total;
			if(winners[k].send(value)){ // skip winner if fail to send but still use next distribution index
				forJack = forJack - value;
			}
		}

		if(forJack > 0){
		    if(!msg.sender.send(forJack)){
		        throw;
		    }
		}

    }

}",S
0xB19ff6657A80a68c94CA3fe6AAc3B6cfd16bdcD4,Safe,"/*
this smartcontract used to store documents text on the Ethereum blockchain
*/

contract ProofOfExistence{

    /* ---- Public variables: */
    string public created;
    address public manager; // account that adds info to this smartcontract
    uint256 public index;   // record's numbers and number of records
    mapping (uint256 => Doc) public docs; // index => Doc
    // to get Doc obj call ProofOfExistence.docs(index);

    /* ---- Stored document structure: */

    struct Doc {
        string publisher; // publisher's email
        uint256 publishedOnUnixTime; // block timestamp (block.timestamp)
        uint256 publishedInBlockNumber; // block.number
        string text; // text of the document
    }

    /* ---- Constructor: */

    function ProofOfExistence(){
        manager = msg.sender;
        created = ""cryptonomica.net"";
        index = 0; //
    }

    /* ---- Event:  */
    // This generates a public event on the blockchain that will notify clients. In 'Mist' SmartContract page enable 'Watch contract events'
    event DocumentAdded(uint256 indexed index,
                        string indexed publisher,
                        uint256 publishedOnUnixTime,
                        string indexed text);

    /* ----- Main method: */

    function addDoc(string _publisher, string _text) returns (uint256) {
        // authorization
        if (msg.sender != manager) throw;
        // document number
        index += 1;
        // add document data:
        docs[index] = Doc(_publisher, now, block.number, _text);
        // add event
        DocumentAdded(index,
                      docs[index].publisher,
                      docs[index].publishedOnUnixTime,
                      docs[index].text);
        // return number of the stored document
        return index;
    }

    /* ---- Utilities: */

    function () {
        // This function gets executed if a
        // transaction with invalid data is sent to
        // the contract or just ether without data.
        // We revert the send so that no-one
        // accidentally loses money when using the
        // contract.
        throw;
    }

}",S
0x938875f7a161ce2f4c314ba1bb3172dbf52ebb3d,Safe,"pragma solidity ^0.4.0;

contract Presale {
   struct PresaleEntry {
        address ethID;
        string email;
        string bitcoinSRC;
        string bitcoinDEST;
        uint satoshis;
        uint centiWRG;
    }

   PresaleEntry [] public entries ;
   address public master; // master address
   uint public presaleAmount;
   bool public presaleGoing;

   event presaleMade(string sender, uint satoshis);

    /* Initializes contract with initial supply tokens to the creator of the contract */

    function Presale() {
     master = msg.sender;
     presaleAmount = 23970000 * 100; // 6 030 000 was sold to first investors
     presaleGoing = true;
    }

    /* Very simple trade function */

    function makePresale(string mail, address adr, uint satoshis, uint centiWRG,string bitcoinSRC, string bitcoinDEST) returns(bool sufficient) {
        PresaleEntry memory entry;
        int expectedWRG = int(presaleAmount) - int(centiWRG);

        if (!presaleGoing) return;

        if (msg.sender != master) return false;
        if (expectedWRG < 0) return false;

        presaleAmount -= centiWRG;
        entry.ethID = adr;
        entry.email = mail;
        entry.satoshis = satoshis;
        entry.centiWRG = centiWRG;
        entry.bitcoinSRC = bitcoinSRC;
        entry.bitcoinDEST = bitcoinDEST;

        entries.push(entry);

        return true;
     }

     function stopPresale() returns (bool ok) {
          if (msg.sender != master) return false;
          presaleGoing = false;
          return true;
     }

     function getAmountLeft() returns (uint amount){
         return presaleAmount;
     }

     function getPresaleNumber() returns (uint length){
         return entries.length;
     }

     function getPresale(uint i) returns (string,address,uint,uint,string,string){
         uint max = entries.length;
         if (i >= max) {
             return (""NotFound"",0,0,0,"""","""");
         }
         return (entries[i].email,entries[i].ethID, entries[i].satoshis, entries[i].centiWRG,entries[i].bitcoinSRC,entries[i].bitcoinDEST);
     }

}",S
0x9828953884b857380a80d177c38d95aeb42cd34c,Safe,"pragma solidity ^0.4.1;


contract butttoken {
    function butttoken () {}
    function transfer(address _to, uint256 _value) {}
}

contract BetOnHardFork {
    uint hardForkTimeStamp;
    uint betsOverTimeStamp;
    uint weekAfterHardFork;
    uint twoWeeksAfterHardFork;

    uint buttcoinBalance = 500 * 1000;
    uint buttcoinReward = 500 * 1000 / 100;
    uint gasLimitThreshold = 2 * 1000 * 1000;

    struct Bet {
        bool didBet;
        bool bet;
    }

    mapping(address=>Bet) bets;
    uint numYesBets;
    uint numNoBets;

    function BetOnHardFork() {
        hardForkTimeStamp = now + 1 days;
        betsOverTimeStamp = hardForkTimeStamp + 2 days;
        weekAfterHardFork = hardForkTimeStamp +  1 weeks;
        twoWeeksAfterHardFork = weekAfterHardFork + 2 weeks;

        numYesBets = 0;
        numNoBets = 0;
    }

    function isBetPossible( bool willSucceed ) constant returns(bool) {
        if( now > betsOverTimeStamp ) return false;

        uint numPossibleBets = buttcoinBalance / buttcoinReward;
        if( willSucceed ) {
            if( numYesBets < numNoBets ) return true;
            if( 1 + numYesBets - numNoBets >= numPossibleBets ) return false;
        }
        else {
            if( numNoBets < numYesBets ) return true;
            if( 1 + numNoBets - numYesBets >= numPossibleBets ) return false;
        }

        return (! bets[msg.sender].didBet);
    }

    function makeBet( bool willSucceed ) {
        if( ! isBetPossible( willSucceed ) ) throw;
        bets[msg.sender].didBet = true;
        bets[msg.sender].bet = willSucceed;
        if( willSucceed ) numYesBets++;
        else numNoBets++;
    }

    function claimReward( ) {
        if( now > twoWeeksAfterHardFork ) throw;
        if( now < weekAfterHardFork ) throw;
        if( ! bets[msg.sender].didBet ) throw;
        bool succ = (block.gaslimit >= gasLimitThreshold );
        bool shouldPay = false;
        if( succ && bets[msg.sender].bet ) shouldPay = true;
        if( ! succ && ! bets[msg.sender].bet ) shouldPay = true;

        if( ! shouldPay ) throw;

        butttoken token = butttoken(0x2a106E06cD26FAD93f732dAa4218fCE4eAC6d6D8);
        token.transfer(msg.sender,buttcoinReward);
    }

}",S
0x6Ba4313d6B01efD3C81224a1d34794B2A0b0CF76,Safe,"/*
**   Signed Digital Asset - A contract to store signatures of digital assets.
**   Martin Stellnberger
**   05-Dec-2016
**   martinstellnberger.co
**
**   This software is distributed in the hope that it will be useful,
**   but WITHOUT ANY WARRANTY; without even the implied warranty of
**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**   GNU lesser General Public License for more details.
**   <http://www.gnu.org/licenses/>.
*/

pragma solidity ^0.4.2;

contract SignedDigitalAsset {
    // The owner of the contract
    address owner = msg.sender;
    // Name of the institution (for reference purposes only)
    string public institution;
    // Storage for linking the signatures to the digital fingerprints
	mapping (bytes32 => string) fingerprintSignatureMapping;

    // Event functionality
	event SignatureAdded(string digitalFingerprint, string signature, uint256 timestamp);
    // Modifier restricting only the owner of this contract to perform certain operations
    modifier isOwner() { if (msg.sender != owner) throw; _; }

    // Constructor of the Signed Digital Asset contract
    function SignedDigitalAsset(string _institution) {
        institution = _institution;
    }
    // Adds a new signature and links it to its corresponding digital fingerprint
	function addSignature(string digitalFingerprint, string signature)
        isOwner {
        // Add signature to the mapping
        fingerprintSignatureMapping[sha3(digitalFingerprint)] = signature;
        // Broadcast the token added event
        SignatureAdded(digitalFingerprint, signature, now);
	}

    // Removes a signature from this contract
	function removeSignature(string digitalFingerprint)
        isOwner {
        // Replaces an existing Signature with empty string
		fingerprintSignatureMapping[sha3(digitalFingerprint)] = """";
	}

    // Returns the corresponding signature for a specified digital fingerprint
	function getSignature(string digitalFingerprint) constant returns(string){
		return fingerprintSignatureMapping[sha3(digitalFingerprint)];
	}

    // Removes the entire contract from the blockchain and invalidates all signatures
    function removeSdaContract()
        isOwner {
        selfdestruct(owner);
    }
}",S
0xb6Db69e99f7E3ccB352FaBde7D98A8FAe0De4297,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract Owned{

    //Address of owner
    address Owner;

    //Add modifier
    modifier OnlyOwner{
        if(msg.sender != Owner){
            throw;
        }
        _
    }

    //Contruction function
    function Owned(){
        Owner = msg.sender;
    }

}

//Ethereum Safely Transfer Contract
//https://github.com/etcrelay/ether-transfer
contract EtherTransfer is Owned{

    //""If you are good at something, never do it for free"" - Joker
    //Fee is 0.05% (it's mean you send 1 ETH fee is 0.0005 ETH)
    //Notice Fee is not include transaction fee
    uint constant Fee = 5;
    uint constant Decs = 10000;

    bool public IsEthereum = false;

    //Events log
    event ETHTransfer(address indexed From,address indexed To, uint Value);
    event ETCReturn(address indexed Return, uint Value);

    event ETCTransfer(address indexed From,address indexed To, uint Value);
    event ETHReturn(address indexed Return, uint Value);

    //Is Vitalik Buterin on the Fork ? >_<
    AmIOnTheFork IsHeOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    //Construction function
    function EtherTransfer(){
        IsEthereum = IsHeOnTheFork.forked();
    }

    //Only send ETH
    function SendETH(address ETHAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is forked chain ETH
        if(IsEthereum && ETHAddress.send(Value)){
            ETHTransfer(msg.sender, ETHAddress, Value);
            return true;
        }else if(!IsEthereum && msg.sender.send(msg.value)){
            ETCReturn(msg.sender, msg.value);
            return true;
        }
        //No ETC is trapped
        throw;
    }

    //Only send ETC
    function SendETC(address ETCAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is non-forked chain ETC
        if(!IsEthereum && ETCAddress.send(Value)){
            ETCTransfer(msg.sender, ETCAddress, Value);
            return true;
        } else if(IsEthereum && msg.sender.send(msg.value)){
            ETHReturn(msg.sender, msg.value);
            return true;
        }
        //No ETH is trapped
        throw;
    }

    //Protect user from ETC/ETH trapped
    function (){
        throw;
    }

    //I get rich lol, ez
    function WithDraw() OnlyOwner returns(bool){
        if(this.balance > 0 && Owner.send(this.balance)){
            return true;
        }
        throw;
    }

}",S
0xd4fb7fd0c254a8c6211e441f7236fa9479708a99,Safe,"// The contract that allows DTH that held DAO at a contract address to
// authorize an enduser-account to do the withdrawal for them
//
// License: BSD3

contract Owned {
    /// Prevents methods from perfoming any value transfer
    modifier noEther() {if (msg.value > 0) throw; _}
    /// Allows only the owner to call a function
    modifier onlyOwner { if (msg.sender != owner) throw; _ }

    address owner;

    function Owned() { owner = msg.sender;}



    function changeOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }

    function getOwner() noEther constant returns (address) {
        return owner;
    }
}

contract WHAuthorizeAddress is Owned {

    bool isClosed;

    mapping (address => bool) usedAddresses;

    event Authorize(address indexed dthContract, address indexed authorizedAddress);

    function WHAuthorizeAddress () {
        isClosed = false;
    }

    /// @notice Authorizes a regular account to act on behalf of a contract
    /// @param _authorizedAddress The address of the regular account that will
    ///                           act on behalf of the msg.sender contract.
    function authorizeAddress(address _authorizedAddress) noEther() {

        // after the contract is closed no more authorizations can happen
        if (isClosed) {
            throw;
        }

        // sender must be a contract and _authorizedAddress must be a user account
        if (getCodeSize(msg.sender) == 0 || getCodeSize(_authorizedAddress) > 0) {
            throw;
        }

        // An authorized address can be used to represent only a single contract.
        if (usedAddresses[_authorizedAddress]) {
            throw;
        }
        usedAddresses[_authorizedAddress] = true;

        Authorize(msg.sender, _authorizedAddress);
    }

    function() {
        throw;
    }

    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }

    /// @notice Close the contract. After closing no more authorizations can happen
    function close() noEther onlyOwner {
        isClosed = true;
    }

    function getIsClosed() noEther constant returns (bool) {
        return isClosed;
    }
}",S
0x5a4964bb5fdd3ce646bb6aa020704f7d4db79302,Safe,"pragma solidity ^0.4.0;
contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    /// Create a new ballot with $(_numProposals) different proposals.
    function Ballot(uint8 _numProposals) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    /// Give $(voter) the right to vote on this ballot.
    /// May only be called by $(chairperson).
    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) return;
        voters[voter].weight = 1;
    }

    /// Delegate your vote to the voter $(to).
    function delegate(address to) {
        Voter sender = voters[msg.sender]; // assigns reference
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter delegate = voters[to];
        if (delegate.voted)
            proposals[delegate.vote].voteCount += sender.weight;
        else
            delegate.weight += sender.weight;
    }

    /// Give a single vote to proposal $(proposal).
    function vote(uint8 proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted || proposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = proposal;
        proposals[proposal].voteCount += sender.weight;
    }

    function winningProposal() constant returns (uint8 winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 proposal = 0; proposal < proposals.length; proposal++)
            if (proposals[proposal].voteCount > winningVoteCount) {
                winningVoteCount = proposals[proposal].voteCount;
                winningProposal = proposal;
            }
    }
}",S
0xC4216D17a72BD49E404Fe396bB93c9Cd8Cf3e881,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract Owned{

    //Address of owner
    address Owner;

    //Add modifier
    modifier OnlyOwner{
        if(msg.sender != Owner){
            throw;
        }
        _
    }

    //Contruction function
    function Owned(){
        Owner = msg.sender;
    }

}

//Ethereum Safely Transfer Contract
//https://github.com/etcrelay/ether-transfer
contract EtherTransfer is Owned{

    //""If you are good at something, never do it for free"" - Joker
    //Fee is 0.1% (it's mean you send 1 ETH fee is 0.001 ETH)
    //Notice Fee is not include transaction fee
    uint constant Fee = 1;
    uint constant Decs = 1000;

    bool public IsEthereum = false;

    //Events log
    event ETHTransfer(address indexed From,address indexed To, uint Value);
    event ETCReturn(address indexed Return, uint Value);

    event ETCTransfer(address indexed From,address indexed To, uint Value);
    event ETHReturn(address indexed Return, uint Value);

    //Is Vitalik Buterin on the Fork ? >_<
    AmIOnTheFork IsHeOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    //Construction function
    function EtherTransfer(){
        IsEthereum = IsHeOnTheFork.forked();
    }

    //Only send ETH
    function SendETH(address ETHAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is forked chain ETH
        if(IsEthereum && ETHAddress.send(Value)){
            ETHTransfer(msg.sender, ETHAddress, Value);
            return true;
        }else if(!IsEthereum && msg.sender.send(msg.value)){
            ETCReturn(msg.sender, msg.value);
            return true;
        }
        //No ETC is trapped
        throw;
    }

    //Only send ETC
    function SendETC(address ETCAddress) returns(bool){
        uint Value = msg.value - (msg.value*Fee/Decs);
        //It is non-forked chain ETC
        if(!IsEthereum && ETCAddress.send(Value)){
            ETCTransfer(msg.sender, ETCAddress, Value);
            return true;
        } else if(IsEthereum && msg.sender.send(msg.value)){
            ETHReturn(msg.sender, msg.value);
            return true;
        }
        //No ETH is trapped
        throw;
    }

    //Protect user from ETC/ETH trapped
    function (){
        throw;
    }

    //I get rich lol, ez
    function WithDraw() OnlyOwner returns(bool){
        if(this.balance > 0 && Owner.send(this.balance)){
            return true;
        }
        throw;
    }

}",S
0x6abd2b75ff5f306a4d99bfab1ff84b57bb9d23e7,Safe,"contract ThisExternalAssembly {
    uint public numcalls;
    uint public numcallsinternal;
    uint public numfails;
    uint public numsuccesses;

    address owner;

    event logCall(uint indexed _numcalls, uint indexed _numcallsinternal);

    modifier onlyOwner { if (msg.sender != owner) throw; _ }
    modifier onlyThis { if (msg.sender != address(this)) throw; _ }

    // constructor
    function ThisExternalAssembly() {
        owner = msg.sender;
    }

    function failSend() external onlyThis returns (bool) {
        // storage change + nested external call
        numcallsinternal++;
        owner.send(42);

        // placeholder for state checks
        if (true) throw;

        // never happens in this case
        return true;
    }

    function doCall(uint _gas) onlyOwner {
        numcalls++;

        address addr = address(this);
        bytes4 sig = bytes4(sha3(""failSend()""));

        bool ret;

        // work around `solc` safeguards for throws in external calls
        // https://ethereum.stackexchange.com/questions/6354/
        assembly {
            let x := mload(0x40) // read ""empty memory"" pointer
            mstore(x,sig)

            ret := call(
                _gas, // gas amount
                addr, // recipient account
                0,    // value (no need to pass)
                x,    // input start location
                0x4,  // input size - just the sig
                x,    // output start location
                0x1)  // output size (bool - 1 byte)

            //ret := mload(x) // no return value ever written :/
            mstore(0x40,add(x,0x4)) // just in case, roll the tape
        }

        if (ret) { numsuccesses++; }
        else { numfails++; }

        // mostly helps with function identification if disassembled
        logCall(numcalls, numcallsinternal);
    }

    // will clean-up :)
    function selfDestruct() onlyOwner { selfdestruct(owner); }

    function() { throw; }
}",22: unchecked;
0x9674e9123caf1f74d7f2b8c6823734891c0573d7,Safe,"// `interface` would make a nice keyword ;)
contract TheDaoHardForkOracle {
    // `ran()` manually verified true on both ETH and ETC chains
    function forked() constant returns (bool);
}

// demostrates calling own function in a ""reversible"" manner
/* important lines are marked by multi-line comments */
contract ReversibleDemo {
    // counters (all public to simplify inspection)
    uint public numcalls;
    uint public numcallsinternal;

    address owner;

    // needed for ""naive"" and ""oraclized"" checks
    address constant withdrawdaoaddr = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;
    TheDaoHardForkOracle oracle = TheDaoHardForkOracle(0xe8e506306ddb78ee38c9b0d86c257bd97c2536b3);

    event logCall(uint indexed _numcalls, uint indexed _numcallsinternal);

    modifier onlyOwner { if (msg.sender != owner) throw; _ }
    modifier onlyThis { if (msg.sender != address(this)) throw; _ }

    // constructor (setting `owner` allows later termination)
    function ReversibleDemo() { owner = msg.sender; }

    /* external: increments stack height */
    /* onlyThis: prevent actual external calling */
    function sendIfNotForked() external onlyThis returns (bool) {
        numcallsinternal++;

        /* naive check for ""is this the classic chain"" */
        // guaranteed `true`: enough has been withdrawn already
        //     three million ------> 3'000'000
        if (withdrawdaoaddr.balance < 3000000 ether) {
            /* intentionally not checking return value */
            owner.send(42);
        }

        /* ""reverse"" if it's actually the HF chain */
        if (oracle.forked()) throw;

        // not exactly a ""success"": send() could have failed on classic
        return true;
    }

    // accepts value transfers
    function doCall(uint _gas) onlyOwner {
        numcalls++;

        // if it throws, there won't be any return value on the stack :/
        this.sendIfNotForked.gas(_gas)();

        logCall(numcalls, numcallsinternal);
    }

    function selfDestruct() onlyOwner {
        selfdestruct(owner);
    }

    // reject value trasfers
    function() { throw; }
}",38: unchecked;
0x4B8e1ad58657F8b4b036AD12AfbCef54D24Ac9Ba,Safe,"contract BasicSign {

    event Created(
        address indexed from,
        uint256 id
    );
    event Signed(
        address indexed from,
        uint256 docId,
        uint8 singId,
        bytes16 signType,
        bytes sign
    );

    address owner;
    mapping (uint256 => Document) public documents;

    struct Document {
        address organizer;
        Sign[] signs;
    }

    struct Sign {
        address signer;
        bytes16 signType;
        bytes   sign;
    }

    function SimpleSign() {
        owner = msg.sender;
    }

    function createDocument(uint256 nonce) returns (uint256 docId) {
        docId = generateId(nonce);
        if (documents[docId].organizer != 0) throw;
        documents[docId].organizer = msg.sender;
        Created(msg.sender, docId);
    }

    function removeDocument(uint256 docId) {
        Document doc = documents[docId];
        if (doc.organizer != msg.sender) throw;
        delete documents[docId];
    }

    function addSignature(uint256 docId, bytes16 _type, bytes _sign) {
        Document doc = documents[docId];
        if (doc.organizer != msg.sender) throw;
        if (doc.signs.length >= 0xFF) throw;
        uint idx = doc.signs.push(Sign(msg.sender, _type, _sign));
        Signed(msg.sender, docId, uint8(idx), _type, _sign);
    }

    function getDocumentDetails(uint256 docId) returns (address organizer, uint count) {
        Document doc = documents[docId];
        organizer = doc.organizer;
        count = doc.signs.length;
    }

    function getSignsCount(uint256 docId) returns (uint) {
        return documents[docId].signs.length;
    }

    function getSignDetails(uint256 docId, uint8 signId) returns (address, bytes16) {
        Document doc = documents[docId];
        Sign s = doc.signs[signId];
        return (s.signer, s.signType);
    }

    function getSignData(uint256 docId, uint8 signId) returns (bytes) {
        Document doc = documents[docId];
        Sign s = doc.signs[signId];
        return s.sign;
    }

    function generateId(uint256 nonce) returns (uint256) {
        return uint256(sha3(msg.sender, nonce));
    }

    function () {
        throw;
    }

}",S
0x9C169d81420aAD7D8a0D6d9F295C3ba2C33575De,Safe,"contract Ballot {
    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }
    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    /// Create a new ballot with $(_numProposals) different proposals.
    function Ballot(uint8 _numProposals) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    /// Give $(voter) the right to vote on this ballot.
    /// May only be called by $(chairperson).
    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) return;
        voters[voter].weight = 1;
    }

    /// Delegate your vote to the voter $(to).
    function delegate(address to) {
        Voter sender = voters[msg.sender]; // assigns reference
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter delegate = voters[to];
        if (delegate.voted)
            proposals[delegate.vote].voteCount += sender.weight;
        else
            delegate.weight += sender.weight;
    }

    /// Give a single vote to proposal $(proposal).
    function vote(uint8 proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted || proposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = proposal;
        proposals[proposal].voteCount += sender.weight;
    }

    function winningProposal() constant returns (uint8 winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 proposal = 0; proposal < proposals.length; proposal++)
            if (proposals[proposal].voteCount > winningVoteCount) {
                winningVoteCount = proposals[proposal].voteCount;
                winningProposal = proposal;
            }
    }
}",S
0xB071e5c53094Cabb971E98EBA3B1A86BE555c943,Safe,"contract IOU {
    address owner;

/* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;

/* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

/* This generates a public event on the blockchain that will notify clients */
event Transfer(address indexed from, address indexed to, uint256 value);

    function IOU(string tokenName, string tokenSymbol, uint8 decimalUnits) {
        owner = msg.sender;                                 // sets main RipplePay contract as owner
        name = tokenName;                                       // Set the name for display purposes
        symbol = tokenSymbol;                                     // Set the symbol for display purposes
        decimals = decimalUnits;                                       // Amount of decimals for display purposes

    }

    /* update balances so they display in ethereum-wallet */
    function transfer(address _from, address _to, uint256 _value) {
        if(msg.sender != owner) throw;                       // can only be invoked by main RipplePay contract
        balanceOf[_from] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

}



contract RipplePayMain {

mapping(string => address) currencies;

function newCurrency(string currencyName, string currencySymbol, uint8 decimalUnits){
currencies[currencySymbol] = new IOU(currencyName, currencySymbol, decimalUnits);
}

function issueIOU(string _currency, uint256 _amount, address _to){
    // update creditLines in main contract, then update balances in IOU contract to display in ethereum-wallet
    IOU(currencies[_currency]).transfer(msg.sender, _to, _amount);

}

}",S
0xb377dc0593ebce801cdfff2e0c8f786983f7d2e7,Safe,"contract  Ballot{
    struct Voter{
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }

    struct Proposal{
        bytes32 name;
        uint voteCount;
    }

    address public chairperson  ;

    mapping(address=>Voter) voters;

    Proposal[] public proposals;

    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        for(uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount:0
            }));
        }

    }

    function giveRightToVote(address voter) {

        if(msg.sender != chairperson || voters[voter].voted){
            throw;
        }

        voters[voter].weight = 1;

    }

    function delegate(address to){

        Voter sender = voters[msg.sender];
        if (sender.voted)
            throw;

        while (
            voters[to].delegate != address(0)&&
            voters[to].delegate != msg.sender
        ){
            to = voters[to].delegate;
        }

        if (to == msg.sender)
            throw;

        sender.voted = true;
        sender.delegate = to;
        Voter delegate = voters[to];
        if  (delegate.voted) {
            proposals[delegate.vote].voteCount += sender.weight;
        }else {
            delegate.weight += sender.weight;
        }

    }


    function vote(uint proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted)
            throw;

        sender.voted=true;
        sender.vote=proposal;
        proposals[proposal].voteCount += sender.weight;

    }

    function winningProtocal() returns (uint proposal)
    {
        proposal = 0;
        uint maxCount = 0;
        for (uint i = 0 ; i < proposals.length ; i++) {
            if (proposals[i].voteCount > maxCount) {
                proposal = i;
                maxCount = proposals[i].voteCount;
            }
        }

        //return proposal;
    }



}",S
0xfbd9986b21fbc0d718d3999a640fe41391b5694d,Safe,"// `interface` would make a nice keyword ;)
contract TheDaoHardForkOracle {
    // `ran()` manually verified true on both ETH and ETC chains
    function forked() constant returns (bool);
}

// demostrates calling own function in a ""reversible"" manner
/* important lines are marked by multi-line comments */
contract ReversibleDemo {
    // counters (all public to simplify inspection)
    uint public numcalls;
    uint public numcallsinternal;
    uint public numfails;
    uint public numsuccesses;

    address owner;

    // needed for ""naive"" and ""oraclized"" checks
    address constant withdrawdaoaddr = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;
    TheDaoHardForkOracle oracle = TheDaoHardForkOracle(0xe8e506306ddb78ee38c9b0d86c257bd97c2536b3);

    event logCall(uint indexed _numcalls,
                  uint indexed _numfails,
                  uint indexed _numsuccesses);

    modifier onlyOwner { if (msg.sender != owner) throw; _ }
    modifier onlyThis { if (msg.sender != address(this)) throw; _ }

    // constructor (setting `owner` allows later termination)
    function ReversibleDemo() { owner = msg.sender; }

    /* external: increments stack height */
    /* onlyThis: prevent actual external calling */
    function sendIfNotForked() external onlyThis returns (bool) {
        numcallsinternal++;

        /* naive check for ""is this the classic chain"" */
        // guaranteed `true`: enough has been withdrawn already
        //     three million ------> 3'000'000
        if (withdrawdaoaddr.balance < 3000000 ether) {
            /* intentionally not checking return value */
            owner.send(42);
        }

        /* ""reverse"" if it's actually the HF chain */
        if (oracle.forked()) throw;

        // not exactly a ""success"": send() could have failed on classic
        return true;
    }

    // accepts value transfers
    function doCall(uint _gas) onlyOwner {
        numcalls++;

        if (!this.sendIfNotForked.gas(_gas)()) {
            numfails++;
        }
        else {
            numsuccesses++;
        }
        logCall(numcalls, numfails, numsuccesses);
    }

    function selfDestruct() onlyOwner {
        selfdestruct(owner);
    }

    // accepts value trasfers, but does nothing
    function() {}
}",S
0x8a772004af0b8fca5e7093c6f277ba7b0e8fa97a,Safe,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function sendApproval(address _from, uint256 _value, address _token); }

contract MyToken is owned {
    /* Public variables of the token */
    string public name;
    string public symbol;
    uint8 public decimals;
	uint8 public disableconstruction;
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyTokenLoad(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {
		if(disableconstruction != 2){
            if(centralMinter != 0 ) owner = msg.sender;         // Sets the minter
            balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
            name = tokenName;                                   // Set the name for display purposes
            symbol = tokenSymbol;                               // Set the symbol for display purposes
            decimals = decimalUnits;                            // Amount of decimals for display purposes
		}
    }
    function MyToken(){
        MyTokenLoad(10000000000000,'Kraze',8,'KRZ',0);
		disableconstruction=2;
    }
    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}",S
0x85b846d361f861c9363f769e65f76b83dc80b531,Safe,"pragma solidity ^0.4.2;
contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    /// Create a new ballot with $(_numProposals) different proposals.
    function Ballot(uint8 _numProposals) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    /// Give $(voter) the right to vote on this ballot.
    /// May only be called by $(chairperson).
    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) return;
        voters[voter].weight = 1;
    }

    /// Delegate your vote to the voter $(to).
    function delegate(address to) {
        Voter sender = voters[msg.sender]; // assigns reference
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter delegate = voters[to];
        if (delegate.voted)
            proposals[delegate.vote].voteCount += sender.weight;
        else
            delegate.weight += sender.weight;
    }

    /// Give a single vote to proposal $(proposal).
    function vote(uint8 proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted || proposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = proposal;
        proposals[proposal].voteCount += sender.weight;
    }

    function winningProposal() constant returns (uint8 winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 proposal = 0; proposal < proposals.length; proposal++)
            if (proposals[proposal].voteCount > winningVoteCount) {
                winningVoteCount = proposals[proposal].voteCount;
                winningProposal = proposal;
            }
    }
}",S
0xd18e21bb13d154a16793c6f89186a034a8116b74,Safe,"contract ZeroDollarHomePage {
    event InvalidPullRequest(uint indexed pullRequestId);
    event PullRequestAlreadyClaimed(uint indexed pullRequestId, uint timeBeforeDisplay, bool past);
    event PullRequestClaimed(uint indexed pullRequestId, uint timeBeforeDisplay);
    event QueueIsEmpty();

    bool _handledFirst;
    uint[] _queue;
    uint _current;
    address owner;

    function ZeroDollarHomePage() {
        owner = msg.sender;
        _handledFirst = false;
        _current = 0;
    }

    function remove() {
        if (msg.sender == owner){
            suicide(owner);
        }
    }

    /*
     * Register a new pull request.
     */
    function newRequest(uint pullRequestId) {
        if (pullRequestId <= 0) {
            InvalidPullRequest(pullRequestId);
            return;
        }

        // Check that the pr hasn't already been claimed
        bool found = false;
        uint index = 0;

        while (!found && index < _queue.length) {
            if (_queue[index] == pullRequestId) {
                found = true;
                break;
            } else {
                index++;
            }
        }

        if (found) {
            PullRequestAlreadyClaimed(pullRequestId, (index - _current) * 1 days, _current > index);
            return;
        }

        _queue.push(pullRequestId);
        PullRequestClaimed(pullRequestId, (_queue.length - _current) * 1 days);
    }

    /*
     * Close the current request in queue and move the queue to its next element.
     */
    function closeRequest() {
        if (_handledFirst && _current < _queue.length - 1) {
            _current += 1;
        }

        _handledFirst = true;
    }

    /*
     * Get the last non published pull-request from the queue
     */
    function getLastNonPublished() constant returns (uint pullRequestId) {
        if (_current >= _queue.length) {
            return 0;
        }

        return _queue[_current];
    }
}",S
0x27c41d20014fa87291006d02ddd81b2128039bd7,Safe,"//! Github Hinting contract.
//! By Gav Wood (Ethcore), 2016.
//! Released under the Apache Licence 2.

contract GithubHint {
    struct Entry {
        string accountSlashRepo;
        bytes20 commit;
        address owner;
    }

    modifier when_edit_allowed(bytes32 _content) { if (entries[_content].owner != 0 && entries[_content].owner != msg.sender) return; _ }

    function hint(bytes32 _content, string _accountSlashRepo, bytes20 _commit) when_edit_allowed(_content) {
        entries[_content] = Entry(_accountSlashRepo, _commit, msg.sender);
    }

    function hintURL(bytes32 _content, string _url) when_edit_allowed(_content) {
        entries[_content] = Entry(_url, 0, msg.sender);
    }

    function unhint(bytes32 _content) when_edit_allowed(_content) {
        delete entries[_content];
    }

    mapping (bytes32 => Entry) public entries;
}",S
0x993bbc77c48ca648659129602dd507a96bc5b561,Safe,"// Refund contract for trust DAO #37

contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
    uint public totalSupply;
}

contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x1ca6abd14d30affe533b24d7a21bff4c2d5e1f3b);
    address constant public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    function trusteeWithdraw() {
        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());
    }
}",21: unchecked;
0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6,Safe,"// https://github.com/ConsenSys/uport-registry

pragma solidity 0.4.8;

contract UportRegistry{
  uint public version;
  address public previousPublishedVersion;
  mapping(bytes32 => mapping(address => mapping(address => bytes32))) public registry;

  function UportRegistry(address _previousPublishedVersion) {
    version = 3;
    previousPublishedVersion = _previousPublishedVersion;
  }

  event Set(
    bytes32 indexed registrationIdentifier,
    address indexed issuer,
    address indexed subject,
    uint updatedAt);

  //create or update
  function set(bytes32 registrationIdentifier, address subject, bytes32 value){
      Set(registrationIdentifier, msg.sender, subject, now);
      registry[registrationIdentifier][msg.sender][subject] = value;
  }

  function get(bytes32 registrationIdentifier, address issuer, address subject) constant returns(bytes32){
      return registry[registrationIdentifier][issuer][subject];
  }
}",S
0x466f39a5fd8d1bd54ea7e82975177c0f00c68492,Safe,"contract SimpleLotto {
    int public playCount = 0;
    address public owner = msg.sender;
    mapping (address => uint) public players;
    Aggregate public aggregate;

  struct Aggregate {
    uint msgValue;
    uint gas;
  }

    modifier onlyBy(address _account) {
        if (msg.sender != _account)
            throw;
        _
    }

    function SimpleLotto() {
        playCount = 42;
    }

    event Sent(address from, address to, int amount);

    function play(address receiver, uint amount) returns (uint){
        playCount++;
        Sent(owner, receiver, playCount);
        players[receiver] += amount;

        aggregate.msgValue = msg.value;
        aggregate.gas = msg.gas;

        return msg.value;
    }

    function terminate() {
        if (msg.sender == owner)
            suicide(owner);
    }

    function terminateAlt() onlyBy(owner) {
            suicide(owner);
    }
}",S
0xcd3e727275bc2f511822dc9a26bd7b0bbf161784,Safe,"/*
http://platform.dao.casino
For questions contact noxon i448539@gmail.com
*/

pragma solidity ^0.4.8;

//ide http://dapps.oraclize.it/browser-solidity/

// <ORACLIZE_API>
/*
Copyright (c) 2015-2016 Oraclize SRL
Copyright (c) 2016 Oraclize LTD



Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:



The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.



THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

pragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0

contract OraclizeI {
    address public cbAddress;
    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);
    function getPrice(string _datasource) returns (uint _dsprice);
    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);
    function useCoupon(string _coupon);
    function setProofType(byte _proofType);
    function setConfig(bytes32 _config);
    function setCustomGasPrice(uint _gasPrice);
}
contract OraclizeAddrResolverI {
    function getAddress() returns (address _addr);
}
contract usingOraclize {
    uint constant day = 60*60*24;
    uint constant week = 60*60*24*7;
    uint constant month = 60*60*24*30;
    byte constant proofType_NONE = 0x00;
    byte constant proofType_TLSNotary = 0x10;
    byte constant proofStorage_IPFS = 0x01;
    uint8 constant networkID_auto = 0;
    uint8 constant networkID_mainnet = 1;
    uint8 constant networkID_testnet = 2;
    uint8 constant networkID_morden = 2;
    uint8 constant networkID_consensys = 161;

    OraclizeAddrResolverI OAR;

    OraclizeI oraclize;
    modifier oraclizeAPI {
        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);
        oraclize = OraclizeI(OAR.getAddress());
        _;
    }
    modifier coupon(string code){
        oraclize = OraclizeI(OAR.getAddress());
        oraclize.useCoupon(code);
        _;
    }

    function oraclize_setNetwork(uint8 networkID) internal returns(bool){
        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet
            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);
            return true;
        }
        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet
            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);
            return true;
        }
        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ //ether.camp ide
            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);
            return true;
        }
        if (getCodeSize(0x93bbbe5ce77034e3095f0479919962a903f898ad)>0){ //norsborg testnet
            OAR = OraclizeAddrResolverI(0x93bbbe5ce77034e3095f0479919962a903f898ad);
            return true;
        }
        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity
            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);
            return true;
        }
        return false;
    }

    function __callback(bytes32 myid, string result) {
        __callback(myid, result, new bytes(0));
    }
    function __callback(bytes32 myid, string result, bytes proof) {
    }

    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource);
    }
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
        return oraclize.getPrice(datasource, gaslimit);
    }

    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(0, datasource, arg);
    }
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query.value(price)(timestamp, datasource, arg);
    }
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);
    }
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
    }
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);
    }
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource);
        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
    }
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
    }
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
        uint price = oraclize.getPrice(datasource, gaslimit);
        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
    }
    function oraclize_cbAddress() oraclizeAPI internal returns (address){
        return oraclize.cbAddress();
    }
    function oraclize_setProof(byte proofP) oraclizeAPI internal {
        return oraclize.setProofType(proofP);
    }
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {
        return oraclize.setCustomGasPrice(gasPrice);
    }
    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {
        return oraclize.setConfig(config);
    }

    function getCodeSize(address _addr) constant internal returns(uint _size) {
        assembly {
            _size := extcodesize(_addr)
        }
    }


    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }


    function strCompare(string _a, string _b) internal returns (int) {
        bytes memory a = bytes(_a);
        bytes memory b = bytes(_b);
        uint minLength = a.length;
        if (b.length < minLength) minLength = b.length;
        for (uint i = 0; i < minLength; i ++)
            if (a[i] < b[i])
                return -1;
            else if (a[i] > b[i])
                return 1;
        if (a.length < b.length)
            return -1;
        else if (a.length > b.length)
            return 1;
        else
            return 0;
   }

    function indexOf(string _haystack, string _needle) internal returns (int)
    {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length))
            return -1;
        else if(h.length > (2**128 -1))
            return -1;
        else
        {
            uint subindex = 0;
            for (uint i = 0; i < h.length; i ++)
            {
                if (h[i] == n[0])
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }
    }

    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        bytes memory _bc = bytes(_c);
        bytes memory _bd = bytes(_d);
        bytes memory _be = bytes(_e);
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
        bytes memory babcde = bytes(abcde);
        uint k = 0;
        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
        return string(babcde);
    }

    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, """");
    }

    function strConcat(string _a, string _b, string _c) internal returns (string) {
        return strConcat(_a, _b, _c, """", """");
    }

    function strConcat(string _a, string _b) internal returns (string) {
        return strConcat(_a, _b, """", """", """");
    }

    // parseInt
    function parseInt(string _a) internal returns (uint) {
        return parseInt(_a, 0);
    }

    // parseInt(parseFloat*10^_b)
    function parseInt(string _a, uint _b) internal returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }

    function uint2str(uint i) internal returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint len;
        while (j != 0){
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }



}
// </ORACLIZE_API>



contract HackDao is usingOraclize {

   struct Game {
	    address player;
	    bool results;
	    uint betsvalue;
	    uint betslevel;
	}

  mapping (bytes32 => address) bets;
  mapping (bytes32 => bool) public results;
  mapping (bytes32 => uint) betsvalue;
  mapping (bytes32 => uint) betslevel;
  address public owner;



  function HackDao() {

    if (owner>0) throw;
    owner = msg.sender;
    //oraclize_setNetwork(networkID_consensys);
    }

  modifier onlyOwner {
        if (msg.sender != owner)
            throw;
        _;
    }

  event LogB(bytes32 h);
  event LogS(string s);
  event LogI(uint s);

	  function game (uint level) payable returns (bytes32) {

	   if (msg.value <= 0) throw;
	   if (level > 10) throw;
	   if (level < 1) throw;


	   //temprorary  disabled
	   /*
	   if (level == 1 && msg.value < 0.99 ether) throw;
	   if (level == 2 && msg.value < 0.99 ether*1.09) throw;
	   if (level == 3 && msg.value < 0.99 ether*1.3298) throw;
	   if (level == 4 && msg.value < 0.99 ether*1.86172) throw;
	   if (level == 5 && msg.value < 0.99 ether*3.0346036) throw;
	   if (level == 6 && msg.value < 0.99 ether*5.947823056) throw;
	   if (level == 7 && msg.value < 0.99 ether*14.5721664872) throw;
	   if (level == 8 && msg.value < 0.99 ether*47.505262748272) throw;
	   if (level == 9 && msg.value < 0.99 ether*232.7757874665328) throw;
	   */


	   if (msg.value > 10 ether) throw;

  	   uint random_number;

	   if (msg.value < 5 ether) {
    	    myid = bytes32(keccak256(msg.sender, block.blockhash(block.number - 1)));
    	    random_number = uint(block.blockhash(block.number-1))%10 + 1;
	   } else {
	        bytes32 myid = oraclize_query(""WolframAlpha"", ""random integer number between 1 and 10"");
	   }

  	   bets[myid] = msg.sender;
  	   betsvalue[myid] = msg.value; //-10000000000000000 ставка за вычитом расходов на оракула ~0.01 eth
  	   betslevel[myid] = level;

  	   if (random_number > 0) __callback(myid, uint2str(random_number),true);

  	   LogB(myid);


  	   return myid;
	  }

	  function get_return_by_level(uint level) {

	  }


	  function __callback(bytes32 myid, string result) {
	      __callback(myid, result, false);
	  }

	  function __callback(bytes32 myid, string result, bool ishashranodm) {
        LogS('callback');
        if (msg.sender != oraclize_cbAddress() && ishashranodm == false) throw;

        //log0(result);

        //TODO alex bash


        LogB(myid);

        if (parseInt(result) > betslevel[myid]) {
            LogS(""win"");
            LogI(betslevel[myid]);
            uint koef;
            if (betslevel[myid] == 1) koef = 109; //90
            if (betslevel[myid] == 2) koef = 122; //80
            if (betslevel[myid] == 3) koef = 140; //70
            if (betslevel[myid] == 4) koef = 163; //
            if (betslevel[myid] == 5) koef = 196;
            if (betslevel[myid] == 6) koef = 245;
            if (betslevel[myid] == 7) koef = 326;
            if (betslevel[myid] == 8) koef = 490;
            if (betslevel[myid] == 9) koef = 980;

            if (!bets[myid].send(betsvalue[myid]*koef/100)) {LogS(""bug! bet to winner was not sent!"");} else {
                //LogI();
              }
            results[myid] = true;
        } else {

            LogS(""lose"");
            results[myid] = false;
        }

      }


      function ownerDeposit() payable onlyOwner  {

      }

      function ownerWithdrawl() onlyOwner  {
        owner.send(this.balance);
      }

}",S
0x9c9dc2b707a99ae4b6795538ac6bf4f6d4842830,Safe,"/* A contract to exchange encrypted messages. Most of the work done on
   the client side. */

contract comm_channel {

    address owner;

    event content(string datainfo, string senderKey, string recipientKey, uint amount);
    modifier onlyowner { if (msg.sender == owner) _ }

    function comm_channel() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo, string senderKey, string recipientKey,
                 address resendTo) {

        //try to resend money from message to the address
        if(msg.value > 0) {
            if(resendTo == 0) throw;
            if(!resendTo.send(msg.value)) throw;
        }

        //write to blockchain
        content(datainfo, senderKey, recipientKey, msg.value);
    }
}",17: uchecked;
0xa43ebd8939d8328f5858119a3fb65f65c864c6dd,Safe,"pragma solidity ^0.4.4;
/*
* This is a contract for debloating the state
* @author mhswende
**/
contract Sweeper
{
    //Solidity implentation
    function sol_clean(uint256 s, uint i){
        uint x = s;
        address b = 0;
        for(uint c=0 ; c < i ; c++){
            x = x+s;
            b = address(x/0x1000000000000000000000000);
            b.send(0);

        }
    }
    //Asm implementation
    function asm_clean(uint s, uint i)
    {

        assembly{
            let seed := calldataload(4)//4 if we're using a named function
            let iterations := calldataload(36)
            let target :=seed

        loop:
            target := add(target,seed)
            pop(call(0,div(target,0x1000000000000000000000000),0,0,0,0,0))
            iterations := sub(iterations,1)
            jumpi(loop, iterations)
        }
    }
}",15: unchecked;
0xcc39e8ab206229c95b9649ead3560e1712a72eed,Safe,"pragma solidity ^0.4.8;

contract UportRegistry{
  uint public version;
  address public previousPublishedVersion;
  mapping(bytes32 => mapping(address => mapping(address => bytes32))) public registry;

  function UportRegistry(address _previousPublishedVersion) {
    version = 2;
    previousPublishedVersion = _previousPublishedVersion;
  }

  event Set(
    bytes32 indexed registrationIdentifier,
    address indexed attestor,
    address indexed attestee);

  //create or update
  function set(bytes32 registrationIdentifier, address attestee, bytes32 value){
      Set(registrationIdentifier, msg.sender, attestee);
      registry[registrationIdentifier][msg.sender][attestee] = value;
  }

  function get(bytes32 registrationIdentifier, address attestor, address attestee) returns(bytes32){
      return registry[registrationIdentifier][attestor][attestee];
  }
}",S
0xf236d15aa8164626e3457cd38e69d7f46f95eeb9,Safe,"contract comm_channel {

    address owner;

    event content(string datainfo, uint indexed version, string indexed senderKey, string indexed recipientKey, uint amount);
    modifier onlyowner { if (msg.sender == owner) _ }

    function comm_channel() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo, uint version, string senderKey, string recipientKey,
                 address resendTo) {

        //try to resend money from message to the address
        if(msg.value > 0) {
            if(resendTo == 0) throw;
            if(!resendTo.send(msg.value)) throw;
        }

        //write to blockchain
        content(datainfo, version, senderKey, recipientKey, msg.value);
    }
}",S
0xb57acd47240599d0c68f14892dd05441af67e2d3,Safe,"contract SimpleLotto {
    int public playCount = 0;
    int public playCount1;
    address public owner = msg.sender;
    mapping (address => uint) public players;
    My public aloha;

  struct My {
    string a;
    int b;
  }

    modifier onlyBy(address _account) {
        if (msg.sender != _account)
            throw;
        _
    }

    function SimpleLotto() {
        playCount1 = 42;
    }

    event Sent(address from, address to, int amount);

    function play(address receiver, uint amount) returns (uint){
        playCount++;
        playCount1++;
        Sent(owner, receiver, playCount);
        players[receiver] += amount;

        aloha.a = ""hi"";
        aloha.b = playCount1;

        return msg.value;
    }

    function terminate() {
        if (msg.sender == owner)
            suicide(owner);
    }

    function terminateAlt() onlyBy(owner) {
            suicide(owner);
    }
}",S
0xcf31dd376d15db527375b8c2b24e0ef45bcf71b6,Safe,"pragma solidity ^0.4.0;


contract testing {
  mapping (address => uint256) public balanceOf;
  event Transfer(address indexed from, address indexed to, uint256 value);
  event LogB(bytes32 h);


  	function buy() payable returns (uint amount){
        amount = msg.value ;                     // calculates the amount
        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
        balanceOf[this] -= amount;                         // subtracts amount from seller's balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
        return amount;                                     // ends function and returns
    }


}",S
0xf1aa63ad7a897ca02cab6021513ee0a86820153e,Safe,"// EthVenture plugin
// TESTING CONTRACT

contract EthVenturePlugin {

address public owner;


function EthVenturePlugin() {
owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures
}


function() {

uint Fees = msg.value;

//********************************EthVenturesFinal Fee Plugin
    // payout fees to the owner
     if (Fees != 0)
     {
	uint minimal= 1999 finney;
	if(Fees<minimal)
	{
      	owner.send(Fees);		//send fee to owner
	}
	else
	{
	uint Times= Fees/minimal;

	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function
	if(Fees>0)
	{
	owner.send(minimal);		//send fee to owner
	Fees-=minimal;
	}
	}
     }
//********************************End Plugin

}

// AAAAAAAAAAAAAND IT'S STUCK!

}",34: unchecked;
0x144bf2bbc61a5ae867d7e1fd603015df7f6d4fb6,Safe,"contract CoinFlipLotto
{
    address owner = msg.sender;
    uint msgValue;
    uint msgGas;
    string greeting;

    function Greeter(string _greeting) public
    {

        msgValue = msg.value;
        msgGas = msg.gas;
        greeting = _greeting;
    }

    modifier onlyBy(address _account)
    {
        if (msg.sender != _account)
            throw;
        _
    }

    function greet()  constant returns (string)
    {
        return greeting;
    }

    function getBlockNumber()  constant returns (uint)  // this doesn't have anything to do with the act of greeting
    {													// just demonstrating return of some global variable
        return block.number;
    }

    function setGreeting(string _newgreeting)
    {
        greeting = _newgreeting;
    }

    function terminate()
    {
        if (msg.sender == owner)
            suicide(owner);
    }

    function terminateAlt() onlyBy(owner)
    {
            suicide(owner);
    }


}",S
0x260972db3571a4297b9e0cfa237eabbc9c6e35ce,Safe,"/* A contract to exchange encrypted messages. Most of the work done on
   the client side. */

contract comm_channel {

    address owner;

    event content(string datainfo, string senderKey, string recipientKey, uint amount);
    modifier onlyowner { if (msg.sender == owner) _ }

    function comm_channel() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo, string senderKey, string recipientKey,
                 address resendTo) {

        //try to resend money from message to the address
        if(msg.value > 0) {
            if(!resendTo.send(msg.value)) throw;
        }

        //write to blockchain
        content(datainfo, senderKey, recipientKey, msg.value);
    }
}",17: unchecked;
0xd1c37dffd4ef36867c5bd7e59566358ea3d21e63,Safe,"// Refund contract for trust DAO #39

contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
    uint public totalSupply;
}

contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x6131c42fa982e56929107413a9d526fd99405560);
    address constant public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    function trusteeWithdraw() {
        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());
    }
}",21: unchecked;
0x4C2C4511BA8F5B5f356ADF7eaeBCE8dD2ea9a9c6,Safe,"pragma solidity ^0.4.0;
contract BlockmaticsGraduationCertificate {
    address public owner = msg.sender;
    string certificate;


    function publishGraduatingClass(string cert) {
        if (msg.sender != owner)
            throw;
        certificate = cert;
    }


    function showBlockmaticsCertificate() constant returns (string) {
        return certificate;
    }
}",S
0xa35fc4d3ea15e0d9272dc181ee1c2761d5d0cabd,Safe,"contract UsernameRegistry {

  mapping(address => string) addr_to_str;
  mapping(string => address) str_to_addr;

  function register(string username) {
    if (str_to_addr[username] != address(0)) {
      // username taken
      throw;
    }
    str_to_addr[addr_to_str[msg.sender]] = address(0);
    addr_to_str[msg.sender] = username;
    str_to_addr[username] = msg.sender;
  }

  function get_username(address addr) constant returns (string) {
    return addr_to_str[addr];
  }

  function get_address(string username) constant returns (address) {
    return str_to_addr[username];
  }
}",S
0x139759b6Cfada56ccf5B3536f21EAC209140A9d4,Safe,"pragma solidity ^0.4.2;
contract Token {
    address public issuer;
    mapping (address => uint) public balances;

    function Token() {
        issuer = msg.sender;
        balances[issuer] = 1000000;
    }

    function transfer(address _to, uint _amount) {
        if (balances[msg.sender] < _amount) {
            throw;
        }

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
}",S
0x799f987acb75a571dd95f7fd152d30f50484b837,Safe,"pragma solidity ^0.4.8;

contract Sylence {

  struct User {
    uint16 pubKeysCount;
    mapping(uint16 => string) pubKeys;
  }
  mapping(bytes28 => User) users;

  address owner;

  function Sylence() { owner = msg.sender; }

  function getPubKeyByHash(bytes28 phoneHash) constant returns (string pubKey) {
    User u = users[phoneHash];
    pubKey = u.pubKeys[u.pubKeysCount];
  }

  function registerNewPubKeyForHash(bytes28 phoneHash, string pubKey) {
    if(msg.sender != owner) { throw; }
    User u = users[phoneHash];
    u.pubKeys[u.pubKeysCount++] = pubKey;
  }

}",S
0xb6cd94c7cdea8fa5cfad9210e3f2358ad8b0cd75,Safe,"pragma solidity ^0.4.2;
contract BlockmaticsGraduationCertificate_02102017 {
    address public owner = msg.sender;
    string certificate;
    bool certIssued = false;

    function publishGraduatingClass(string cert) {
        if (msg.sender != owner || certIssued)
            throw;
        certIssued = true;
        certificate = cert;
    }

    function showBlockmaticsCertificate() constant returns (string) {
        return certificate;
    }
}",S
0xf9e03d5e3d86277574cfd5f7e842f213cf88945f,Safe,"/* A contract to store only messages approved by owner */
contract self_store {

    address owner;

    uint16 public contentCount = 0;

    event content(string datainfo);

    function self_store() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() { if (msg.sender == owner) suicide(owner); }

    function add(string datainfo) {
        if (msg.sender != owner) return;
        contentCount++;
        content(datainfo);
    }

    function flush() {
        owner.send(this.balance);
    }
}",22: unchecked;
0xDea48D521832780f5e437F7f744c94d2CdA85Af9,Safe,"pragma solidity ^0.4.8;

contract testingToken {
	mapping (address => uint256) public balanceOf;
	address public owner;
	function testingToken() {
		owner = msg.sender;
		balanceOf[msg.sender] = 1000;
	}
	function send(address _to, uint256 _value) {
		if (balanceOf[msg.sender]<_value) throw;
		if (balanceOf[_to]+_value<balanceOf[_to]) throw;
		if (_value<0) throw;
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += _value;
	}
}",S
0x5f5d7147adb6ed31a2ca03ce3defb070a3be0ebb,Safe,"pragma solidity ^0.4.1;

contract EtherLovers {

  event LoversAdded(string lover1, string lover2);

  uint constant requiredFee = 100 finney;

  address private owner;

  function EtherLovers() public {
    owner = msg.sender;
  }

  modifier isOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }

  function declareLove(string lover1, string lover2) public payable {
    if (msg.value >= requiredFee) {
      LoversAdded(lover1, lover2);
    } else {
      throw;
    }
  }

  function collectFees() public isOwner() {
    msg.sender.send(this.balance);
  }

}",31: unchecked;
0x3d42f7eb6b97ab66d8d44c725651befe02a70e5e,Safe,"pragma solidity 0.4.4;

contract AddressNames{

	mapping(address => string) addressNames;

	function setName(string name){
		if(bytes(name).length >= 3){
			addressNames[msg.sender] = name;
		}
	}

	function hasName(address who) constant returns (bool hasAName){
		hasAName = bytes(addressNames[who]).length != 0;
	}

	function getName(address who) constant returns (string name){
		name = addressNames[who];
	}
}",S
0x60a76ea79eBC7264F2897EE7FE4f33F31ef25A74,Safe,"pragma solidity ^0.4.2;
contract BlockmaticsGraduationCertificate {
    address public owner = msg.sender;
    string certificate;
    bool certIssued = false;


    function publishGraduatingClass(string cert) {
        if (msg.sender != owner || certIssued)
            throw;
        certIssued = true;
        certificate = cert;
    }


    function showBlockmaticsCertificate() constant returns (string) {
        return certificate;
    }
}",S
0x7CF51743Ed1BCE645e1bB4A3619B73CC782C8de6,Safe,"pragma solidity ^0.4.0;
library TokenEventLib {
    event Transfer(address indexed _from,
                   address indexed _to,
                   bytes32 indexed _tokenID);
    event Approval(address indexed _owner,
                   address indexed _spender,
                   bytes32 indexed _tokenID);
    function _Transfer(address _from, address _to, bytes32 _tokenID) public {
        Transfer(_from, _to, _tokenID);
    }
    function _Approval(address _owner, address _spender, bytes32 _tokenID) public {
        Approval(_owner, _spender, _tokenID);
    }
}",S
0xD934eE44c22fE8cF0f43bf66620b3001D9172904,Safe,"pragma solidity ^0.4.0;

contract ContractPlay {
    address owner;
    uint16 numCalled;

    modifier onlyOwner {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    function ContractPlay() {
        owner = msg.sender;
    }

    function remove() onlyOwner {
        selfdestruct(owner);
    }

    function addFunds() payable {
        numCalled++;
    }

    function getNumCalled() returns (uint16) {
        return numCalled;
    }

    function() {
        throw;
    }
}",S
0x66943100bf0464c1ec43b957a5f72fe2d67a3678,Safe,"contract Escrow {

    address seller;
    address buyer;
    address arbiter;

    function Escrow() {
        buyer = msg.sender;
        seller = 0x1db3439a222c519ab44bb1144fc28167b4fa6ee6;
        arbiter = 0xd8da6bf26964af9d7eed9e03e53415d37aa96045;
    }

    function finalize() {
        if (msg.sender != buyer && msg.sender != arbiter) throw;
        seller.send(this.balance);
    }

    function refund() {
        if (msg.sender != seller && msg.sender != arbiter) throw;
        buyer.send(this.balance);
    }
}",15: unchecked; 20: unchecked;
0x2807e558a7eba8d25c3a05a0e7e9a6a437a6e6a4,Safe,"pragma solidity ^0.4.0;

contract Resolver {
    function supportsInterface(bytes4 interfaceID) constant returns (bool);
    function dnsrr(bytes32 node) constant returns (bytes data);
}

contract DNSResolver is Resolver {
    address public owner;
    mapping(bytes32=>bytes) zones;

    function OwnedResolver() {
        owner = msg.sender;
    }

    modifier owner_only {
        if(msg.sender != owner) throw;
        _;
    }

    function supportsInterface(bytes4 interfaceID) constant returns (bool) {
        return interfaceID == 0x126a710e;
    }

    function dnsrr(bytes32 node) constant returns (bytes data) {
        return zones[node];
    }

    function setDnsrr(bytes32 node, bytes data) owner_only {
        zones[node] = data;
    }
}",S
0x6c5c0e2496d27f60c486faaaaa9bde58ea1dc386,Safe,"pragma solidity ^0.4.8;

contract Sylence {

  struct User {
    uint256 pubKeysCount;
    mapping(uint256 => string) pubKeys;
  }
  mapping(string => User) users;

  address owner;
  function Sylence() { owner = msg.sender; }

  function getPubKeyByHash(string phoneHash) constant returns (string pubKey) {
    User u = users[phoneHash];
    pubKey = u.pubKeys[u.pubKeysCount];
  }

  function registerNewPubKeyForHash(string phoneHash, string pubKey) {
    if(msg.sender != owner) { throw; }
    users[phoneHash].pubKeys[++users[phoneHash].pubKeysCount] = pubKey;
  }

}",S
0x49311a711ea4aff7fea3e0c32066e732fe4652ba,Safe,"contract Oath {
	mapping (address => bytes) public sig;

	event LogSignature(address indexed from, bytes version);

	function Oath() {
		if(msg.value > 0) { throw; }
	}

	function sign(bytes version) public {
		if(sig[msg.sender].length != 0 ) { throw; }
		if(msg.value > 0) { throw; }

		sig[msg.sender] = version;
		LogSignature(msg.sender, version);
	}

	function () { throw; }
}",S
0x40ebf2d6e998a76a848c41908733b26e04adffe2,Safe,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}

contract ReplaySafeSend {
    // Fork oracle to use
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    function safeSend(address etcAddress) returns(bool) {
        if (!amIOnTheFork.forked() && etcAddress.send(msg.value)) {
            return true;
        }
        throw; // don't accept value transfer, otherwise it would be trapped.
    }

    // Reject value transfers.
    function() {
        throw;
    }
}",S
0xe601d4981FA105fEC023622bddE3f07C774b421F,Safe,"pragma solidity ^0.4.2;
contract Token {
    address public issuer;
    mapping (address => uint) public balances;

    function Token() {
        issuer = tx.origin;
        balances[issuer] = 10000000;
    }

    function transfer(address _to, uint _amount) {
        if (balances[msg.sender] < _amount) {
            throw;
        }

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
}",7: access control;
0xE7aA95217EB415B2c400c81e2B65359E720aB936,Safe,"contract Switch {
    address constant theWithdraw = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;
    function Switch() {
        forked = theWithdraw.balance > 10000 ether;
    }

    function transferringETC(address to) {
        if (forked)
            throw;
        if (!to.send(msg.value))
            throw;
    }

    function transferringETH(address to) {
        if (!forked)
            throw;
        if (!to.send(msg.value))
            throw;
    }

    bool public forked;
}",S
0xbad661c5a1970342ade69857689738b6c8d9da51,Safe,"contract AddressReg{

    address public owner;

    function setOwner(address _owner){
        if(msg.sender==owner)
            owner = _owner;
    }

    function AddressReg(){
        owner = msg.sender;
    }

    mapping (address=>bool) isVerifiedMap;

    function verify(address addr){
        if(msg.sender==owner)
            isVerifiedMap[addr] = true;
    }

    function deverify(address addr){
        if(msg.sender==owner)
            isVerifiedMap[addr] = false;
    }

    function hasPhysicalAddress(address addr) constant returns(bool){
        return isVerifiedMap[addr];
    }

}",S
0x8f4e3d448a318c1dec52b3f22d77132a39c62025,Safe,"pragma solidity ^0.4.1;

contract ForceSendHelper
{
    function ForceSendHelper(address _to) payable
    {
        selfdestruct(_to);
    }
}

contract ForceSend
{
    function send(address _to) payable
    {
        if (_to == 0x0) {
            throw;
        }
        ForceSendHelper s = (new ForceSendHelper).value(msg.value)(_to);
        if (address(s) == 0x0) {
            throw;
        }
    }

    function withdraw(address _to)
    {
        if (_to == 0x0) {
            throw;
        }
        if (!_to.send(this.balance)) {
            throw;
        }
    }
}",S
0x1c94f41ab9cd8faa8af45ae7827bf5a8f891f4cd,Safe,"/* A contract to store a list of messages. Obtainable as events. */

contract store {

    address owner;

    uint16 public contentCount = 0;

    event content(string datainfo, address sender, uint payment);
    modifier onlyowner { if (msg.sender == owner) _ }

    function store() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo) {
        contentCount++;
        content(datainfo, msg.sender, msg.value);
    }
}",18: unchecked;
0x0318179601a70085aeb488f178b081295b65ecc9,Safe,"contract self_store {

    address owner;

    uint public contentCount = 0;

    event content(string datainfo, uint indexed version);
    modifier onlyowner { if (msg.sender == owner) _ }

    function self_store() public { owner = msg.sender; }

    ///TODO: remove in release
    function kill() onlyowner { suicide(owner); }

    function flush() onlyowner {
        owner.send(this.balance);
    }

    function add(string datainfo, uint version) onlyowner {
        contentCount++;
        content(datainfo, version);
    }
}",16: unchecked;
0x627917e47cd111382ddf7fb1dc140d2daf8876b3,Safe,"contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) suicide(owner); }
}

contract store is mortal {

    uint16 public contentCount = 0;

    event content(string datainfo);

    function store() public {
    }

    function add(string datainfo) {
        contentCount++;
        content(datainfo);
    }
}",S
0x22F83d39A2148dD389ED4C7A9280f57D5c8679DA,Safe,"contract Emailer {
    /* Define variable owner of the type address*/
    address owner;
	event Sent(address from, uint256 price, string to, string body);

    function Emailer() {
        owner = msg.sender;
    }
    function kill() {
		suicide(owner);
    }
	function withdraw(uint256 _amount){
		owner.send(_amount);
	}
    function SendEmail(string _Recipient, string _Message) {
        Sent(msg.sender, msg.value, _Recipient, _Message);
    }
}",13: unchecked;
0x536c2622748118a82bc9fb15a450d828966d9761,Safe,"contract Prism {
    address constant theWithdraw = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;
    function Prism() {
        forked = theWithdraw.balance > 1 ether;
    }

    function transferETC(address to) {
        if (forked)
            throw;
        if (!to.send(msg.value))
            throw;
    }

    function transferETH(address to) {
        if (!forked)
            throw;
        if (!to.send(msg.value))
            throw;
    }

    bool public forked;
}",S
0xe47014f16c55ddd3add5b68b951e10fcea7da686,Safe,"pragma solidity ^0.4.2;

contract BlocklabTokenV1 {
	mapping (address => uint) balances;

	function BlocklabTokenV1() {
		balances[tx.origin] = 100000;
	}

	function sendCoin(address receiver, uint amount) returns(bool sufficient) {
		if (balances[msg.sender] < amount) return false;
		balances[msg.sender] -= amount;
		balances[receiver] += amount;
		return true;
	}

	function getBalance(address addr) returns(uint) {
		return balances[addr];
	}

	function () { throw; }
}",S
0xe0b8fce1183e31c995b40460e6cb6712fa929f59,Safe,"contract AmIOnTheFork {
    bool public forked = false;
    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;
    // Check the fork condition during creation of the contract.
    // This function should be called between block 1920000 and 1930000.
    // After that the status will be locked in.
    function update() {
        if (block.number >= 1920000 && block.number <= 1930000) {
            forked = darkDAO.balance < 3600000 ether;
        }
    }
    function() {
        throw;
    }
}",S
0xFE70f7D0Fe6Ceb71D4FC0308322fFA6098043E43,Safe,"contract ERW {
    string public EdgarRichardWunsche;
    string public Parents;
    string public DateOfBirth;
    string public DateOfDeath;
    string public Location;

    function ERW() {
        EdgarRichardWunsche = ""Edgar Richard Wunsche (12.11.1930-22.04.2016). Rest in Peace Dad. Love Alan."";
        DateOfBirth = ""12.11.1930"";
        DateOfDeath = ""22.04.2016"";
        Parents = ""Beloved son of Anna Wunsche (Moser) and Antonin Wunsche."";
        Location = ""Toronto, Ontario, Canada"";
    }

    function () {
        throw;     // Prevents accidental sending of ether
    }
}",S
0x1d11e5eaE3112dbD44f99266872FF1D07C77DCe8,Safe,"/*
Copyright (c) 2015-2016 Oraclize srl, Thomas Bertani
*/

contract OraclizeAddrResolver {

    address public addr;

    address owner;

    function OraclizeAddrResolver(){
        owner = msg.sender;
    }


    function getAddress() returns (address oaddr){
        return addr;
    }

    function setAddr(address newaddr){
        if (msg.sender != owner) throw;
        addr = newaddr;
    }

}",S
0xa9659531a174390b6921ffd540365bbb02297f10,Safe,"contract bbb{
    /* Define variable owner of the type address*/
    address owner;
	event EmailSent(address Sender, uint256 PricePaid, string EmailAddress, string Message);

    function bbb() {
        owner = msg.sender;
    }
    function Kill() {
		if(msg.sender==owner){
			suicide(owner);
		}
    }
	function Withdraw(uint256 AmountToWithdraw){
		owner.send(AmountToWithdraw);
	}
    function SendEmail(string EmailAddress, string Message) {
        EmailSent(msg.sender, msg.value, EmailAddress, Message);
    }
}",15: unchecked;
0x1e9d5e4ed8ef31cfece10b4c92c9057f991f36bc,Safe,"/*
Based on a contract built by Vlad and Vitalik for Ether signal
If you need a license, refer to WTFPL.
*/

contract EtherVote {
    event LogVote(bytes32 indexed proposalHash, bool pro, address addr);
    function vote(bytes32 proposalHash, bool pro) {
        // don't accept ether
        if (msg.value > 0) throw;
        // Log the vote
        LogVote(proposalHash, pro, msg.sender);
    }

    // again, no ether
    function () { throw; }
}",S
0xbeac5df5f1c56f949852c8589314036042c1d603,Safe,"pragma solidity ^0.4.8;

library ArrayLib {
  // Inserts to keep array sorted (assumes input array is sorted)
	function insertInPlace(uint8[] storage self, uint8 n) {
		uint8 insertingIndex = 0;

		while (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) {
			insertingIndex += 1;
		}

		self.length += 1;
		for (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) {
			self[i] = self[i - 1];
		}

		self[insertingIndex] = n;
	}
}",S
