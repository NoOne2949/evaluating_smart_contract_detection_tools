import csv
import os

from entities.Metrics import Metrics

artifacts_file = "csvs/smartbugs_curated_revised.csv"
vulnerability_file = "smartbugs-results/metadata/vulnerabilities_mapping_rev2.csv"
vulnerability_log = "vulnerabilities_log.csv"


def confronts_artifacts(artifact, contract_address, log_vulnerabilities):
    for row in artifact:
        address = row['name'].replace('.sol', '')
        if address == contract_address:
            artifact_vulnerabilities = parse_vulnerabilities(row['Tag'])
            artifact_vulnerabilities = set(
                (line, parse_artifact_vulnerability(vul)) for line, vul in artifact_vulnerabilities)
            log_vulnerabilities = set(log_vulnerabilities)

            common_vulnerabilities, artifact_only, log_only, metrics, single_vuln_metrics = compare_vulnerabilities(
                artifact_vulnerabilities, log_vulnerabilities)
            print(f"{contract_address} comparison results:")
            print(f"Right vulnerability found: {len(common_vulnerabilities)}/{len(artifact_vulnerabilities)}")
            print(f"Right vulnerability not found: {len(artifact_only)}/{len(artifact_vulnerabilities)}")
            print(f"Extra vulnerability found: {len(log_only)}\n")

            right_vulnerability_found = [len(common_vulnerabilities), len(artifact_vulnerabilities)]
            return metrics, single_vuln_metrics, right_vulnerability_found

    # in case artifact file is empty
    metrics = {
        'true_negative': 0,
        'true_positive': 0,
        'false_negative': 0,
        'false_positive': 0,
    }
    single_vuln_metrics = {
        'access_control': 0,
        'arithmetic': 0,
        'denial_service': 0,
        'reentrancy': 0,
        'unchecked_low_calls': 0,
        'bad_randomness': 0,
        'front_running': 0,
        'time_manipulation': 0,
        'short_addresses': 0
    }
    right_vulnerability_found = [0, 0]

    return metrics, single_vuln_metrics, right_vulnerability_found


def compare_vulnerabilities(artifact_vulnerabilities, log_vulnerabilities):
    metrics = {
        'true_negative': 0,
        'true_positive': 0,
        'false_negative': 0,
        'false_positive': 0,
    }
    single_vuln_metrics = {
        'access_control': 0,
        'arithmetic': 0,
        'denial_service': 0,
        'reentrancy': 0,
        'unchecked_low_calls': 0,
        'bad_randomness': 0,
        'front_running': 0,
        'time_manipulation': 0,
        'short_addresses': 0
    }

    common_vulnerabilities = []
    log_only = []
    artifact_only = artifact_vulnerabilities.copy()

    if len(artifact_vulnerabilities) == 0 and len(log_vulnerabilities) == 0:
        metrics['true_negative'] += 1
    if len(log_vulnerabilities) == 0 and len(artifact_vulnerabilities) > 0:
        metrics['false_negative'] += 1

    for line, vul in log_vulnerabilities:
        found = False
        for artifact_line, artifact_set_vul in artifact_vulnerabilities:
            if vul == artifact_set_vul:
                if "-" in line:
                    start, end = map(int, line.split('-'))
                    if start <= int(artifact_line) <= end:
                        common_vulnerabilities.append((artifact_line, vul))
                        artifact_only.discard((str(artifact_line), artifact_set_vul))
                        found = True
                        metrics['true_positive'] += 1
                        single_vuln_metrics[vul] += 1
                    else:
                        continue
                elif artifact_line == line:
                    common_vulnerabilities.append((artifact_line, vul))
                    artifact_only.discard((str(artifact_line), artifact_set_vul))
                    found = True
                    metrics['true_positive'] += 1
                    single_vuln_metrics[vul] += 1
        if not found:
            log_only.append((line, vul))
            metrics['false_positive'] += 1

    return common_vulnerabilities, artifact_only, log_only, metrics, single_vuln_metrics


def parse_artifact_vulnerability(vulnerability):
    if "arithmetic" in vulnerability:
        return "arithmetic"
    elif "unchecked" in vulnerability:
        return "unchecked_low_calls"
    elif "reentrancy" in vulnerability:
        return "reentrancy"
    elif "short" in vulnerability:
        return "short_addresses"
    elif "access" in vulnerability:
        return "access_control"
    elif "time manipulation" in vulnerability:
        return "time_manipulation"
    elif "random" in vulnerability:
        return "bad_randomness"
    elif "front" in vulnerability:
        return "front_running"
    elif "dos" in vulnerability or "denial" in vulnerability:
        return "denial_service"
    else:
        return vulnerability


def parse_vulnerabilities(vulnerability_string):
    vulnerabilities = []
    if vulnerability_string:
        for part in vulnerability_string.split(';'):
            if ': ' in part:
                vulnerability_line, vulnerability_name = part.split(': ')
                vulnerabilities.append((vulnerability_line.strip().lower(), vulnerability_name.strip().lower()))
    return vulnerabilities


def filter_vulnerabilities(mapping, headers, tool, row_vulnerabilities):
    vulnerabilities = []
    row_vulnerabilities = parse_vulnerabilities(row_vulnerabilities)

    for vulnerability in row_vulnerabilities:
        for row in mapping:
            if row[0] == tool and row[1] == vulnerability[1]:
                true_found = False
                for index, value in enumerate(row):
                    if value.strip().upper() == "TRUE":
                        true_found = True
                        if headers[index] == "Other" or headers[index] == "Ignore":
                            # print(f"{tool}:{vulnerability} discarded: has {headers[index]} class")
                            break
                        else:
                            vulnerabilities.append((vulnerability[0], headers[index]))
                            break
                if not true_found:
                    print(f"{tool}:{vulnerability} discarded: vulnerability not tagged")
                    pass

    return vulnerabilities


def extract_row_from_logs(artifacts):
    metrics = {
        'false_positive': 0,
        'false_negative': 0,
        'true_positive': 0,
        'true_negative': 0
    }
    right_vulnerability_found = {
        'found': 0,
        'total': 0
    }
    single_vulnerability_metrics = {
        'access_control': 0,
        'arithmetic': 0,
        'denial_service': 0,
        'reentrancy': 0,
        'unchecked_low_calls': 0,
        'bad_randomness': 0,
        'front_running': 0,
        'time_manipulation': 0,
        'short_addresses': 0
    }

    with open(vulnerability_file, 'r', newline='') as file:
        reader = csv.reader(file)
        headers = next(reader)
        mapping = list(reader)

    with open(vulnerability_log, 'r', newline='') as file:
        reader = csv.reader(file)
        sorted_rows = sorted(reader, key=lambda row: row[0])
        for row in sorted_rows:
            if row[0] == "slither":
                if row[2] == "Error/Fail":
                    continue
                elif row[2] == "FP":
                    # logica vero negativo
                    continue
                else:
                    vulnerabilities = filter_vulnerabilities(mapping, headers, row[0], row[2])
                    metrics_obtained, single_vuln_metrics, vuln_found = confronts_artifacts(artifacts, row[1],
                                                                                            vulnerabilities)
                    update_metrics(metrics, right_vulnerability_found, single_vulnerability_metrics, metrics_obtained,
                                   single_vuln_metrics, vuln_found)

    calculate_final_metrics(metrics, single_vulnerability_metrics, right_vulnerability_found)
    return None


def update_metrics(metrics, right_vulnerability_found, single_vulnerability_metrics, metrics_obtained,
                   single_vuln_metrics, vuln_found):
    metrics['false_positive'] += metrics_obtained['false_positive']
    metrics['false_negative'] += metrics_obtained['false_negative']
    metrics['true_positive'] += metrics_obtained['true_positive']
    metrics['true_negative'] += metrics_obtained['true_negative']
    right_vulnerability_found['found'] += vuln_found[0]
    right_vulnerability_found['total'] += vuln_found[1]
    single_vulnerability_metrics['access_control'] += single_vuln_metrics['access_control']
    single_vulnerability_metrics['arithmetic'] += single_vuln_metrics['arithmetic']
    single_vulnerability_metrics['denial_service'] += single_vuln_metrics['denial_service']
    single_vulnerability_metrics['reentrancy'] += single_vuln_metrics['reentrancy']
    single_vulnerability_metrics['unchecked_low_calls'] += single_vuln_metrics['unchecked_low_calls']
    single_vulnerability_metrics['bad_randomness'] += single_vuln_metrics['bad_randomness']
    single_vuln_metrics['front_running'] += single_vuln_metrics['front_running']
    single_vulnerability_metrics['time_manipulation'] += single_vuln_metrics['time_manipulation']
    single_vuln_metrics['short_addresses'] += single_vuln_metrics['short_addresses']


def calculate_final_metrics(metrics, single_vulnerability_metrics, vulnerabilities_found):
    true_positives = metrics['true_positive']
    true_negatives = metrics['true_negative']
    false_negatives = metrics['false_negative']
    false_positives = metrics['false_positive']

    accuracy = (true_positives + true_negatives) / (true_positives + true_negatives + false_negatives + false_positives)

    precision = true_positives / (true_positives + false_positives)

    recall = true_positives / (true_positives + false_negatives)

    f1_score = 2 * (precision * recall) / (precision + recall)
    print(f"\nTotal Metrics:")
    print(f"Total vulnerabilities found: {vulnerabilities_found['found']}/{vulnerabilities_found['total']}")
    print(f'True positives: {true_positives}')
    print(f'True negatives: {true_negatives}')
    print(f'False positives: {false_negatives}')
    print(f'False negatives: {false_positives}')
    print(f'Accuracy: {accuracy}')
    print(f'Precision: {precision}')
    print(f'Recall: {recall}')
    print(f'F1 Score: {f1_score}')
    for single_vulnerability_metric in single_vulnerability_metrics:
        print(f'{single_vulnerability_metric}: {single_vulnerability_metrics[single_vulnerability_metric]}')


def confront_vulnerability():
    if not os.path.exists(vulnerability_log):
        print("Vulnerability log not found")
        return

    with open(artifacts_file, 'r', newline='') as infile:
        reader = csv.DictReader(infile)
        artifacts = list(reader)

    if artifacts:
        extract_row_from_logs(artifacts)
